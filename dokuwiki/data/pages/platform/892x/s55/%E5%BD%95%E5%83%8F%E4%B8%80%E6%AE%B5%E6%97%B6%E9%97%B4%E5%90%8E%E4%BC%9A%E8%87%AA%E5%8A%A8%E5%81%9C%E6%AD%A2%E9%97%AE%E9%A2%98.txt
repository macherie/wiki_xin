====== 录像一段时间后会自动停止问题 ======
**用UCAM录像一段时间后会自动停止，查一下看是UCAM的问题还是我们系统问题。**

测试发现用UCAM每次录像到27.04min录像自动停掉，用我们自己的Camera发现每次录到38.24min会自动停掉，

仔细看录像的详细信息发现两个的resolution不一样，但是大小均是3.8G，这样问题就定位到录像最大文件大小限制了。

===== libmediaplayerservice/StagefrightRecorder.cpp =====


void StagefrightRecorder::setupMPEG4MetaData

(int64_t startTimeUs, int32_t totalBitRate,sp<MetaData> *meta){
    (*meta)->setInt64(kKeyTime, startTimeUs);
    (*meta)->setInt32(kKeyFileType, mOutputFormat);
    (*meta)->setInt32(kKeyBitRate, totalBitRate);
    (*meta)->setInt32(kKey64BitFileOffset, mUse64BitFileOffset);//use 64bit file offset
    if (mMovieTimeScale > 0) {
        (*meta)->setInt32(kKeyTimeScale, mMovieTimeScale);
    }
    if (mTrackEveryTimeDurationUs > 0) {
        (*meta)->setInt64(kKeyTrackTimeStatus, mTrackEveryTimeDurationUs);
    }
    if (mRotationDegrees != 0) {
        (*meta)->setInt32(kKeyRotation, mRotationDegrees);
    }
}
 
===== frameworks/av/media/libstagefright/MPEG4Writer.cpp =====


static const int64_t kMax64BitFileSize = 0x00ffffffffLL; \/\/fat32 max size limited to 4GB

status_t MPEG4Writer::start(MetaData *param) {

  if (mInitCheck != OK) {
        return UNKNOWN_ERROR;
    }

    /*
     * Check mMaxFileSizeLimitBytes at the beginning
     * since mMaxFileSizeLimitBytes may be implicitly
     * changed later for 32-bit file offset even if
     * user does not ask to set it explicitly.
     */
    if (mMaxFileSizeLimitBytes != 0) {
        mIsFileSizeLimitExplicitlyRequested = true;
    }

    int32_t use64BitOffset = 0;
    if (param &&
        param->findInt32(kKey64BitFileOffset, &use64BitOffset) &&
        use64BitOffset) {
        mUse32BitOffset = false;
        if (mMaxFileSizeLimitBytes == 0) {
            mMaxFileSizeLimitBytes = kMax64BitFileSize;//max file limit bytes use 64bit file offset
        }
   ............

}


bool MPEG4Writer::exceedsFileSizeLimit() {
    // No limit
    if (mMaxFileSizeLimitBytes == 0) {
        return false;
    }

    int64_t nTotalBytesEstimate = static_cast<int64_t>(mEstimatedMoovBoxSize);
    for (List<Track *>::iterator it = mTracks.begin();
         it != mTracks.end(); ++it) {
        nTotalBytesEstimate += (*it)->getEstimatedTrackSizeBytes();
    }

    if (!mStreamableFile) {
        // Add 1024 bytes as error tolerance
        return nTotalBytesEstimate + 1024 >= mMaxFileSizeLimitBytes;
    }
    // Be conservative in the estimate: do not exceed 95% of
    // the target file limit. For small target file size limit, though,
    // this will not help.
    return (nTotalBytesEstimate >= (95 * mMaxFileSizeLimitBytes) / 100);
}

**通过以上代码可发现，录像理论的最大大小是4G，系统取4G*95%=3.8G作为实际最大大小限制。**
把95改为10后，进行录像到0.4G时停掉，即验证猜想。
