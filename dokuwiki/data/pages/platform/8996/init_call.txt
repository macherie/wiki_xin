====如何控制驱动代码的初始化时间====
一般情况下，我们注册驱动代码的init函数使用module_init这个宏。但是使用这个宏，我们只能保证代码被运行，不能确定他的运行时间。在有些场合，我们需要保证某个驱动先于另一个驱动被启动，则这个宏的功能就无法完成我们的目的。（我觉得在MTK的代码平台下会比较常有这种情况）
===init.h===
在kernel/include/linux/init.h中module_init做了详尽的声明
<code c>
/*为了方便阅读，我修改了行的顺序*/
268 #define module_init(x)  __initcall(x)
214 #define __initcall(fn) device_initcall(fn)
196 #define pure_initcall(fn)               __define_initcall(fn, 0)
198 #define core_initcall(fn)               __define_initcall(fn, 1)
199 #define core_initcall_sync(fn)          __define_initcall(fn, 1s)
200 #define postcore_initcall(fn)           __define_initcall(fn, 2)
201 #define postcore_initcall_sync(fn)      __define_initcall(fn, 2s)
202 #define arch_initcall(fn)               __define_initcall(fn, 3)
203 #define arch_initcall_sync(fn)          __define_initcall(fn, 3s)
204 #define subsys_initcall(fn)             __define_initcall(fn, 4)
205 #define subsys_initcall_sync(fn)        __define_initcall(fn, 4s)
206 #define fs_initcall(fn)                 __define_initcall(fn, 5)
207 #define fs_initcall_sync(fn)            __define_initcall(fn, 5s)
208 #define rootfs_initcall(fn)             __define_initcall(fn, rootfs)
209 #define device_initcall(fn)             __define_initcall(fn, 6)
210 #define device_initcall_sync(fn)        __define_initcall(fn, 6s)
211 #define late_initcall(fn)               __define_initcall(fn, 7)
212 #define late_initcall_sync(fn)          __define_initcall(fn, 7s)
</code>
显然，module_init 等效于 device_initcall 从她后续的声明我们可以猜测，他的时间顺序要晚于arch_initcall等宏声明的函数。
===实践===
处于MTK平台的局限，我现在有个需求，需要将fm的代码先于MTK i2c adapter驱动运行。一下是我的修改方案：
<code c>
1290 static int __init rda_module_init_f(void)
1291 {
1292         int err;
1293         RDA_DEBUG("chaser    init in it\n");
1294         err = i2c_register_board_info(3,&fm_i2c_info,1);
1295         RDA_DEBUG("chaser ret=%d\n",err);
1296         err = platform_device_register(&rda_fm_device);
1297         err = platform_driver_register(&rda_fm_platform);
1298         if(err)
1299         {
1300                 RDA_ERR("module_init:register i2c is err\n");
1301                 return err;
1302         }
1303         return 0;
1304 }
1305 - module_init(rda_module_init_f);
1305 + arch_initcall(rda_module_init_f);
</code>
一下是使用module_init和使用arch_initcall两种情况的log信息：
<code c>
/*修改前使用module_init*/
4371 <1>[    3.512734]<2>.(1)[1:swapper/0]RDA DEBUG chaser    init in it
/*修改后使用arch_initcall*/
586 <1>[    0.676376]<2>.(1)[1:swapper/0]RDA DEBUG chaser    init in it
</code>

有效。