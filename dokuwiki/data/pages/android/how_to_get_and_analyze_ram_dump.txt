--- //[[shu.yin@sim.com|尹姝]] 2014/2/21//
====== How to get and analyze RAM dump ======
^Document Title:     |How to get and analyze RAM dump|
^Version:            |1.01                           |
^Date:               |2013-04-22                     |       
^Status:             |Release                        |
^Document Control ID:|SIM0004                        |
^Writer:             |Xifangqing                     |


----


=====Get the RAM dump:=====
**<color teal>1. </color>**In file AMSS/products/7x30/build/ms/targaaabqoazm.h, add the following defines: 
<code c>
#define FEATURE_DLOAD_HW_RESET_DETECT 
#define FEATURE_DLOAD_MEM_DEBUG 
#define FEATURE_AUTO_DLOAD_ON_ERROR 
#define FEATURE_ERR_EXTENDED_STORE //For EFS logs 
#define FEATURE_QPMD //For QPMD log, 
#define FEATURE_SMEM_LOG 
</code>

**<color teal>2. </color>**Modify file AMSS/products/7x30/build/ms/linux_build （In windows “build.cmd”）
<code>
export BUILD_CMD="BUILD_ID=$BUILD_ID BUILD_VER=$BUILD_VER MSM_ID=$MSM_ID DEBUG_ON=yes HAL_PLATFORM=$HAL_PLATFORM .." 
</code>
that is, add "DEBUG_ON=yes" when make build. 

**<color teal>3. </color>**Rebuild AMSS and flash the amss.mbn to the phone by QPST.

**<color teal>4. </color>**Get the RAM dump when the phone had entered into QPST download mode.

{{doc:ram_dump1.png}}

{{doc:ram_dump2.png}}

=====Analyze the RAM dump by TRACE32 Simulator=====
**<color teal>1. </color>**Copy the RAM dump files to AMSS\products\7x30\build\ms

**<color teal>2. </color>**Open Trace32 Simulator,

{{doc:ram_dump3.png}}

<code>
cd " AMSS\products\7x30\build\ms ", run "load_log.cmm",
Select Choice :   "2,8x55(512 MB)"
Select Log Type:  "USB Crash Logs"
Select ELF file:   " AMSS\products\7x30\build\ms\ M7630AAABQOAZM41400700.elf"
Select Log file:   " AMSS\products\7x30\build\ms\load.cmm"
Click  “Go! Load the logs”
Then select OS: choose "2 Android"
</code>

{{doc:ram_dump4.png}}

**<color teal>3. </color>**check MMU_DATA.

Open " AMSS\products\7x30\build\ms\quartz_constants_M.cmm ".

<color royalblue>&l4_entry_point=0xb00000</color>

<color royalblue>&l4_bootimg="../../core/kernel/build_m/bootimg.pbn"</color>

<color royalblue>&mmu_data =&l4_entry_point+0x1ea68</color>

So mmu_data_addr = 0xb1ea68

In trace32 simulator,

Input command:  **v.v (mmu_data_t *)0xb1ea68** to query this variable.

{{doc:ram_dump5.png}}

**cpu->Peripherals->Memory Management Unit**

Check the value of **"CR"="mmu_cr","TTBR0"="ttb","DACR"="DACR"?**

If they are not equal, **double click the data and set it to the right value in command line**.

{{doc:ram_dump6.png}}

**<color teal>4. </color>**Click **"trace buffer"** icon, it will show all the task and thread.

**"Current" task** is most likely where the problem is. 

{{doc:ram_dump7.png}}

**<color teal>5. </color>**CPU ->CPU Registers, set **"CPSR"=0xD0** to change the ARM processor form **SVC mode to user mode**, then SP and CP data can be modified as the user’s wish.

Due to fs task crashed, corroding to the ram dump, the call stack may not complete, dog task can be taken as an example for call stack show.

{{doc:ram_dump8.png}}

{{doc:ram_dump9.png}}

"**R13**" ="Sp" of dog task, "**PC**" ="PC" of dog task,

Click "Thread list" icon, double click “ktcb value” of "dog" task,

{{doc:ram_dump10.png}}

{{doc:ram_dump11.png}}

And input command: **v.f** to show the call stack.

{{doc:ram_dump12.png}}

=====Obtain logs by scripts:=====

**<color teal>1. </color>**F3 log 

Run: “do AMSS\products\7x30\build\ms\recover_f3.cmm”.

It will generate file C:\temp\f3tokens_temp.txt, some useful logs can be show here.

{{doc:ram_dump13.png}}

**<color teal>2. </color>**SMEM log

Run “do AMSS\products\7x30\tools\debug\smemlog.cmm” in Trace32

It will generate “smem_log*.lst” in AMSS\products\7x30\build\ms.

{{doc:ram_dump14.png}}

{{doc:ram_dump15.png}}

Copy “AMSS\products\7x30\tools\debug\smem_log.pl” to “AMSS\products\7x30\build\ms”,

And run “perl smem_log.pl > smemlog.txt” in cygwin.(C:\cygwin\Cygwin.bat)

{{doc:ram_dump16.png}}

Then you can analysis the SMEM log in “smemlog.txt”.

=====Dump the current crash task call stack:=====

As the description above, the current crash task is “fs_task”, so set command in Trace32 Simultor:

**<color teal>1. </color>****symbol.BROWSE fs_stack** to show the range of it, and

**<color teal>2. </color>****d.dump “bottom address of the stack”**

{{doc:ram_dump17.png}}

{{doc:ram_dump18.png}}

Almost all of the crash issue will call below functions in file **err.c**:

{{doc:ram_dump19.png}}

{{doc:ram_dump20.png}}

{{doc:ram_dump21.png}}

So  **sYmbol.BROWSE err_emergency_error_recovery**

**sYmbol.BROWSE err_fatal_handler**

**sYmbol.BROWSE err_fatal_put_log**

{{doc:ram_dump22.png}}

Then you can found these err handler address(E7A125,E7A13F,E7A245..) in fs_stack dump. Then set command **“d.l E7A125 ”** . So, it is indeed that some fatal error happened in fs_stack. 

{{doc:ram_dump23.png}}

CPU register R14 is for error handler, set it value as 0xE7A125, and set PC=0xE7A0FC (function **err_emergency_error_recovery(asm)**).You can set SP address(R13) as you wish(must in the range of  fs_stack), it will show different call stack when V.F command is set.
{{doc:ram_dump24.png}}

{{doc:ram_dump25.png}}

{{doc:ram_dump26.png}}

=====参考文档：=====

80-VN752-2_B_Stability_Debugging_Guide.pdf