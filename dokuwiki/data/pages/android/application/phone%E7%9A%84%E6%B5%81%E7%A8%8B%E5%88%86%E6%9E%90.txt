该流程基于S100D 源码分析，以程序启动和常用操作为主要引导线。水平有限，如有错误，请及时更正。
======程序启动======
phone部分对应到系统进程中的“com.android.phone”，系统启动时默认启动。该应用的application文件“PhoneApp”中定义了许多关键的对象，并初始化了这些对象。后面会逐渐解释这些对象。
<code java>
// A few important fields we expose to the rest of the package
// directly (rather than thru set/get methods) for efficiency.
Phone phone;
CallController callController;
InCallUiState inCallUiState;
CallerInfoCache callerInfoCache;
CallNotifier notifier;
NotificationMgr notificationMgr;
Ringer ringer;
BluetoothHandsfree mBtHandsfree;
PhoneInterfaceManager phoneMgr;
CallManager mCM;
...
</code>
<code java>
// Initialize the telephony framework
PhoneFactory.makeDefaultPhones(this);

// Get the default phone
phone = PhoneFactory.getDefaultPhone();

// Start TelephonyDebugService After the default phone is created.
Intent intent = new Intent(this, TelephonyDebugService.class);
startService(intent);

mCM = CallManager.getInstance();
mCM.registerPhone(phone);

// Create the NotificationMgr singleton, which is used to display
// status bar icons and control other status bar behavior.
notificationMgr = NotificationMgr.init(this);

phoneMgr = PhoneInterfaceManager.init(this, phone);

mHandler.sendEmptyMessage(EVENT_START_SIP_SERVICE);

...

mReceiver = new PhoneAppBroadcastReceiver();
mMediaButtonReceiver = new MediaButtonBroadcastReceiver();

...

// Create the CallController singleton, which is the interface
// to the telephony layer for user-initiated telephony functionality
// (like making outgoing calls.)
callController = CallController.init(this);
// ...and also the InCallUiState instance, used by the CallController to
// keep track of some "persistent state" of the in-call UI.
inCallUiState = InCallUiState.init(this);

// Create the CallerInfoCache singleton, which remembers custom ring tone and
// send-to-voicemail settings.
//
// The asynchronous caching will start just after this call.
callerInfoCache = CallerInfoCache.init(this);

// Create the CallNotifer singleton, which handles
// asynchronous events from the telephony layer (like
// launching the incoming-call UI when an incoming call comes
// in.)
notifier = CallNotifier.init(this, phone, ringer, mBtHandsfree, new CallLogAsync());

// register for ICC status
IccCard sim = phone.getIccCard();
if (sim != null) {
    if (VDBG) Log.v(LOG_TAG, "register for ICC status");
    sim.registerForPersoLocked(mHandler, EVENT_PERSO_LOCKED, null);
}
</code>
=====打电话=====
打电话的入口从OutgoingCallBroadcaster类开始，该类继承与Activity，接受CALL 、 CALL_PRIVILEGED 和 CALL_EMERGENCY 的intent的action。
  * CALL 代表普通的拨号
  * CALL_PRIVILEGED 代表来自通讯录、蓝牙、语音等的拨号
  * CALL_EMERGENCY 意味着紧急拨号，如120、119等
该类在接到需要打电话的通知以后，会有一系列的判断来最终确定该次呼叫的类型，同时CALL_PRIVILEGED最终也会被确认为CALL/CALL_EMERGENCY。
<code java>
/* Change CALL_PRIVILEGED into CALL or CALL_EMERGENCY as needed. */
// TODO: This code is redundant with some code in InCallScreen: refactor.
if (Intent.ACTION_CALL_PRIVILEGED.equals(action)) {
    // We're handling a CALL_PRIVILEGED intent, so we know this request came
    // from a trusted source (like the built-in dialer.)  So even a number
    // that's *potentially* an emergency number can safely be promoted to
    // CALL_EMERGENCY (since we *should* allow you to dial "91112345" from
    // the dialer if you really want to.)
    if (isPotentialEmergencyNumber) {
        Log.i(TAG, "ACTION_CALL_PRIVILEGED is used while the number is a potential"
                + " emergency number. Use ACTION_CALL_EMERGENCY as an action instead.");
        action = Intent.ACTION_CALL_EMERGENCY;
    } else {
        action = Intent.ACTION_CALL;
    }
    if (DBG) Log.v(TAG, " - updating action from CALL_PRIVILEGED to " + action);
    intent.setAction(action);
}
</code>
如果最终判断是紧急呼叫则直接调用callcontrol的placeCall(intent)播出电话
<code java>
// Initiate the outgoing call, and simultaneously launch the
// InCallScreen to display the in-call UI:
PhoneApp.getInstance().callController.placeCall(intent);
</code>
这里比较有意思的一点是这里并没有返回，而是按照普通呼叫一样的继续执行。后面会讲到它最终是怎么处理的。

在普通呼叫的状态下，它会发出一个ACTION_NEW_OUTGOING_CALL广播，让别的程序可以接受这条广播并可以打断这次通话。如果没有被打断的话，这个广播最终会回到该类的子类OutgoingCallReceiver的实例中。
<code java>
Intent broadcastIntent = new Intent(Intent.ACTION_NEW_OUTGOING_CALL);
if (number != null) {
    broadcastIntent.putExtra(Intent.EXTRA_PHONE_NUMBER, number);
}
PhoneUtils.checkAndCopyPhoneProviderExtras(intent, broadcastIntent);
broadcastIntent.putExtra(EXTRA_ALREADY_CALLED, callNow);
broadcastIntent.putExtra(EXTRA_ORIGINAL_URI, uri.toString());
broadcastIntent.putExtra(SUBSCRIPTION_KEY, mSubscription);
// Need to raise foreground in-call UI as soon as possible while allowing 3rd party app
// to intercept the outgoing call.
broadcastIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
if (DBG) Log.v(TAG, " - Broadcasting intent: " + broadcastIntent + ".");

// Set a timer so that we can prepare for unexpected delay introduced by the broadcast.
// If it takes too much time, the timer will show "waiting" spinner.
// This message will be removed when OutgoingCallReceiver#onReceive() is called before the
// timeout.
mHandler.sendEmptyMessageDelayed(EVENT_OUTGOING_CALL_TIMEOUT,
        OUTGOING_CALL_TIMEOUT_THRESHOLD);
sendOrderedBroadcast(broadcastIntent, PERMISSION, new OutgoingCallReceiver(),
        null,  // scheduler
        Activity.RESULT_OK,  // initialCode
        number,  // initialData: ini
</code>
在OutgoingCallReceiver的处理中我们发现她首先就做了是否已经有通话在进行的判断，从而解决了上面“紧急呼叫”没有返回的问题。

紧接着OutgoingCallReceiver将请求传递到SipCallOptionHandler，SipCallOptionHandler 里面主要是判断选择这次呼叫的类型（不同与上面的类型，这次是SIP or PSTN）并最终在setResultAndFinish中向callController发起通话请求
<code java>
// Woo hoo -- it's finally OK to initiate the outgoing call!
PhoneApp.getInstance().callController.placeCall(mIntent);
</code>
placeCall发起通话，并在该方法的末尾打开通话过程中显示的页面 InCallScreen Activity
<code java>
if(mApp instanceof MSimPhoneApp){
      ((MSimPhoneApp)mApp).displayCallScreen(intent.getIntExtra(MSimConstants.SUBSCRIPTION_KEY, mApp.getDefaultSubscription()));
}else{
      mApp.displayCallScreen();
}
</code>
该界面的视图主要参考InCallTouchUi，并且已将事件传递到InCallScreen 中处理
<code java>
/**
 * Handles button clicks from the InCallTouchUi widget.
 */
/* package */ void handleOnscreenButtonClick(int id) {
    log("handleOnscreenButtonClick(id " + id + ")...");

    switch (id) {
        // Actions while an incoming call is ringing:
        case R.id.incomingCallAnswer:
            internalAnswerCall();
            break;
        ...
        case R.id.manageConferenceButton:
            // Show the Manage Conference panel.
            setInCallScreenMode(InCallScreenMode.MANAGE_CONFERENCE);
            requestUpdateScreen();
            break;

        default:
            Log.w(LOG_TAG, "handleOnscreenButtonClick: unexpected ID " + id);
            break;
    }
     // Clicking any onscreen UI element counts as explicit "user activity".
    mApp.pokeUserActivity();
    /**...*/
    updateInCallTouchUi();
}
</code>
=====来电=====
来电的入口需要从CallNotifier（在PhoneApp里有看=到他的初始化）这个类讲起，这个类的主要职责是监听通话状态的改变和来自telephony层的事件（如来电），并且触发相应的UI变化。在该类的构造函数中可以看到它将自己作为监听注册给telephony监听了许多事件。
<code java>
private void registerForNotifications() {
    mCM.registerForNewRingingConnection(this, PHONE_NEW_RINGING_CONNECTION, null);
    mCM.registerForPreciseCallStateChanged(this, PHONE_STATE_CHANGED, null);
    mCM.registerForDisconnect(this, PHONE_DISCONNECT, null);
    mCM.registerForUnknownConnection(this, PHONE_UNKNOWN_CONNECTION_APPEARED, null);
    mCM.registerForIncomingRing(this, PHONE_INCOMING_RING, null);
    mCM.registerForCdmaOtaStatusChange(this, EVENT_OTA_PROVISION_CHANGE, null);
    mCM.registerForCallWaiting(this, PHONE_CDMA_CALL_WAITING, null);
    mCM.registerForDisplayInfo(this, PHONE_STATE_DISPLAYINFO, null);
    mCM.registerForSignalInfo(this, PHONE_STATE_SIGNALINFO, null);
    mCM.registerForInCallVoicePrivacyOn(this, PHONE_ENHANCED_VP_ON, null);
    mCM.registerForInCallVoicePrivacyOff(this, PHONE_ENHANCED_VP_OFF, null);
    mCM.registerForRingbackTone(this, PHONE_RINGBACK_TONE, null);
    mCM.registerForResendIncallMute(this, PHONE_RESEND_MUTE, null);
    mCM.registerForSuppServiceNotification(this, SUPP_SERVICE_NOTIFY, null);
}
</code>
来电的过程中，telephony层的RIL.java类有一个RILReceiver类继承于Runnable代表了一个线程。该线程接收来自c库RIL的消息（如incoming），调用processResponse进行处理，后者将根据Response的类型，调用processSolicited 和processUnsolicited，然后辗转调用到CallNotifier的handler。

RIL: (Radio Interface Layer between Android telephony services (android.telephony) and the radio hardware)是介于android telephony 和 Radio 硬件层的接口层，包含两个部分：RIL守护进程和RIL供应商，RIL守护进程与telephony服务交互并往RIL供应商分发"solicited commands"，RIL供应商是Radio的特定实现并分发"unsolicited commands"事件到RIL守护进程。（参考Wikipedia）

<code java>
@Override
public void handleMessage(Message msg) {
    switch (msg.what) {
        case RINGER_WAIT_FOR_QUERY:
             int subscription = mCM.getRingingPhone().getSubscription();
             mRinger.ring(subscription);
        break;
        
        case PHONE_NEW_RINGING_CONNECTION:
             log("RINGING... (new)");
             onNewRingingConnection((AsyncResult) msg.obj);
             mSilentRingerRequested = false;
        break;

        case PHONE_INCOMING_RING:
            // repeat the ring when requested by the RIL, and when the user has NOT
            // specifically requested silence.
            if (msg.obj != null && ((AsyncResult) msg.obj).result != null) {
                PhoneBase pb =  (PhoneBase)((AsyncResult)msg.obj).result;

                if ((pb.getState() == Phone.State.RINGING)
                        && (mSilentRingerRequested == false)) {
                    if (DBG) log("RINGING... (PHONE_INCOMING_RING event)");
                    sendEmptyMessageDelayed(RINGER_WAIT_FOR_QUERY, RINGTONE_QUERY_WAIT_TIME);
                } else {
                    if (DBG) log("RING before NEW_RING, skipping");
                }
            }
            break;

        case PHONE_STATE_CHANGED:
            onPhoneStateChanged((AsyncResult) msg.obj);
            break;

        case PHONE_DISCONNECT:
            if (DBG) log("DISCONNECT");
            onDisconnect((AsyncResult) msg.obj);
            break;

        ...

        default:
            // super.handleMessage(msg);
    }
}
</code>
这么多的状态那个才是来电第一个首先触发的状态呢，我第一眼看到了PHONE_INCOMING_RING。决定跟踪下去，判断是否静音，到了RINGER_WAIT_FOR_QUERY然后调用mRinger.ring(subscription)，进入方法。^_^，开始震动了。
<code>
if (shouldVibrate(subscription) && mVibratorThread == null) {
    mContinueVibrating = true;
    mVibratorThread = new VibratorThread();
    if (DBG) log("- starting vibrator...");
    mVibratorThread.start();
}
</code>
然后处理PLAY_RING_ONCE响铃，然后、然后没了，一滴汗。。。\\ 没有了，界面没有启动，所以回去再找。PHONE_NEW_RINGING_CONNECTION、PHONE_STATE_CHANGED都蛮像的，决定先看PHONE_STATE_CHANGED。因为如果是它的话，一定会转到PHONE_NEW_RINGING_CONNECTION。跳转到onPhoneStateChanged((AsyncResult) msg.obj)。\\ 不过很遗憾，从注释可以看到该方法不处理新的来电和断开连接。（注释真是好,赞一个！！！）
<code java>
/**
 * Updates the phone UI in response to phone state changes.
 *
 * Watch out: certain state changes are actually handled by their own
 * specific methods:
 *   - see onNewRingingConnection() for new incoming calls
 *   - see onDisconnect() for calls being hung up or disconnected
 */
private void onPhoneStateChanged(AsyncResult r) {
</code>
既然来了，就呆一会再走吧。首先看它支持的状态。
  * IDLE 代表处于空闲状态
  * RINGING 正在通话状态
  * OFFHOOK 相当于电话的没挂好的状态
研究了一下这个方法的内容，感觉跟UI关系不是很大，处理的都是声音播放器、近距离传感器、屏幕锁定等的状态。

接下来跟踪PHONE_NEW_RINGING_CONNECTION的处理，进入onNewRingingConnection（）方法，该方法先进行一些过滤，在某些情况下（比如正在视频通话）直接挂断该次通话请求。此外还看到这样一句,在源码中经常会看到类似的语句，以增强代码的健壮性。
<code java>
if (c == null) {
    Log.w(LOG_TAG, "CallNotifier.onNewRingingConnection(): null connection!");
    // Should never happen, but if it does just bail out and do nothing.
    return;
}
</code>
然后再经过获取callerinfo，进入该处理流程的最后步骤onCustomRingQueryComplete()。这个方法里主要做了两件事情：响铃和显示来电界面。补充一句，在获取callerinfo超时的情况也直接跳到该方法。
<code java>
// Ring, either with the queried ringtone or default one.
if (VDBG) log("RINGING... (onCustomRingQueryComplete)");
int subscription = mCM.getRingingPhone().getSubscription();
mRinger.ring(subscription);

// ...and display the incoming call to the user:
if (DBG) log("- showing incoming call (custom ring query complete)...");
showIncomingCall();
</code>
继续跟踪到updateInCallNotification(boolean allowFullScreenIntent)，从这个方法可以看出它是通过发通知的方式来告诉用户，然后通过设置fullScreenIntent为true直接启动InCallScreen。
<code java>
// Ok, we actually want to launch the incoming call
// UI at this point (in addition to simply posting a notification
// to the status bar).  Setting fullScreenIntent will cause
// the InCallScreen to be launched immediately *unless* the
// current foreground activity is marked as "immersive".
if (DBG) log("- Setting fullScreenIntent: " + inCallPendingIntent);
builder.setFullScreenIntent(inCallPendingIntent, true);
</code>
至此来电过程已经基本结束。但是细心的你有没有发现有两个地方（PHONE_INCOMING_RING、PHONE_NEW_RINGING_CONNECTION）都有机会调用了mRinger.ring(subscription)这个方法，这是怎么回事，这还是不能判断那个会先行调用。于是本人决定使用debug模式。\\ 通过调试可以发现，先行接受到的事件是PHONE_INCOMING_RING，但是这是的状态不是处于RINGING，所以直接忽略掉了。然后才会接受到PHONE_NEW_RINGING_CONNECTION的事件。而此后还会接受到PHONE_INCOMING_RING事件，同样会执行mRinger.ring(subscription)，不过这道是很像android源码的风格，以增强产品的适应性。