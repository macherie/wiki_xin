====== Wpa_supplicant 分析 ======

依然是带着问题去看吧，否则20w行代码要看死的...，不可能也没必要去详细的分析代码，我们只要知道它的功能框架，会去debug，会去用就看了，下面是我想到的几个问题：

===== 1.什么是wpa_supplicant，它主要的功能是什么，它有什么特点... =====

Wpa_supplicnt是一个开源项目，支持多平台多系统，它实现了对无线网络进行管理和控制的功能.
Wpa_supplicant主要是用来支持WEP，WPA/WPA2和WAPI无线协议和加密认证的，而实际上的工作内容是通过socket（不管是wpa_supplicant与上层还是wpa_supplicant与驱动都采用socket通讯）与驱动交互上报数据给用户，而用户可以通过socket发送命令给wpa_supplicant调动驱动来对WiFi芯片操作。 简单的说，wpa_supplicant就是WiFi驱动和用户的中转站外加对协议和加密认证的支持。

根据官网描述，wpa_supplicant所支持的功能非常多，此处列举其中几个重要的功能点：

==== 1>支持WPA和IEEE 802.11i所定义的大部分功能，这部分功能集中在安全方面，包括： ====

●支持WPA-PSK（即WPA-Personal）和WPA-Enterprise（即利用RAIDUS认证服务器来完成身份认证的情况）。

●数据加密方面支持CCMP、TKIP、WEP104和WEP40。注意，WEP104和WEP40中的数字代表密钥的长度。104表示密钥长度为104个二进制位（如以ASCII字符个数来计算的话，WEP104支持的密钥长度为13个ASCII字符）。

●完全支持WPA和WPA2，包括PMKSA缓存，预认证（pre-authentication）等功能。

●支持IEEE 802.11r和802.11w，其中802.11r规范定义了快速基础服务转移（Fast Transition）功能，而802.11w则新增了对管理帧的安全保护机制。支持WFA制定的Wi-Fi Proctected Setup功能、P2P、TDLS等。

==== 2>支持多种EAP Method：主要和802.1X中Supplicant的功能有关，wpa_supplicant支持多达25种EAP Method，包括： ====

●EAP-TLS：TLS（Transport Layer Security）本身是一种传输层安全协议，它利用密钥算法提供端点身份认证与通讯保密，其基础是公钥基础设施（public key infrastructure，简称PKI）。EAP-TLS定义于RFC 5216。

●EAP-PEAP：PEAP（Protected Extensible Authentication Protocol，可扩展EAP）由微软、思科以及RSA Security三个公司共同开发，是一种利用证书加用户名和密码来进行身份验证的方法。

●EAP-TTLS：它是TLS的拓展，全名为Tunneled Transport Layer Security（隧道传输层安全协议），相比TLS，它简化了认证过程中客户端的工作。

●EAP-SIM、EAP-PSK、EAP-GPSK等其他认证方法。

☆http://en.wikipedia.org/wiki/Extensible_Authentication_Protocol以了解更多EAP方法的知识

==== 3>支持的无线网卡驱动： ====

●支持nl80211/cfg80211驱动

●支持wext驱动

●Wired Ethernet drivers

●BSD net80211 layer (e.g., Atheros driver) (FreeBSD 6-CURRENT and NetBSD current)

●Windows NDIS drivers (Windows; at least XP and 2000, others not tested)

wpa_supplicant经过谷歌修改移植到android平台上，它是用户空间中无线网络部分的核心模块，所有Framework中wifi相关的操作最终都是借由wpa_supplicant来完成。

===== 2.Wpa_supplicant都有哪些部分组成，框架是什么? =====
{{:android:wifi:wpa_supplicant:wpa_supplicant.png|}}

从上图看wpa_supplicant主要组成部分：

●wpa_supplicant所有工作都围绕事件（对应图中的event loop模块）展开。wpa_supplicant没有使用多线程编程，所有事件处理都在主线程中完成。

●位于event loop模块下方的driver i/f（i/f代表interface）接口模块用于隔离和底层驱动直接交互的那些driver控制模块（如wext、ndiswrapper、nl80211等，wpa_supplicant中称之为driver wrapper）。这些driver wrapper和平台以及芯片所使用的驱动相关。不过，由于driver i/f的隔离作用，wpa_supplicant中其他模块将能最大程度保持平台以及驱动无关性。

●driver wrapper经常要返回一些信息给上层。wpa_supplicant中，这些信息将通过driver events的方式反馈给wpa_supplicant供其他模块进行处理。

●EAP以及EAPOL协议，除了定义消息格式外，RFC4137文档定义了EAP状态机，而802.1X文档中还定义了EAPOL状态机。wpa_supplicant根据这两个协议分别实现了EAP和EAPOL状态机。除此之外，wpa_supplicant还定义了自己的状态机（即WPA/WPA2 State Machine）。

●wpa_supplicant实现了多种EAP方法，如图中EAP method模块所示。另外它还包含了TLS模块和crypto模块用于支持对应的EAP方法。

●EAPOL以及EAP消息都属于LLC层数据，所以wpa_supplicant的l2_packet模块用于收发EAPOL和EAP消息。

●wpa_supplicant支持较多的配置参数，这些参数的处理由configuration模块完成。

●wpa_supplicant是C/S结构中的Server端，它通过ctrl i/f模块向客户端提供通信接口。Linux/Unix平台中，Client端利用Unix域socket与其通信。目前常用的Client端wpa_cli（无界面的命令行程序）和wpa_gui（UI用Qt实现）。

关于WPA/WPA2 80211i 80211x EAP EAPOL见另一文档介绍。

===== 3.Wpa_supplicant是如何初始化的? =====
{{:android:wifi:wpa_supplicant:wpa_supplicnat.jpg|}}

看不清楚？好吧，见附件下载。


===== 4.Wpa_supplicant是如何完成“承上启下”的桥梁功能的？ =====

==== 1>上行接口，即与framework层通信接口，是通过socket通信，上面流程图中已经分析了两种接口的初始化与建立： ====


● global control interface: 用于配置（增加或删除）网络接口。

● ctrl interface: 与其他外部模块交互的控制接口。

例如，在初始化时，android 平台的wifi.c中的 wifi_connect_to_supplicant函数调用wpa_ctrl_open函数创建两个socket，一个是ctrl interface，另一个就是monitor interface,monitor interface这个接口用于监测从wpa_supplicant发出的event事件。
这两个socket创建成功后，monitor interface 会发送ATTACH到wpa_supplicant模块，wpa_supplicant模块收到后，会将该客户端的socket信息记录下来，用于以后发送事件时用（由于用的是DGRAM的方式）。

关于控制接口命令：
       PING
       MIB
       STATUS
       STATUS-VERBOSE
       PMKSA
       SET <variable> <valus>
       LOGON
       LOGOFF
       REASSOCIATE
       RECONNECT
       PREAUTH <BSSID>
       ATTACH
       DETACH
       LEVEL <debug level>
       RECONFIGURE
       TERMINATE
       BSSID <network id> <BSSID>
       LIST_NETWORKS
       DISCONNECT
       SCAN
       SCAN_RESULTS
       BSS
       SELECT_NETWORK <network id>
       ENABLE_NETWORK <network id>
       DISABLE_NETWORK <network id>
       ADD_NETWORK
       REMOVE_NETWORK <network id>
       SET_NETWORK <network id> <variable> <value>
       GET_NETWORK <network id> <variable>
       SAVE_CONFIG
==== 2>下行接口，即最终实现与kernel driver层通信（待具体分析）： ====

● socket for ioctl: 发送命令到kernel space。

● socket (netlink) for interact between kernel and userspace(AF_NETLINK, NETLINK_ROUTE): 接受kernel发送上来的event。

● socket for l2 packet(PF_PACKET): 处理802.1x报文。


===== 5.wpa_supplicant工具使用，Wpa_supplicant.conf的格式？ =====
===== 6.资源列表. =====

