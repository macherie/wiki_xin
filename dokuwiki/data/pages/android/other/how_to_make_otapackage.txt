**基于C500项目的OTA升级包制作**

**客户需求**：拿到update.zip升级包，可以自己定制，比如修改logo，加入系统应用等。

**我的思考过程**：熟悉recovery升级模式的知道，这个update.zip是经过签名的，如果解压原生update.zip，修改完成后，直接打包升级是不能通过验证，所以需要进行签名，度娘会告诉你。命令是:
<code>java -Xmx2048m -jar signapk.jar -w testkey.x509.pem testkey.pk8 update-origin.zip update-signed.zip</code>
轻松搞定。但是在升级过程过程中发现，recovery.img是无法升级的，因为它采用了差分升级的方法，升级的过程是在Android系统启动后完成。如果需要升级recovery.img，光靠打包是不行的，所以要找出如何生成这个差分包。我就去build目录下研究整个过程，后来发现这样太麻烦，有那功夫，还不如直接把整个recovery打包过程从Android分离出来，因为在研究脚本的过程中发现，这套流程很独立。于是我摒弃了这套“山寨”做法。

**真正的工作**

我首先想到要从编译过程的输出log中寻找答案，Make otapackage这个命令就是用来制作升级包的，细心的同学会发现在编译的最后会有很多命令输出，其中一行大体是这样的：
<code>ota_from_target_files -v -w -x pagesize=4096 -p ./linux-x86/ -d MMC -f 0 -k ./security/testkey target.zip  update.zip</code>
OK,其实整个故事就是从这个脚本开始的，这个脚本位于build/tools/releasetools下。参数说明可以查看这个脚本源码，或者直接运行这个脚本，就会有提示。我关注的地方是target.zip，这玩意儿从哪来的？同样我回到编译过程最后的输出log中查找答案，发现这个包就是拷贝自obj/PACKAGING/target_files_intermediates/c500-target_files-版本号-日期.zip，到现在为止其实我的工作就完成了。一切都可以自动化！

接下来就是构造环境了，当然是read the fucking codes！，发现ota_from_target_files这个脚本会依赖很多命令，比如imgdiff，mingzip，mkbootfs，mkbootimg，这些命令来自out/host/linux-x86/bin下。还需要security目录下的公钥等等，一切就绪后，就形成了附件offical-update.zip里的环境包，里面的manual.txt就是使用手册。

{{:android:other:offical-update.zip|}}