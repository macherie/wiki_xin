转自   http://blog.csdn.net/green1900/article/details/42496741#comments

1、底电流调试（Rock Bottom Current Optimization）

底电流在手机飞行模式下调试。每个平台的底电流数据可能不一样，具体可以参考release出来的Current Consumption Data文档或者release note。一般情况下的底电流参考数据上限是：

512M RAM < 1.5mA; 1G RAM < 2mA; 2G RAM < 2.6mA

 

1.1校准RF

保证RF的PA、Antenna switch、Tuner、APT、GPIO工作在正常状态

 

1.2飞行模式

开启飞行模式、关闭GPS、关闭自动旋转屏幕、关闭自动亮度调节、关闭其他特效效果设置

开启飞行模式，可以基本避免蓝牙、wifi、NFC、网络、FM等的一般影响；

关闭GPS，可以基本排除开启GPS对底电流的影响；

关闭自动旋转屏幕，可以基本排除sensor的影响；

关闭自动亮度调节，可以基本排除距离感应到的影响；

关闭其他特效效果设置，如指纹识别、黑屏手势、智能体感、手势隔空操作。。。。。。

 

1.3使用perf_defconfig

修改device/qcom/<TARGET>/AndroidBoard.mk。如果KERNEL_DEFCONFIG := <TARGET>_defconfig，那么改成KERNEL_DEFCONFIG := <TARGET>-perf_defconfig

同时，kernel代码改用/kernel/arch/arm/configs/<TARGET>-perf_defconfig

<TARGET>是平台名称或者项目名称

 

1.4移除debugging APKs

/system/app/Logkit.apk

/system/app/com.qualcomm.qlogcat.apk

/system/xbin/qlogd

 

1.5把应用尽量删除

在设置-->应用，禁用正在运行的应用

 

1.6去掉CPU占用高的进程

adb shell

top

查看CPU占用，去掉在休眠模式下CPU占用大于0的进程。kill掉该进程，若kill不掉则rm掉相关应用。对于占用CPU高的kwork，需要查找驱动原因。

 

1.7手动移除所有可以移除的外设

手机连上安捷伦电源，手机开机，然后让手机进入待机状态。手动移除TP、LCM、前camera、后camera、sensor、SD卡、SIM卡等可以手动移除的外围器件，同时观察并记录底电流变化。

直接移除WLAN芯片可能会导致开不了机，所以在移除WLAN之前，先对软件做如下处理：

# mount -o rw,remount -t vfat /dev/block/bootdevice/by-name/modem 

# cd /firmware/image 

# rm wcnss.* 

# reboot 

或者

#lsmod

#rmmod WLAN

移除其他可以移除的芯片（sensor、NFC。。。）

 

1.8移除驱动模块

在/kernel/arch/arm/configs/<TARGET>-perf_defconfig中把sensor、TP、LCM、camera等的驱动模块移除；

或者在对应驱动的Makefile里面，移除驱动代码

然后编译bootimage，烧入手机观察底电流变化

 

1.9配置不用的GPIO

将不用的GPIO置为输入、拉低；配置成SPI、I2C的GPIO，若不用，置为悬空

在boot_images/core/systemdrivers/tlmm/config/platform/TLMMChipset.xml，修改GPIO配置。该处配置GPIO的初始状态，驱动有可能会修改GPIO。

对比项目原理图与平台参考原理图，项目原理图中多出的NC GPIO要处理掉。

 

1.10检查power相关的NV items

需要跟CE确认。一般如下：

1027 = 0

1895 = 0

1892 = 0

1962 = 0

4679 = 16

4201 = 0

3851 = 0

3852 = 6

7157 = 1

69745 rxd_enable = 0

WCDMA NV:

NV3581 = 0

NV3852 = 6

 

1.11排查GPIO、LDO、总线

对比项目原理图与平台参考原理图，排查硬件不一样的GPIO、LDO、总线配置。

量测各GPIO、LDO、I2C在休眠时候的电压，需用万用表准确测量。

休眠时各路I2C GPIO的电压是多少v，用万用表准确测量。

如果条件允许，测量所有LDO在休眠前和休眠后的准确电压。

对于LDO，调试方法如下：

（1）adb shell关闭LDO

如关闭L3：

cd /sys/kernel/debug/regulator/8916_l3/

echo 0 > enable


（3）通过寄存器地址关闭LDO

如LDO6的地址是0x14546，则关闭方法是：

# cd /sys/kernel/debug/spmi/spmi-0 

# echo 0x14546 > address 

# echo 1 > count 

# cat data 可以读寄存器 

# echo 0x00 > data 关LDO6
#在较新的平台是无法手动关闭LDO

在S600项目LDO6和LDO17分别是提供主外设用的数字电压和模拟电压，分别是1.8v和2.8v，在cd /sys/kernel/debug/regulator/8916_l6中，cat use_count，如果值等于0表明引用计数没有使用LDO6.如果不等于0，分别将他们驱动去除，去除之后重新查看use_count的值，在S600项目中，因为icm20546陀螺仪驱动导致底电流过高，系统睡不下去。

（4）关闭MPP

在休眠前关闭MPP1、MPP2、MPP3、MPP4 

如PM8916的寄存器地址分别是0xA046、0xA146、0xA246、0xA346 

在关闭前先cat data以查看原来的值。 


GPIO状态读取的方法如下：

（1）GPIO dump

为了得到休眠时的GPIO状态，增加下面的打印: 

rpm_proc/core/power/sleep/src/lpr_definition_uber.c 

#include "tlmm_hwio.h" 

void deep_sleep_enter(void) 

{ 

uint64 sleep_duration; 

... 

 

SWEVENT(SLEEP_DEEP_SLEEP_ENTER_COMPLETE, sleep_mode.deep_sleep_mode, sleep_duration); 

// For test 

{ 

int num; 

int i=11;/*LCM_I2C_SCL, GPIO_11*/ 

volatile uint32 cfg ,inout, val; 

 

num = 122; //8916 only. Need modify for 8974/8x10/8x26 etc. 

 

cfg = *(volatile uint32*)HWIO_TLMM_GPIO_CFGn_ADDR(i); //(0x61000000 + i * 0x1000) 

inout = *(volatile uint32*)HWIO_TLMM_GPIO_IN_OUTn_ADDR(i);//(0x61000004 + i * 0x1000) 

val = ((cfg << 16)&0xffff0000) | (inout&0xffff); 

SWEVENT(SLEEP_GPIO_DUMP, i, val); 

} 

mpm_sw_done(sleep_mode.deep_sleep_mode, sleep_duration); 

} while(FALSE); 

} 

 

增加for test下面这一段代码。

然后再修改: 

rpm_proc\core\power\sleep\build\SConscript 

if 'USES_QDSS_SWE' in env: 

QDSS_IMG = ['QDSS_EN_IMG'] 

events = [['SLEEP_DEEP_SLEEP_ENTER=320','deep sleep enter. (sleep mode: %d) (count: %d)'], 

['SLEEP_DEEP_SLEEP_EXIT','deep sleep exit (sleep mode: %d)'], 

['SLEEP_NO_DEEP_SLEEP','bail early from deep sleep. (sleep mode: %d) (reason: %d)'], 

['SLEEP_RPM_HALT_ENTER','rpm halt enter'], 

['SLEEP_RPM_HALT_EXIT','rpm halt exit'], 

['SLEEP_MPM_INTS','pending mpm interrupts at wakeup: (interrupt_status_1 %d), (interrupt_status_2 %d)'], 

['SLEEP_DEEP_SLEEP_ENTER_COMPLETE','deep sleep exit complete (sleep mode: %d)'], 

['SLEEP_DEEP_SLEEP_EXIT_COMPLETE','deep sleep exit (sleep mode: %d)'], 

['SLEEP_MPM_WAKEUP_TIME','mpm wake up time (wakeup time: 0x%0.8x%0.8x)'], 

['SLEEP_GPIO_DUMP','gpio [%d] configuration is %d'],

['SLEEP_EVENT_LAST=383','sleep last event placeholder'] 

增加SLEEP_GPIO_DUMP这一项。 

编译烧写rpm.mbn。

让机器休眠，进入download，抓dump，然后将如下日志发给平台技术支持分析。 

CODERAM.bin 

MSGRAM.bin 

DATARAM.bin 

以及新编译出来的RPM_AAAAANAZR.elf。  

（2）GPIO寄存器读取

在RPM可能不是很方便，也可以用busybox来读取寄存器，例如读GPIO11： 

Physical Address for GPIO_CFG11 = 0x100B000 

root@android:/data/busybox # ./busybox devmem 0x100B000 32 

./busybox devmem 0x100B000 32 

0x00000203 

GPIO_PULL = "11" PULL_UP 

FUNC_SEL = "0000" FUNCTION GPIO 

DRV_STRENGTH = "000" DRV_2_MA 

GPIO_OE = "1" Output Enable 

 

1.12 rpm dump

抓rpm dump，然后把log提供给平台技术支持。

方法如下： 

（1）ps_hold接地

在休眠状态下，接ps_hold到地少于200mS，机器会进入紧急下载状态，插入USB，QPST会自动得到memory dump，然后上传以下几个文件： 

CODERAM.bin 

MSGRAM.bin

DATARAM.bin 

以及RPM_AAAAANAZR.elf（必须与机器的编译时间一致匹配的elf) 

（2）改reset为download key

发这些命令改reset为download key: 

# cd /sys/kernel/debug/spmi/spmi-0 

# echo 0x844 > address 

# echo 4 > count 

# cat data 

00840 -- -- -- -- 0F 07 04 00 

# echo 0x00 0x00 0x01 0x00 > data 

# cat data 

00840 -- -- -- -- 00 00 01 00 

# echo 0x00 0x00 0x01 0x80 > data 

# cat data 

00840 -- -- -- -- 00 00 01 80 

然后长按下键，会进入download。之后抓取log方法同上。

如果进不了download，需要确认： 

CONFIG_MSM_DLOAD_MODE=y 

另外也有可能与nv 4399和905有关系。

 

1.13检查rpm_stats

检查rpm_stats是否进入vdd min或者xo/no shutdown。使用下面的命令检查rpm lower power mode count:

cat /sys/kernel/debug/rpm_stats

如果vmin的count是0，则表明设备从来没有进入vdd min；non-zero则说明设备进入过vdd_min。

RPM Mode: xosd

count:0

time in last mode(msec):0

time since last mode(sec):794

actual last sleep(msec):0

RPM Mode:vmin

count:11

time in last mode(msec):0

time since last mode(sec):359

actual last sleep(msec):110000

 

1.14使用Trace32

可以dump出来完整详细的gpio/clk/pmic信息，排除休眠时候的状态异常。

 

 

2、待机电流优化（Standby Current Optimization）

2.1通过adb log排查

adb logcat -v time > YearMounthDayHourMinute_logcat.txt   //main log

adb logcat -v time -b events > YearMounthDayHourMinute_logcat_event.txt   //event log

adb logcat -v time -b radio > YearMounthDayHourMinute_logcat_radio.txt    //radio log

adb shell dmesg > YearMounthDayHourMinute_dmesg.txt                 //kernel log

可以采用功耗问题时间追踪表来精确追踪功耗异常。

可以使用如下命令来打开指定文件的kernel log（以qpnp-adc-tm.c和qpnp-adc-common.c为例）：

adb shell mount -t debugfs none /sys/kernel/debug

adb shell "echo 8 > /proc/sys/kernel/printk" 

adb shell "echo 'file qpnp-adc-tm.c +p' > /sys/kernel/debug/dynamic_debug/control"

adb shell "echo 'file qpnp-adc-common.c +p' > /sys/kernel/debug/dynamic_debug/control"

adb shell "echo 8 > /proc/sys/kernel/printk"

 

为指定的函数开启log，以qpnpint_handle_irq为例：

adb shell "echo 'func qpnpint_handle_irq +p' > /sys/kernel/debug/dynamic_debug/control" 

 

*#logkit#*调出logkit apk，可以保存logcat、dmesg、crash、QXDM、GPU log等日志信息到手机里面。

 

2.2 top

通过top命令，可以查询到cpu占用较高的应用。如果一个应用一直在占用cpu，而此时并没有打开该应用，那么该应用很可能会导致待机异常。

adb shell

top

“该场景下CPU使用率”是User+System+IOW+IRQ

“模块相关的CPU占用率”是模块相关进程占用CPU使用率的总和

 

2.3正在运行

设置-->应用-->正在运行，可以看到正在运行的应用或者服务。禁止掉应用或者服务，观察待机电流变化。

 

2.4 wakeup debug mask

调试wakeup问题，可以使能debug功能，然后抓取log。Log中会增加一些debug信息。

mount -t debugfs none /sys/kernel/debug  

echo 1 > /sys/kernel/debug/clk/debug_suspend  

echo 1 > /sys/module/msm_show_resume_irq/parameters/debug_mask  

echo 4 > /sys/module/wakelock/parameters/debug_mask  

echo 1 > /sys/module/lpm_levels/parameters/debug_mask  

echo 0x16 > /sys/module/smd/parameters/debug_mask  

 

2.5 wakelock  

1、wakeup_sources  

kernel wakelock和userspace wakelock都有可能阻止系统睡眠。所有的wakeup_sources均保存在sys节点/sys/kernel/debug/wakeup_sources里面。 

该文件包含了如下信息：

（1）the total amount of time a wakeup source has prevented suspend  

（2）the amount of time a wakelock has been active since the last activation etc. The unit of time is milliseconds. 

 

2、active_since

active_since值可以用来确认wakelock是否正在阻止休眠。如果该值不是零，那么这个wakelock正在工作并且阻止休眠。

 

3、获取wakeup_sources的命令

adb root 67754400

adb remount

adb shell 

cat /sys/kernel/debug/wakeup_sources > /data/wakeup_sources.txt

adb pull /data/wakeup_sources.txt

获得wakeup_sources.txt以后，通过Excel打开，active_since不为0的项为wakeup source。以表2为例，msm_dwc3对应的active-since值481756>0，这意味着msm_dwc3驱动在阻止系统睡眠，下一步需要检查msm_dwc3驱动代码及相关log。

 

表格 2 Wakeup source opened in Excel

 

4、power:wakeup_source_activate and power:wakeup_source_deactivate events

当一个wakeup source被acquire或者release时候，power:wakeup_source_activate和power:wakeup_source_deactivate event将随即被写到trace buffer里面，这样可以记录wakeup source被driver使用的频率。

开启该功能的方法：

echo "power:wakeup_source_activate power:wakeup_source_deactivate" > /sys/kernel/debug/tracing/set_event

 

The power:wakeup_source_activate and power:wakeup_source_deactivate events are written to the trace buffer any time a wakeup source is acquired or released and it can provide information on how often a wakeup source is being used by a driver.  

To enable these events, you can enable following:  

echo "power:wakeup_source_activate power:wakeup_source_deactivate" > /sys/kernel/debug/tracing/set_event 

Once the above done, the traces will be present in /sys/kernel/debug/tracing/trace. 

 

2.6 powertop

powertop用来看CPU的运行统计以协助调试power问题。powertop的用法如下：

powertop --h

Usage: powertop [OPTION...]

n -d, --dump read wakeups once and print list of top offenders

n -t, --time=DOUBLE default time to gather data in seconds

n -r, --reset Reset PM stats data

n -h, --help Show this help message

n -v, --version Show version information and exit

获取powertop log的方法：

1. 通过USB连接手机到电脑

2. adb shell，然后执行如下命令：

sleep 10 && /data/powertop [-r] -d -t 30 > /data/powertop.log & 

3. 拔掉USB线，等待10秒后开始功耗测试

4. 插上USB  

5. adb pull /data/powertop.log  

 

2.7 CPU freq log 

打开CPU freq change log：

mount -t debugfs none /sys/kernel/debug  

cd /sys/kernel/debug 

echo -n 'file acpuclock-8x60.c +p' > dynamic_debug/control 

echo -n 'file acpuclock-krait.c +p' > dynamic_debug/control

 

查看cpu freq stats: 

cat /sys/devices/system/cpu/cpu0/cpufreq/stats 

cat /sys/devices/system/cpu/cpu1/cpufreq/stats 

cat /sys/devices/system/cpu/cpu2/cpufreq/stats 

cat /sys/devices/system/cpu/cpu3/cpufreq/stats 

 

To lock cpu freg: 

echo the same freq to following sys mode will lock cpu freq to the setting freq. 

/sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq 

/sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq

 

To enable/disable specific freq for ACPU 

ACPU freq table is defined in acpu_freq_tbl_* structure of specific platform. 

arch/arm/mach-msm/acpuclock-<platform name>.c 

For 8974, it is defined in arch/arm/mach-msm/acpuclock-8974.c. the first column of following table used to enable/disable freq in the row: 1:enable, 0:disable  

static struct acpu_level acpu_freq_tbl_2p3g_pvs0[] __initdata = { 

{ 1, { 300000, PLL_0, 0, 0 }, L2(0), 800000, 72 }, 

{ 0, { 345600, HFPLL, 2, 36 }, L2(1), 800000, 83 }, 

{ 1, { 422400, HFPLL, 2, 44 }, L2(2), 800000, 101 }, 

{ 0, { 499200, HFPLL, 2, 52 }, L2(2), 805000, 120 }, 

{ 0, { 576000, HFPLL, 1, 30 }, L2(3), 815000, 139 }, 

{ 1, { 652800, HFPLL, 1, 34 }, L2(3), 825000, 159 }, 

{ 1, { 729600, HFPLL, 1, 38 }, L2(4), 835000, 180 }, 

{ 0, { 806400, HFPLL, 1, 42 }, L2(4), 845000, 200 }, 

{ 1, { 883200, HFPLL, 1, 46 }, L2(4), 855000, 221 }, 

{ 1, { 960000, HFPLL, 1, 50 }, L2(9), 865000, 242 }, 

{ 1, { 1036800, HFPLL, 1, 54 }, L2(10), 875000, 264 }, 

{ 0, { 1113600, HFPLL, 1, 58 }, L2(10), 890000, 287 }, 

{ 1, { 1190400, HFPLL, 1, 62 }, L2(10), 900000, 308 }, 

… 

{ 1, { 1958400, HFPLL, 1, 102 }, L2(19), 1040000, 565 }, 

{ 0, { 2035200, HFPLL, 1, 106 }, L2(19), 1055000, 596 }, 

{ 0, { 2112000, HFPLL, 1, 110 }, L2(19), 1070000, 627 }, 

{ 0, { 2188800, HFPLL, 1, 114 }, L2(19), 1085000, 659 }, 

{ 1, { 2265600, HFPLL, 1, 118 }, L2(19), 1100000, 691 }, 

{ 0, { 0 } } 

}; 

 

2.8 Hoplug cores 

Core 0 can’t be hotplugged, Core 1/2/3 can be hotplugged, 

To remove core : 

echo 0 > /sys/devices/system/cpu/cpu1/online 

echo 0 > /sys/devices/system/cpu/cpu2/online 

echo 0 > /sys/devices/system/cpu/cpu3/online 

 

To add back core: 

echo 1 > /sys/devices/system/cpu/cpu1/online

echo 1 > /sys/devices/system/cpu/cpu2/online

echo 1 > /sys/devices/system/cpu/cpu3/online

 

2.9 Scaling governor

To check scaling governor：

cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor

 

To set new governor：

echo <new_governor> > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor

比如：

echo ondemand > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor

 

2.10 Mpdecision

Use Mpdecison daemon to start/stop/enable debug with commands below: 

Start mpdecison： 

start mpdecision 

n 

Stop mpdecison：

stop mpdecision

 

Enable mpdecision debug ：

start mpdecision --debug 

 

2.11 Power feature enable/disable 

Following sys node can be used to enable the lower resource, 

 

echo 2 > /sys/module/lpm_resources/enable_low_power/l2 

echo 1 > /sys/module/lpm_resources/enable_low_power/pxo 

echo 1 > /sys/module/lpm_resources/enable_low_power/vdd_dig 

echo 1 > /sys/module/lpm_resources/enable_low_power/vdd_mem 

echo 1 > /sys/module/pm_8x60/modes/cpu0/power_collapse/suspend_enabled 

echo 1 > /sys/module/pm_8x60/modes/cpu1/power_collapse/suspend_enabled 

echo 1 > /sys/module/pm_8x60/modes/cpu2/power_collapse/suspend_enabled 

echo 1 > /sys/module/pm_8x60/modes/cpu3/power_collapse/suspend_enabled 

echo 1 > /sys/module/pm_8x60/modes/cpu0/power_collapse/idle_enabled 

echo 1 > /sys/module/pm_8x60/modes/cpu0/standalone_power_collapse/suspend_enabled

echo 1 > /sys/module/pm_8x60/modes/cpu1/standalone_power_collapse/suspend_enabled

echo 1 > /sys/module/pm_8x60/modes/cpu2/standalone_power_collapse/suspend_enabled 

echo 1 > /sys/module/pm_8x60/modes/cpu3/standalone_power_collapse/suspend_enabled

echo 1 > /sys/module/pm_8x60/modes/cpu0/standalone_power_collapse/idle_enabled 

echo 1 > /sys/module/pm_8x60/modes/cpu1/standalone_power_collapse/idle_enabled 

echo 1 > /sys/module/pm_8x60/modes/cpu2/standalone_power_collapse/idle_enabled 

echo 1 > /sys/module/pm_8x60/modes/cpu3/standalone_power_collapse/idle_enabled 

echo 0 to above sys node will disable related low power mode. 

 

2.12 Check system alarm  

get android alarms and statistics: 

adb dumpsys alarm > alarms.txt

 

enable android debug message in logcat： 

setprop persist.alarm.debug 1

 

2.13 Kernel timer check

Sys node /proc/timer_stats can be used to check kernel timer stastics, customer can use following command to get timer statics in specific scenario: 

echo 0 > /proc/timer_stats && sleep 10 && echo 1 > /proc/timer_stats && sleep 30 && cat /proc/timer_stats > /data/timer_stats & 

 

OEMs need to provide file /data/timer_stats to salesforce case for check. 

 

 

3、其他功耗项的优化

3.1屏幕对功耗的影响

屏幕亮度等级不同，功耗不同。亮度越低，功耗越低。调低屏幕默认背光亮度等级和屏幕最高亮度设置时候的背光亮度等级，可以优化手机整体功耗表现。

LCD背光等级的设备节点：

/sys/class/leds/lcd-backlight/brightness

默认背光等级和最高亮度背光等级需要同时考虑到用户体验和功耗表现，需要一起评估。

另外，调试LCD的fps帧率，也可以优化功耗。

 

3.2 CPU/GPU DVFS

CPU/GPU的动态调频调压可以优化手机的功耗表现。该影响是整体性的，系统性的。

CPU降频主要通过两种方式实现，都可以达到降频的目标。

1、设置CPU工作在powersave模式。设置该模式后，CPU将一直工作在最低频率（300000hz）。此时手机最省电，但是有可能会出现手机运行变卡顿。

例如：将CPU0置为powersave模式，命令为：

echo "powersave" > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor

例如：将CPU1置为powersave模式，命令为：

echo "powersave" > /sys/devices/system/cpu/cpu1/cpufreq/scaling_governor

ex780共有4个CPU（CPU0~CPU3），都可以这样处理

2、限制CPU最高频率，以限制CPU的运行频率上限

CPU（CPU0~CPU3）可以选择的频率值如下所列，即这些数值都可以用作CPU的频率上限。选择的频率上限可以根据实际场景需要来设置。在超级省电模式下，CPU工作的宗旨是：CPU工作频率低+运行不卡，两项都要保障。

CPU可以选择的频率：

300000 422400 652800 729600 883200 960000 1036800 1190400 1267200 1497600 1574400 1728000 1958400 2265600 2457600

例如：将CPU0的频率上限设置为960000

echo 960000 > /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq

例如：将CPU0的频率上限设置为422400

echo 422400 > /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq

 

GPU相关调试与CPU类似，设备节点路径/sys/devices/fdb00000.qcom,kgsl-3d0/kgsl/kgsl-3d0

 

3.3 CPU占用率

应用对cpu的占有率，如果占有率过高，则该应用一般会导致功耗较大。

adb shell

top -m 6 

 

3.4游戏功耗

可以从下面几个方面优化：

降低屏幕背光亮度等级；

采用CPU、GPU动态调频调压，并调低CPU、GPU频率下限；

采用thermal-engine.conf 。

 

3.5 Camera功耗偏大

降低camera帧率；

降低屏幕背光亮度等级；

采用CPU、GPU动态调频调压，并调低CPU、GPU频率下限；

采用thermal-engine.conf 。