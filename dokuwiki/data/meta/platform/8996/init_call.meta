a:2:{s:7:"current";a:8:{s:4:"date";a:2:{s:7:"created";i:1483929654;s:8:"modified";i:1483929654;}s:7:"creator";s:12:"daimiao.chen";s:4:"user";s:12:"daimiao.chen";s:11:"last_change";a:7:{s:4:"date";i:1483929654;s:2:"ip";s:11:"172.19.2.90";s:4:"type";s:1:"C";s:2:"id";s:23:"platform:8996:init_call";s:4:"user";s:12:"daimiao.chen";s:3:"sum";s:6:"创建";s:5:"extra";s:0:"";}s:5:"title";s:42:"如何控制驱动代码的初始化时间";s:11:"description";a:2:{s:15:"tableofcontents";a:3:{i:0;a:4:{s:3:"hid";s:42:"如何控制驱动代码的初始化时间";s:5:"title";s:42:"如何控制驱动代码的初始化时间";s:4:"type";s:2:"ul";s:5:"level";i:2;}i:1;a:4:{s:3:"hid";s:5:"inith";s:5:"title";s:6:"init.h";s:4:"type";s:2:"ul";s:5:"level";i:3;}i:2;a:4:{s:3:"hid";s:6:"实践";s:5:"title";s:6:"实践";s:4:"type";s:2:"ul";s:5:"level";i:3;}}s:8:"abstract";s:422:"如何控制驱动代码的初始化时间

一般情况下，我们注册驱动代码的init函数使用module_init这个宏。但是使用这个宏，我们只能保证代码被运行，不能确定他的运行时间。在有些场合，我们需要保证某个驱动先于另一个驱动被启动，则这个宏的功能就无法完成我们的目的。（我觉得在MTK的代码平台下会比较常有这种情况）";}s:8:"internal";a:2:{s:5:"cache";b:1;s:3:"toc";b:1;}s:8:"relation";a:1:{s:10:"firstimage";s:0:"";}}s:10:"persistent";a:4:{s:4:"date";a:1:{s:7:"created";i:1483929654;}s:7:"creator";s:12:"daimiao.chen";s:4:"user";s:12:"daimiao.chen";s:11:"last_change";a:7:{s:4:"date";i:1483929654;s:2:"ip";s:11:"172.19.2.90";s:4:"type";s:1:"C";s:2:"id";s:23:"platform:8996:init_call";s:4:"user";s:12:"daimiao.chen";s:3:"sum";s:6:"创建";s:5:"extra";s:0:"";}}}