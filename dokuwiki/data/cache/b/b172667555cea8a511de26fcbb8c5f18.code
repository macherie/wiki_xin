<span class="kw4">static</span> <span class="kw4">void</span> e1000_alloc_rx_buffers<span class="br0">&#40;</span><span class="kw4">struct</span> e1000_adapter <span class="sy0">*</span>adapter<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
       <span class="kw4">struct</span> e1000_desc_ring <span class="sy0">*</span>rx_ring <span class="sy0">=</span> <span class="sy0">&amp;</span>adapter<span class="sy0">-&gt;</span>rx_ring<span class="sy0">;</span>
       <span class="kw4">struct</span> net_device <span class="sy0">*</span>netdev <span class="sy0">=</span> adapter<span class="sy0">-&gt;</span>netdev<span class="sy0">;</span>
       <span class="kw4">struct</span> pci_dev <span class="sy0">*</span>pdev <span class="sy0">=</span> adapter<span class="sy0">-&gt;</span>pdev<span class="sy0">;</span>
       <span class="kw4">struct</span> e1000_rx_desc <span class="sy0">*</span>rx_desc<span class="sy0">;</span>
       <span class="kw4">struct</span> e1000_buffer <span class="sy0">*</span>buffer_info<span class="sy0">;</span>
       <span class="kw4">struct</span> sk_buff <span class="sy0">*</span>skb<span class="sy0">;</span>
       <span class="kw4">int</span> reserve_len <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span>
       <span class="kw4">unsigned</span> <span class="kw4">int</span> i<span class="sy0">;</span>
       <span class="coMULTI">/*接收队列中下一个用到的缓冲区索引，初始化是0。并且获取该索引对应的缓冲区信息结构指针buffer_info。*/</span>
       i <span class="sy0">=</span> rx_ring<span class="sy0">-&gt;</span>next_to_use<span class="sy0">;</span>
       buffer_info <span class="sy0">=</span> <span class="sy0">&amp;</span>rx_ring<span class="sy0">-&gt;</span>buffer_info<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy0">;</span>
       <span class="coMULTI">/*如果该缓冲区还没有为sk_buff分配内存，则调用dev_alloc_skb函数分配内存，默认的e1000网卡的接收缓冲区长度是2048字节加上保留长度。
注 意：在e1000_open（）-&gt;e1000_up（）中已经调用了这个函数为环形缓冲区队列中的每一个缓冲区分配了sk_buff内存，但是如 果接收到数据以后，调用netif_receive_skb (skb)向上层提交数据以后，这段内存将始终被这个skb占用（直到上层处理完以后才会调用__kfree_skb释放，但已经跟这里没有关系了），换 句话说，就是当前缓冲区必须重新申请分配sk_buff内存，为了下一个数据做准备。*/</span>
       <span class="kw1">while</span><span class="br0">&#40;</span><span class="sy0">!</span>buffer_info<span class="sy0">-&gt;</span>skb<span class="br0">&#41;</span> <span class="br0">&#123;</span>
              rx_desc <span class="sy0">=</span> E1000_RX_DESC<span class="br0">&#40;</span><span class="sy0">*</span>rx_ring<span class="sy0">,</span> i<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
              skb <span class="sy0">=</span> dev_alloc_skb<span class="br0">&#40;</span>adapter<span class="sy0">-&gt;</span>rx_buffer_len <span class="sy0">+</span> reserve_len<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
              <span class="kw1">if</span><span class="br0">&#40;</span><span class="sy0">!</span>skb<span class="br0">&#41;</span> <span class="br0">&#123;</span>
                     <span class="coMULTI">/* Better luck next round */</span>
                     <span class="kw2">break</span><span class="sy0">;</span>
              <span class="br0">&#125;</span>
              skb_reserve<span class="br0">&#40;</span>skb<span class="sy0">,</span> reserve_len<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
              skb<span class="sy0">-&gt;</span>dev <span class="sy0">=</span> netdev<span class="sy0">;</span>
              <span class="coMULTI">/*映射DMA缓冲区，DMA通道直接将收到的数据写到我们提供的这个缓冲区内，每次必须将缓冲区与DMA通道解除映射关系，才能读取缓冲区内容。*/</span>
              buffer_info<span class="sy0">-&gt;</span>skb <span class="sy0">=</span> skb<span class="sy0">;</span>
              buffer_info<span class="sy0">-&gt;</span>length <span class="sy0">=</span> adapter<span class="sy0">-&gt;</span>rx_buffer_len<span class="sy0">;</span>
              buffer_info<span class="sy0">-&gt;</span>dma <span class="sy0">=</span>
                     pci_map_single<span class="br0">&#40;</span>pdev<span class="sy0">,</span>
                                    skb<span class="sy0">-&gt;</span>data<span class="sy0">,</span>
                                    adapter<span class="sy0">-&gt;</span>rx_buffer_len<span class="sy0">,</span>
                                    PCI_DMA_FROMDEVICE<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
              rx_desc<span class="sy0">-&gt;</span>buffer_addr <span class="sy0">=</span> cpu_to_le64<span class="br0">&#40;</span>buffer_info<span class="sy0">-&gt;</span>dma<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
              <span class="kw1">if</span><span class="br0">&#40;</span><span class="sy0">++</span>i <span class="sy0">==</span> rx_ring<span class="sy0">-&gt;</span>count<span class="br0">&#41;</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
              buffer_info <span class="sy0">=</span> <span class="sy0">&amp;</span>rx_ring<span class="sy0">-&gt;</span>buffer_info<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy0">;</span>
       <span class="br0">&#125;</span>
       rx_ring<span class="sy0">-&gt;</span>next_to_use <span class="sy0">=</span> i<span class="sy0">;</span>
<span class="br0">&#125;</span>