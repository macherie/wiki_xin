<span class="co1">// New class members</span>
<span class="co3">/** Allocate storage for the final combined matrix. This will be passed into the shader program. */</span>
<span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mMVPMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
<span class="co3">/** How many elements per vertex. */</span>
<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mStrideBytes <span class="sy0">=</span> <span class="nu0">7</span> <span class="sy0">*</span> mBytesPerFloat<span class="sy0">;</span>
&nbsp;
<span class="co3">/** Offset of the position data. */</span>
<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mPositionOffset <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
<span class="co3">/** Size of the position data in elements. */</span>
<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mPositionDataSize <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
&nbsp;
<span class="co3">/** Offset of the color data. */</span>
<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mColorOffset <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
&nbsp;
<span class="co3">/** Size of the color data in elements. */</span>
<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mColorDataSize <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">;</span>
&nbsp;
<span class="co3">/**
 * Draws a triangle from the given vertex data.
 *
 * @param aTriangleBuffer The buffer containing the vertex data.
 */</span>
<span class="kw1">private</span> <span class="kw4">void</span> drawTriangle<span class="br0">&#40;</span><span class="kw1">final</span> FloatBuffer aTriangleBuffer<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// Pass in the position information</span>
    aTriangleBuffer.<span class="me1">position</span><span class="br0">&#40;</span>mPositionOffset<span class="br0">&#41;</span><span class="sy0">;</span>
    GLES20.<span class="me1">glVertexAttribPointer</span><span class="br0">&#40;</span>mPositionHandle, mPositionDataSize, GLES20.<span class="me1">GL_FLOAT</span>, <span class="kw2">false</span>,
            mStrideBytes, aTriangleBuffer<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    GLES20.<span class="me1">glEnableVertexAttribArray</span><span class="br0">&#40;</span>mPositionHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Pass in the color information</span>
    aTriangleBuffer.<span class="me1">position</span><span class="br0">&#40;</span>mColorOffset<span class="br0">&#41;</span><span class="sy0">;</span>
    GLES20.<span class="me1">glVertexAttribPointer</span><span class="br0">&#40;</span>mColorHandle, mColorDataSize, GLES20.<span class="me1">GL_FLOAT</span>, <span class="kw2">false</span>,
            mStrideBytes, aTriangleBuffer<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    GLES20.<span class="me1">glEnableVertexAttribArray</span><span class="br0">&#40;</span>mColorHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// This multiplies the view matrix by the model matrix, and stores the result in the MVP matrix</span>
    <span class="co1">// (which currently contains model * view).</span>
    Matrix.<span class="me1">multiplyMM</span><span class="br0">&#40;</span>mMVPMatrix, <span class="nu0">0</span>, mViewMatrix, <span class="nu0">0</span>, mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// This multiplies the modelview matrix by the projection matrix, and stores the result in the MVP matrix</span>
    <span class="co1">// (which now contains model * view * projection).</span>
    Matrix.<span class="me1">multiplyMM</span><span class="br0">&#40;</span>mMVPMatrix, <span class="nu0">0</span>, mProjectionMatrix, <span class="nu0">0</span>, mMVPMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    GLES20.<span class="me1">glUniformMatrix4fv</span><span class="br0">&#40;</span>mMVPMatrixHandle, <span class="nu0">1</span>, <span class="kw2">false</span>, mMVPMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
    GLES20.<span class="me1">glDrawArrays</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_TRIANGLES</span>, <span class="nu0">0</span>, <span class="nu0">3</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>