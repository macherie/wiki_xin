a:119:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:0;}i:2;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:1;}i:3;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"---";}i:2;i:2;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:5;}i:5;a:3:{i:0;s:13:"emphasis_open";i:1;a:0:{}i:2;i:6;}i:6;a:3:{i:0;s:9:"emaillink";i:1;a:2:{i:0;s:23:"liangjiong.zhou@sim.com";i:1;s:15:"liangjiong.zhou";}i:2;i:8;}i:7;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:" 2013/12/06 02:41";}i:2;i:51;}i:8;a:3:{i:0;s:14:"emphasis_close";i:1;a:0:{}i:2;i:68;}i:9;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:70;}i:10;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:30:"Android对Linux内核的增强";i:1;i:1;i:2;i:72;}i:2;i:72;}i:11;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:72;}i:12;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:72;}i:13;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:"Alarm(硬件时钟)";}i:2;i:117;}i:14;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:136;}i:15;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:136;}i:16;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:"Ashmem(匿名内存共享)";}i:2;i:138;}i:17;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:164;}i:18;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:164;}i:19;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:34:"Low Memory Killer(低内存管理)";}i:2;i:166;}i:20;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:200;}i:21;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:200;}i:22;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:"Logger(日志设备)";}i:2;i:202;}i:23;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:222;}i:24;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:225;}i:25;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"Alarm(硬件时钟)";i:1;i:2;i:2;i:225;}i:2;i:225;}i:26;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:225;}i:27;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:225;}i:28;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"todo";}i:2;i:258;}i:29;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:262;}i:30;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:265;}i:31;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:26:"Ashmem(匿名内存共享)";i:1;i:2;i:2;i:265;}i:2;i:265;}i:32;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:265;}i:33;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:265;}i:34;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"todo";}i:2;i:304;}i:35;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:308;}i:36;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:311;}i:37;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:34:"Low Memory Killer(低内存管理)";i:1;i:2;i:2;i:311;}i:2;i:311;}i:38;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:311;}i:39;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:311;}i:40;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:56:"今天(2013-11-25)在一台S200机器上看到一段log:";}i:2;i:359;}i:41;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:421;}i:42;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:266:"
58780 <4>[152689.665953] [(2013-11-23 21:09:27.230597932 UTC)] [cpuid: 0] select 31758 (d.process.media), adj 0, size 5414, to kill
58781 <4>[152689.665975] [(2013-11-23 21:09:27.230617932 UTC)] [cpuid: 2] select 32547 (droid.gallery3d), adj 0, size 15583, to kill
";i:1;N;i:2;N;}i:2;i:421;}i:43;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:421;}i:44;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:238:"一直有这几个log在重复。这是什么东西呢，这就是Android添加在内核里的内存回收的东西。原来这太机器跑过Monkey Test，内存消耗很多，后来又跑了长时间录像，
跑到了系统开始回收";}i:2;i:697;}i:45;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:935;}i:46;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:"前台";}i:2;i:936;}i:47;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:942;}i:48;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:"程序的情况了。";}i:2;i:943;}i:49;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:964;}i:50;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:964;}i:51;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:48:"我们来看看 Android 的 Low Memory Killer。";}i:2;i:966;}i:52;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1014;}i:53;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1014;}i:54;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:28:"PS. 摘点网上的东西。";}i:2;i:1016;}i:55;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1044;}i:56;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1046;}i:57;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:6:"概要";i:1;i:3;i:2;i:1046;}i:2;i:1046;}i:58;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1046;}i:59;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1046;}i:60;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:507:"对于PC来说，内存是至关重要。如果某个程序发生了内存泄漏，那么一般情况下系统就会将其进程Kill掉。Linux中使用一种名称为OOM(Out Of Memory，内存不足)的机制来完成这个任务，该机制会在系统内存不足的情况下，选择一个进程并将其Kill掉。Android则使用了一个新的机制——Low Memory Killer来完成同样的任务。下面首先来看看Low Memory Killer机制的原理以及它是如何选择将被Kill的进程的。";}i:2;i:1063;}i:61;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1570;}i:62;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1572;}i:63;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:37:"1.Low Memory Killer的原理和机制";i:1;i:3;i:2;i:1572;}i:2;i:1572;}i:64;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1572;}i:65;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1572;}i:66;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:166:"Low Memory Killer在用户空间中指定了一组内存临界值，当其中的某个值与进程描述中的oom_adj值在同一范围时，该进程将被Kill掉。";}i:2;i:1621;}i:67;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1787;}i:68;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1787;}i:69;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:242:"通常，在“/sys/module/lowmemorykiller/parameters/adj”中指定oom_adj的最小值，在“/sys/module/lowmemorykiller/parameters/minfree”中储存空闲页面的数量，所有的值都用一个逗号将其隔开且以升序排列。";}i:2;i:1789;}i:70;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2031;}i:71;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2031;}i:72;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:407:"比如：把“0,8”写入到/sys/module/lowmemorykiller/parameters/adj中，把“1024,4096”写入到/sys/module/lowmemory- killer/parameters/minfree中，就表示当一个进程的空闲存储空间下降到4096个页面时，oom_adj值为8或者更大的进程会被Kill掉。同理，当一个进程的空闲存储空间下降到1024个页面时，oom_adj值为0或者更大的进程会被Kill掉。";}i:2;i:2033;}i:73;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2440;}i:74;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2440;}i:75;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:120:"我们发现在lowmemorykiller.c(drivers/staging/android/lowmemorykiller.c)中就指定了这样的值，如下所示：";}i:2;i:2442;}i:76;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2562;}i:77;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:261:"
static int lowmem_adj[6] = { 
        0,  
        1,  
        6,  
        12, 
};
static int lowmem_minfree[6] = { 
        3 * 512,        /* 6MB */
        2 * 1024,       /* 8MB */
        4 * 1024,       /* 16MB */
        16 * 1024,      /* 64MB */
};
";i:1;s:1:"c";i:2;N;}i:2;i:2569;}i:78;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2569;}i:79;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:141:"从上面的代码里可以看出，当一个进程的空闲空间下降到3*512个页面时oom_adj值为0或者更大的进程会被Kill掉;";}i:2;i:2842;}i:80;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2983;}i:81;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2983;}i:82;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:106:"当一个进程的空闲空间下降到2*1024个页面时oom_adj值为0或者更大的进程会被Kill掉;";}i:2;i:2985;}i:83;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3091;}i:84;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3091;}i:85;a:3:{i:0;s:6:"smiley";i:1;a:1:{i:0;s:3:":-x";}i:2;i:3093;}i:86;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:3096;}i:87;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:87:"PS.: 其实0表示的是前台激活的进程，这个进程都要杀了还让人活不";}i:2;i:3098;}i:88;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:3185;}i:89;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3187;}i:90;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3187;}i:91;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:79:"其实更简明的理解就是满足以下条件的进程将被优先Kill掉：";}i:2;i:3189;}i:92;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3268;}i:93;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:132:"
    task_struct->signal_struct->oom_adj越大的越优先被Kill。
    占用物理内存最多的那个进程会被优先Kill。
";i:1;N;i:2;N;}i:2;i:3275;}i:94;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3275;}i:95;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:34:"进程描述符中的signal_struct";}i:2;i:3418;}i:96;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"->";}i:2;i:3452;}i:97;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:238:"oom_adj表示当内存短缺时进程被选择并Kill的优先级，取值范围是-17~15。如果是-17，则表示不会被选中，值越大越可能被选中。当某个进程被选中后，内核会发送SIGKILL信号将其Kill掉。";}i:2;i:3454;}i:98;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3692;}i:99;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3692;}i:100;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:295:"实际上，Low Memory Killer驱动程序会认为被用于缓存的存储空间都要被释放，但是，如果很大一部分缓存存储空间处于被锁定的状态，那么这将是一个非常严重的错误，并且当正常的oom killer被触发之前，进程是不会被Kill掉的。";}i:2;i:3695;}i:101;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3990;}i:102;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3993;}i:103;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:34:"2.Low Memory Killer的具体实现";i:1;i:3;i:2;i:3993;}i:2;i:3993;}i:104;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:3993;}i:105;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3993;}i:106;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:79:"Low Memory Killer驱动的实现位于drivers/staging/android/lowmemorykiller.c";}i:2;i:4039;}i:107;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4118;}i:108;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4118;}i:109;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:30:"该驱动的实现非常简单";}i:2;i:4120;}i:110;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4150;}i:111;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4153;}i:112;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"Logger(日志设备)";i:1;i:2;i:2;i:4153;}i:2;i:4153;}i:113;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:4153;}i:114;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4153;}i:115;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"todo";}i:2;i:4186;}i:116;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4190;}i:117;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4201;}i:118;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:4201;}}