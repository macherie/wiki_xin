<span class="kw4">static</span> <span class="kw4">void</span> net_rx_action<span class="br0">&#40;</span><span class="kw4">struct</span> softirq_action <span class="sy0">*</span>h<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
       <span class="kw4">int</span> this_cpu <span class="sy0">=</span> smp_processor_id<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
       <span class="coMULTI">/*获取当前CPU的接收数据队列。*/</span>
       <span class="kw4">struct</span> softnet_data <span class="sy0">*</span>queue <span class="sy0">=</span> <span class="sy0">&amp;</span>softnet_data<span class="br0">&#91;</span>this_cpu<span class="br0">&#93;</span><span class="sy0">;</span>
       <span class="kw4">unsigned</span> <span class="kw4">long</span> start_time <span class="sy0">=</span> jiffies<span class="sy0">;</span>
<span class="coMULTI">/*呵呵，这里先做个预算，限定我们只能处理这么多数据（300个）。*/</span>
       <span class="kw4">int</span> budget <span class="sy0">=</span> netdev_max_backlog<span class="sy0">;</span>
&nbsp;
       br_read_lock<span class="br0">&#40;</span>BR_NETPROTO_LOCK<span class="br0">&#41;</span><span class="sy0">;</span>
       local_irq_disable<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
       <span class="coMULTI">/*
       进入一个循环，因为软中断处理函数与硬件中断并不是同步的，因此，我们此时并不知道数据包属于哪个设备，因此只能采取逐个查询的方式，遍历整个接收设备列表。
       */</span>
       <span class="kw1">while</span> <span class="br0">&#40;</span><span class="sy0">!</span>list_empty<span class="br0">&#40;</span><span class="sy0">&amp;</span>queue<span class="sy0">-&gt;</span>poll_list<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
              <span class="kw4">struct</span> net_device <span class="sy0">*</span>dev<span class="sy0">;</span>
              <span class="coMULTI">/*如果花费超过预算，或者处理时间超过1秒，立刻从软中断处理函数跳出，我想这可能是系统考虑效率和实时性，一次不能做过多的工作或者浪费过多的时间。*/</span>
              <span class="kw1">if</span> <span class="br0">&#40;</span>budget <span class="sy0">&lt;=</span> <span class="nu0">0</span> <span class="sy0">||</span> jiffies <span class="sy0">-</span> start_time <span class="sy0">&gt;</span> <span class="nu0">1</span><span class="br0">&#41;</span>
                     <span class="kw1">goto</span> softnet_break<span class="sy0">;</span>
&nbsp;
              local_irq_enable<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="coMULTI">/*从当前列表中取出一个接收设备。并根据其配额判断是否能够继续接收数据，如果配额不足（&lt;=0），则立刻将该设备从设备列表中删除。并且再次插入队列当中，同时为该设备分配一定的配额，允许它继续处理数据包。
如果此时配额足够，则调用设备的 poll方法，对于e1000网卡来说，如果采用中断方式处理数据，则调用系统默认poll方法process_backlog（），而对于采用NAPI 来说，则是调用e1000_clean（）函数了。记住这里第一次传递的预算是300 ^_^。*/</span>
              dev <span class="sy0">=</span> list_entry<span class="br0">&#40;</span>queue<span class="sy0">-&gt;</span>poll_list.<span class="me1">next</span><span class="sy0">,</span> <span class="kw4">struct</span> net_device<span class="sy0">,</span> poll_list<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
              <span class="kw1">if</span> <span class="br0">&#40;</span>dev<span class="sy0">-&gt;</span>quota <span class="sy0">&lt;=</span> <span class="nu0">0</span> <span class="sy0">||</span> dev<span class="sy0">-&gt;</span>poll<span class="br0">&#40;</span>dev<span class="sy0">,</span> <span class="sy0">&amp;</span>budget<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
                     local_irq_disable<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
                     list_del<span class="br0">&#40;</span><span class="sy0">&amp;</span>dev<span class="sy0">-&gt;</span>poll_list<span class="br0">&#41;</span><span class="sy0">;</span>
                     list_add_tail<span class="br0">&#40;</span><span class="sy0">&amp;</span>dev<span class="sy0">-&gt;</span>poll_list<span class="sy0">,</span> <span class="sy0">&amp;</span>queue<span class="sy0">-&gt;</span>poll_list<span class="br0">&#41;</span><span class="sy0">;</span>
                     <span class="kw1">if</span> <span class="br0">&#40;</span>dev<span class="sy0">-&gt;</span>quota <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">&#41;</span>
                            dev<span class="sy0">-&gt;</span>quota <span class="sy0">+=</span> dev<span class="sy0">-&gt;</span>weight<span class="sy0">;</span>
                     <span class="kw1">else</span>
                            dev<span class="sy0">-&gt;</span>quota <span class="sy0">=</span> dev<span class="sy0">-&gt;</span>weight<span class="sy0">;</span>
              <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
                     dev_put<span class="br0">&#40;</span>dev<span class="br0">&#41;</span><span class="sy0">;</span>
                     local_irq_disable<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
              <span class="br0">&#125;</span>
       <span class="br0">&#125;</span>
&nbsp;
       local_irq_enable<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
       br_read_unlock<span class="br0">&#40;</span>BR_NETPROTO_LOCK<span class="br0">&#41;</span><span class="sy0">;</span>
       <span class="kw1">return</span><span class="sy0">;</span>
&nbsp;
softnet_break<span class="sy0">:</span>
       netdev_rx_stat<span class="br0">&#91;</span>this_cpu<span class="br0">&#93;</span>.<span class="me1">time_squeeze</span><span class="sy0">++;</span>
       <span class="coMULTI">/*再次产生软中断，准备下一次数据包处理。*/</span>
       __cpu_raise_softirq<span class="br0">&#40;</span>this_cpu<span class="sy0">,</span> NET_RX_SOFTIRQ<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
       local_irq_enable<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
       br_read_unlock<span class="br0">&#40;</span>BR_NETPROTO_LOCK<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>