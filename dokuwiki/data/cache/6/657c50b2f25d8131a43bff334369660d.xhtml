
<p>
1.Opengl es2 学习网址：<a href="http://www.learnopengles.com/android-lesson-one-getting-started/" class="urlextern" title="http://www.learnopengles.com/android-lesson-one-getting-started/"  rel="nofollow">http://www.learnopengles.com/android-lesson-one-getting-started/</a>
</p>

<p>
2.OpenGL ES2 例子
</p>
<pre class="code java"><span class="kw1">package</span> <span class="co2">com.learnopengles.android.lesson1</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">import</span> <span class="co2">android.app.Activity</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.app.ActivityManager</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.content.Context</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.content.pm.ConfigurationInfo</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.opengl.GLSurfaceView</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.os.Bundle</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">public</span> <span class="kw1">class</span> LessonOneActivity <span class="kw1">extends</span> Activity 
<span class="br0">&#123;</span>
	<span class="co3">/** Hold a reference to our GLSurfaceView */</span>
	<span class="kw1">private</span> GLSurfaceView mGLSurfaceView<span class="sy0">;</span>
&nbsp;
	@Override
	<span class="kw1">public</span> <span class="kw4">void</span> onCreate<span class="br0">&#40;</span>Bundle savedInstanceState<span class="br0">&#41;</span> 
	<span class="br0">&#123;</span>
		<span class="kw1">super</span>.<span class="me1">onCreate</span><span class="br0">&#40;</span>savedInstanceState<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		mGLSurfaceView <span class="sy0">=</span> <span class="kw1">new</span> GLSurfaceView<span class="br0">&#40;</span><span class="kw1">this</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Check if the system supports OpenGL ES 2.0.</span>
		<span class="kw1">final</span> ActivityManager activityManager <span class="sy0">=</span> <span class="br0">&#40;</span>ActivityManager<span class="br0">&#41;</span> getSystemService<span class="br0">&#40;</span><a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+context"><span class="kw3">Context</span></a>.<span class="me1">ACTIVITY_SERVICE</span><span class="br0">&#41;</span><span class="sy0">;</span>
                <span class="co1">//获取平台配置信息，判断是否支持opengl es2</span>
		<span class="kw1">final</span> ConfigurationInfo configurationInfo <span class="sy0">=</span> activityManager.<span class="me1">getDeviceConfigurationInfo</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">boolean</span> supportsEs2 <span class="sy0">=</span> configurationInfo.<span class="me1">reqGlEsVersion</span> <span class="sy0">&gt;=</span> 0x20000<span class="sy0">;</span>
&nbsp;
		<span class="kw1">if</span> <span class="br0">&#40;</span>supportsEs2<span class="br0">&#41;</span> 
		<span class="br0">&#123;</span>
			<span class="co1">// Request an OpenGL ES 2.0 compatible context.</span>
			mGLSurfaceView.<span class="me1">setEGLContextClientVersion</span><span class="br0">&#40;</span><span class="nu0">2</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
			<span class="co1">// Set the renderer to our demo renderer, defined below.</span>
			mGLSurfaceView.<span class="me1">setRenderer</span><span class="br0">&#40;</span><span class="kw1">new</span> LessonOneRenderer<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="br0">&#125;</span> 
		<span class="kw1">else</span> 
		<span class="br0">&#123;</span>
			<span class="co1">// This is where you could create an OpenGL ES 1.x compatible</span>
			<span class="co1">// renderer if you wanted to support both ES 1 and ES 2.</span>
			<span class="kw1">return</span><span class="sy0">;</span>
		<span class="br0">&#125;</span>
&nbsp;
		setContentView<span class="br0">&#40;</span>mGLSurfaceView<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	@Override
	<span class="kw1">protected</span> <span class="kw4">void</span> onResume<span class="br0">&#40;</span><span class="br0">&#41;</span> 
	<span class="br0">&#123;</span>
		<span class="co1">// The activity must call the GL surface view's onResume() on activity onResume().</span>
		<span class="kw1">super</span>.<span class="me1">onResume</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		mGLSurfaceView.<span class="me1">onResume</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	@Override
	<span class="kw1">protected</span> <span class="kw4">void</span> onPause<span class="br0">&#40;</span><span class="br0">&#41;</span> 
	<span class="br0">&#123;</span>
		<span class="co1">// The activity must call the GL surface view's onPause() on activity onPause().</span>
		<span class="kw1">super</span>.<span class="me1">onPause</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		mGLSurfaceView.<span class="me1">onPause</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>	
<span class="br0">&#125;</span></pre>
<pre class="code java"><span class="kw1">package</span> <span class="co2">com.learnopengles.android.lesson1</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">import</span> <span class="co2">java.nio.ByteBuffer</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.nio.ByteOrder</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.nio.FloatBuffer</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">import</span> <span class="co2">javax.microedition.khronos.egl.EGLConfig</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">javax.microedition.khronos.opengles.GL10</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">import</span> <span class="co2">android.opengl.GLES20</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.opengl.GLSurfaceView</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.opengl.Matrix</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.os.SystemClock</span><span class="sy0">;</span>
&nbsp;
<span class="co3">/**
 * This class implements our custom renderer. Note that the GL10 parameter passed in is unused for OpenGL ES 2.0
 * renderers -- the static class GLES20 is used instead.
 */</span>
<span class="kw1">public</span> <span class="kw1">class</span> LessonOneRenderer <span class="kw1">implements</span> GLSurfaceView.<a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+renderer"><span class="kw3">Renderer</span></a> 
<span class="br0">&#123;</span>
	<span class="co3">/**
	 * Store the model matrix. This matrix is used to move models from object space (where each model can be thought
	 * of being located at the center of the universe) to world space.
	 */</span>
	<span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mModelMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/**
	 * Store the view matrix. This can be thought of as our camera. This matrix transforms world space to eye space;
	 * it positions things relative to our eye.
	 */</span>
	<span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mViewMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** Store the projection matrix. This is used to project the scene onto a 2D viewport. */</span>
	<span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mProjectionMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** Allocate storage for the final combined matrix. This will be passed into the shader program. */</span>
	<span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mMVPMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** Store our model data in a float buffer. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> FloatBuffer mTriangle1Vertices<span class="sy0">;</span>
	<span class="kw1">private</span> <span class="kw1">final</span> FloatBuffer mTriangle2Vertices<span class="sy0">;</span>
	<span class="kw1">private</span> <span class="kw1">final</span> FloatBuffer mTriangle3Vertices<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This will be used to pass in the transformation matrix. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mMVPMatrixHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This will be used to pass in model position information. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mPositionHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This will be used to pass in model color information. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mColorHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** How many bytes per float. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mBytesPerFloat <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** How many elements per vertex. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mStrideBytes <span class="sy0">=</span> <span class="nu0">7</span> <span class="sy0">*</span> mBytesPerFloat<span class="sy0">;</span>	
&nbsp;
	<span class="co3">/** Offset of the position data. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mPositionOffset <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** Size of the position data in elements. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mPositionDataSize <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** Offset of the color data. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mColorOffset <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** Size of the color data in elements. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mColorDataSize <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">;</span>		
&nbsp;
	<span class="co3">/**
	 * Initialize the model data.
	 */</span>
	<span class="kw1">public</span> LessonOneRenderer<span class="br0">&#40;</span><span class="br0">&#41;</span>
	<span class="br0">&#123;</span>	
		<span class="co1">// Define points for equilateral triangles.</span>
&nbsp;
		<span class="co1">// This triangle is red, green, and blue.</span>
		<span class="kw1">final</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> triangle1VerticesData <span class="sy0">=</span> <span class="br0">&#123;</span>
		    <span class="co1">// X, Y, Z, </span>
		    <span class="co1">// R, G, B, A</span>
	            <span class="sy0">-</span>0.5f, <span class="sy0">-</span>0.25f, 0.0f,     <span class="co1">//表示顶点v1的坐标</span>
	            1.0f, 0.0f, 0.0f, 1.0f,  <span class="co1">//表示顶点v1的颜色</span>
&nbsp;
	            0.5f, <span class="sy0">-</span>0.25f, 0.0f,      <span class="co1">//表示顶点v2的坐标</span>
	            0.0f, 0.0f, 1.0f, 1.0f,  <span class="co1">//表示顶点v2的颜色</span>
&nbsp;
	            0.0f, 0.559016994f, 0.0f, <span class="co1">//表示顶点v3的坐标</span>
	            0.0f, 1.0f, 0.0f, 1.0f<span class="br0">&#125;</span><span class="sy0">;</span>  <span class="co1">//表示顶点v3的颜色</span>
&nbsp;
		<span class="co1">// This triangle is yellow, cyan, and magenta.</span>
		<span class="kw1">final</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> triangle2VerticesData <span class="sy0">=</span> <span class="br0">&#123;</span>
		    <span class="co1">// X, Y, Z, </span>
		    <span class="co1">// R, G, B, A</span>
	            <span class="sy0">-</span>0.5f, <span class="sy0">-</span>0.25f, 0.0f, 
	            1.0f, 1.0f, 0.0f, 1.0f,
&nbsp;
	            0.5f, <span class="sy0">-</span>0.25f, 0.0f, 
	            0.0f, 1.0f, 1.0f, 1.0f,
&nbsp;
	            0.0f, 0.559016994f, 0.0f, 
	            1.0f, 0.0f, 1.0f, 1.0f<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// This triangle is white, gray, and black.</span>
		<span class="kw1">final</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> triangle3VerticesData <span class="sy0">=</span> <span class="br0">&#123;</span>
		    <span class="co1">// X, Y, Z, </span>
		    <span class="co1">// R, G, B, A</span>
	            <span class="sy0">-</span>0.5f, <span class="sy0">-</span>0.25f, 0.0f, 
	            1.0f, 1.0f, 1.0f, 1.0f,
&nbsp;
	            0.5f, <span class="sy0">-</span>0.25f, 0.0f, 
	            0.5f, 0.5f, 0.5f, 1.0f,
&nbsp;
	            0.0f, 0.559016994f, 0.0f, 
	            0.0f, 0.0f, 0.0f, 1.0f<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Initialize the buffers.</span>
		mTriangle1Vertices <span class="sy0">=</span> ByteBuffer.<span class="me1">allocateDirect</span><span class="br0">&#40;</span>triangle1VerticesData.<span class="me1">length</span> <span class="sy0">*</span> mBytesPerFloat<span class="br0">&#41;</span>
                         .<span class="me1">order</span><span class="br0">&#40;</span>ByteOrder.<span class="me1">nativeOrder</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>.<span class="me1">asFloatBuffer</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		mTriangle2Vertices <span class="sy0">=</span> ByteBuffer.<span class="me1">allocateDirect</span><span class="br0">&#40;</span>triangle2VerticesData.<span class="me1">length</span> <span class="sy0">*</span> mBytesPerFloat<span class="br0">&#41;</span>
                         .<span class="me1">order</span><span class="br0">&#40;</span>ByteOrder.<span class="me1">nativeOrder</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>.<span class="me1">asFloatBuffer</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		mTriangle3Vertices <span class="sy0">=</span> ByteBuffer.<span class="me1">allocateDirect</span><span class="br0">&#40;</span>triangle3VerticesData.<span class="me1">length</span> <span class="sy0">*</span> mBytesPerFloat<span class="br0">&#41;</span>
                         .<span class="me1">order</span><span class="br0">&#40;</span>ByteOrder.<span class="me1">nativeOrder</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>.<span class="me1">asFloatBuffer</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		mTriangle1Vertices.<span class="me1">put</span><span class="br0">&#40;</span>triangle1VerticesData<span class="br0">&#41;</span>.<span class="me1">position</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
		mTriangle2Vertices.<span class="me1">put</span><span class="br0">&#40;</span>triangle2VerticesData<span class="br0">&#41;</span>.<span class="me1">position</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
		mTriangle3Vertices.<span class="me1">put</span><span class="br0">&#40;</span>triangle3VerticesData<span class="br0">&#41;</span>.<span class="me1">position</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	@Override
	<span class="kw1">public</span> <span class="kw4">void</span> onSurfaceCreated<span class="br0">&#40;</span>GL10 glUnused, EGLConfig config<span class="br0">&#41;</span> 
	<span class="br0">&#123;</span>
		<span class="co1">// Set the background clear color to gray.</span>
		GLES20.<span class="me1">glClearColor</span><span class="br0">&#40;</span>0.5f, 0.5f, 0.5f, 0.5f<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Position the eye behind the origin.</span>
		<span class="kw1">final</span> <span class="kw4">float</span> eyeX <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> eyeY <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> eyeZ <span class="sy0">=</span> 1.5f<span class="sy0">;</span>
&nbsp;
		<span class="co1">// We are looking toward the distance</span>
		<span class="kw1">final</span> <span class="kw4">float</span> lookX <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> lookY <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> lookZ <span class="sy0">=</span> <span class="sy0">-</span>5.0f<span class="sy0">;</span>
&nbsp;
		<span class="co1">// Set our up vector. This is where our head would be pointing were we holding the camera.</span>
		<span class="kw1">final</span> <span class="kw4">float</span> upX <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> upY <span class="sy0">=</span> 1.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> upZ <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
&nbsp;
		<span class="co1">// Set the view matrix. This matrix can be said to represent the camera position.</span>
		<span class="co1">// NOTE: In OpenGL 1, a ModelView matrix is used, which is a combination of a model and</span>
		<span class="co1">// view matrix. In OpenGL 2, we can keep track of these matrices separately if we choose.</span>
		Matrix.<span class="me1">setLookAtM</span><span class="br0">&#40;</span>mViewMatrix, <span class="nu0">0</span>, eyeX, eyeY, eyeZ, lookX, lookY, lookZ, upX, upY, upZ<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> vertexShader <span class="sy0">=</span>
		  <span class="st0">&quot;uniform mat4 u_MVPMatrix;      <span class="es0">\n</span>&quot;</span>		<span class="co1">// A constant representing the combined model/view/projection matrix.</span>
&nbsp;
		  <span class="sy0">+</span> <span class="st0">&quot;attribute vec4 a_Position;     <span class="es0">\n</span>&quot;</span>		<span class="co1">// Per-vertex position information we will pass in.</span>
		  <span class="sy0">+</span> <span class="st0">&quot;attribute vec4 a_Color;        <span class="es0">\n</span>&quot;</span>		<span class="co1">// Per-vertex color information we will pass in.			  </span>
&nbsp;
		  <span class="sy0">+</span> <span class="st0">&quot;varying vec4 v_Color;          <span class="es0">\n</span>&quot;</span>		<span class="co1">// This will be passed into the fragment shader.</span>
&nbsp;
		  <span class="sy0">+</span> <span class="st0">&quot;void main()                    <span class="es0">\n</span>&quot;</span>		<span class="co1">// The entry point for our vertex shader.</span>
		  <span class="sy0">+</span> <span class="st0">&quot;{                              <span class="es0">\n</span>&quot;</span>
		  <span class="sy0">+</span> <span class="st0">&quot;   v_Color = a_Color;          <span class="es0">\n</span>&quot;</span>		<span class="co1">// Pass the color through to the fragment shader. </span>
		  						<span class="co1">// It will be interpolated across the triangle.</span>
		  <span class="sy0">+</span> <span class="st0">&quot;   gl_Position = u_MVPMatrix   <span class="es0">\n</span>&quot;</span> 	<span class="co1">// gl_Position is a special variable used to store the final position.</span>
		  <span class="sy0">+</span> <span class="st0">&quot;               * a_Position;   <span class="es0">\n</span>&quot;</span>         <span class="co1">// Multiply the vertex by the matrix to get the final point in 			                                            			 </span>
		  <span class="sy0">+</span> <span class="st0">&quot;}                              <span class="es0">\n</span>&quot;</span><span class="sy0">;</span>        <span class="co1">// normalized screen coordinates.</span>
&nbsp;
		<span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> fragmentShader <span class="sy0">=</span>
		  <span class="st0">&quot;precision mediump float;       <span class="es0">\n</span>&quot;</span>	<span class="co1">// Set the default precision to medium. We don't need as high of a </span>
								<span class="co1">// precision in the fragment shader.				</span>
		  <span class="sy0">+</span> <span class="st0">&quot;varying vec4 v_Color;          <span class="es0">\n</span>&quot;</span>		<span class="co1">// This is the color from the vertex shader interpolated across the </span>
		  						<span class="co1">// triangle per fragment.			  </span>
		  <span class="sy0">+</span> <span class="st0">&quot;void main()                    <span class="es0">\n</span>&quot;</span>		<span class="co1">// The entry point for our fragment shader.</span>
		  <span class="sy0">+</span> <span class="st0">&quot;{                              <span class="es0">\n</span>&quot;</span>
		  <span class="sy0">+</span> <span class="st0">&quot;   gl_FragColor = v_Color;     <span class="es0">\n</span>&quot;</span>		<span class="co1">// Pass the color directly through the pipeline.		  </span>
		  <span class="sy0">+</span> <span class="st0">&quot;}                             <span class="es0">\n</span>&quot;</span><span class="sy0">;</span>												
&nbsp;
		<span class="co1">// Load in the vertex shader.</span>
		<span class="kw4">int</span> vertexShaderHandle <span class="sy0">=</span> GLES20.<span class="me1">glCreateShader</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_VERTEX_SHADER</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="kw1">if</span> <span class="br0">&#40;</span>vertexShaderHandle <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span> 
		<span class="br0">&#123;</span>
			<span class="co1">// Pass in the shader source.</span>
			GLES20.<span class="me1">glShaderSource</span><span class="br0">&#40;</span>vertexShaderHandle, vertexShader<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
			<span class="co1">// Compile the shader.</span>
			GLES20.<span class="me1">glCompileShader</span><span class="br0">&#40;</span>vertexShaderHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
			<span class="co1">// Get the compilation status.</span>
			<span class="kw1">final</span> <span class="kw4">int</span><span class="br0">&#91;</span><span class="br0">&#93;</span> compileStatus <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">int</span><span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy0">;</span>
			GLES20.<span class="me1">glGetShaderiv</span><span class="br0">&#40;</span>vertexShaderHandle, GLES20.<span class="me1">GL_COMPILE_STATUS</span>, compileStatus, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
			<span class="co1">// If the compilation failed, delete the shader.</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>compileStatus<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> 
			<span class="br0">&#123;</span>				
				GLES20.<span class="me1">glDeleteShader</span><span class="br0">&#40;</span>vertexShaderHandle<span class="br0">&#41;</span><span class="sy0">;</span>
				vertexShaderHandle <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
&nbsp;
		<span class="kw1">if</span> <span class="br0">&#40;</span>vertexShaderHandle <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
		<span class="br0">&#123;</span>
			<span class="kw1">throw</span> <span class="kw1">new</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+runtimeexception"><span class="kw3">RuntimeException</span></a><span class="br0">&#40;</span><span class="st0">&quot;Error creating vertex shader.&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="br0">&#125;</span>
&nbsp;
		<span class="co1">// Load in the fragment shader shader.</span>
		<span class="kw4">int</span> fragmentShaderHandle <span class="sy0">=</span> GLES20.<span class="me1">glCreateShader</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_FRAGMENT_SHADER</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="kw1">if</span> <span class="br0">&#40;</span>fragmentShaderHandle <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span> 
		<span class="br0">&#123;</span>
			<span class="co1">// Pass in the shader source.</span>
			GLES20.<span class="me1">glShaderSource</span><span class="br0">&#40;</span>fragmentShaderHandle, fragmentShader<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
			<span class="co1">// Compile the shader.</span>
			GLES20.<span class="me1">glCompileShader</span><span class="br0">&#40;</span>fragmentShaderHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
			<span class="co1">// Get the compilation status.</span>
			<span class="kw1">final</span> <span class="kw4">int</span><span class="br0">&#91;</span><span class="br0">&#93;</span> compileStatus <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">int</span><span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy0">;</span>
			GLES20.<span class="me1">glGetShaderiv</span><span class="br0">&#40;</span>fragmentShaderHandle, GLES20.<span class="me1">GL_COMPILE_STATUS</span>, compileStatus, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
			<span class="co1">// If the compilation failed, delete the shader.</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>compileStatus<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> 
			<span class="br0">&#123;</span>				
				GLES20.<span class="me1">glDeleteShader</span><span class="br0">&#40;</span>fragmentShaderHandle<span class="br0">&#41;</span><span class="sy0">;</span>
				fragmentShaderHandle <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
&nbsp;
		<span class="kw1">if</span> <span class="br0">&#40;</span>fragmentShaderHandle <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
		<span class="br0">&#123;</span>
			<span class="kw1">throw</span> <span class="kw1">new</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+runtimeexception"><span class="kw3">RuntimeException</span></a><span class="br0">&#40;</span><span class="st0">&quot;Error creating fragment shader.&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="br0">&#125;</span>
&nbsp;
		<span class="co1">// Create a program object and store the handle to it.</span>
		<span class="kw4">int</span> programHandle <span class="sy0">=</span> GLES20.<span class="me1">glCreateProgram</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="kw1">if</span> <span class="br0">&#40;</span>programHandle <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span> 
		<span class="br0">&#123;</span>
			<span class="co1">// Bind the vertex shader to the program.</span>
			GLES20.<span class="me1">glAttachShader</span><span class="br0">&#40;</span>programHandle, vertexShaderHandle<span class="br0">&#41;</span><span class="sy0">;</span>			
&nbsp;
			<span class="co1">// Bind the fragment shader to the program.</span>
			GLES20.<span class="me1">glAttachShader</span><span class="br0">&#40;</span>programHandle, fragmentShaderHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
			<span class="co1">// Bind attributes</span>
			GLES20.<span class="me1">glBindAttribLocation</span><span class="br0">&#40;</span>programHandle, <span class="nu0">0</span>, <span class="st0">&quot;a_Position&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
			GLES20.<span class="me1">glBindAttribLocation</span><span class="br0">&#40;</span>programHandle, <span class="nu0">1</span>, <span class="st0">&quot;a_Color&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
			<span class="co1">// Link the two shaders together into a program.</span>
			GLES20.<span class="me1">glLinkProgram</span><span class="br0">&#40;</span>programHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
			<span class="co1">// Get the link status.</span>
			<span class="kw1">final</span> <span class="kw4">int</span><span class="br0">&#91;</span><span class="br0">&#93;</span> linkStatus <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">int</span><span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy0">;</span>
			GLES20.<span class="me1">glGetProgramiv</span><span class="br0">&#40;</span>programHandle, GLES20.<span class="me1">GL_LINK_STATUS</span>, linkStatus, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
			<span class="co1">// If the link failed, delete the program.</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>linkStatus<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> 
			<span class="br0">&#123;</span>				
				GLES20.<span class="me1">glDeleteProgram</span><span class="br0">&#40;</span>programHandle<span class="br0">&#41;</span><span class="sy0">;</span>
				programHandle <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
&nbsp;
		<span class="kw1">if</span> <span class="br0">&#40;</span>programHandle <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
		<span class="br0">&#123;</span>
			<span class="kw1">throw</span> <span class="kw1">new</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+runtimeexception"><span class="kw3">RuntimeException</span></a><span class="br0">&#40;</span><span class="st0">&quot;Error creating program.&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="br0">&#125;</span>
&nbsp;
        <span class="co1">// Set program handles. These will later be used to pass in values to the program.</span>
        mMVPMatrixHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetUniformLocation</span><span class="br0">&#40;</span>programHandle, <span class="st0">&quot;u_MVPMatrix&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>        
        mPositionHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetAttribLocation</span><span class="br0">&#40;</span>programHandle, <span class="st0">&quot;a_Position&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        mColorHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetAttribLocation</span><span class="br0">&#40;</span>programHandle, <span class="st0">&quot;a_Color&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>        
&nbsp;
        <span class="co1">// Tell OpenGL to use this program when rendering.</span>
        GLES20.<span class="me1">glUseProgram</span><span class="br0">&#40;</span>programHandle<span class="br0">&#41;</span><span class="sy0">;</span>        
	<span class="br0">&#125;</span>	
&nbsp;
	@Override
	<span class="kw1">public</span> <span class="kw4">void</span> onSurfaceChanged<span class="br0">&#40;</span>GL10 glUnused, <span class="kw4">int</span> width, <span class="kw4">int</span> height<span class="br0">&#41;</span> 
	<span class="br0">&#123;</span>
		<span class="co1">// Set the OpenGL viewport to the same size as the surface.</span>
		GLES20.<span class="me1">glViewport</span><span class="br0">&#40;</span><span class="nu0">0</span>, <span class="nu0">0</span>, width, height<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Create a new perspective projection matrix. The height will stay the same</span>
		<span class="co1">// while the width will vary as per aspect ratio.</span>
		<span class="kw1">final</span> <span class="kw4">float</span> ratio <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">float</span><span class="br0">&#41;</span> width <span class="sy0">/</span> height<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> left <span class="sy0">=</span> <span class="sy0">-</span>ratio<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> right <span class="sy0">=</span> ratio<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> bottom <span class="sy0">=</span> <span class="sy0">-</span>1.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> top <span class="sy0">=</span> 1.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> near <span class="sy0">=</span> 1.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> far <span class="sy0">=</span> 10.0f<span class="sy0">;</span>
&nbsp;
		Matrix.<span class="me1">frustumM</span><span class="br0">&#40;</span>mProjectionMatrix, <span class="nu0">0</span>, left, right, bottom, top, near, far<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>	
&nbsp;
	@Override
	<span class="kw1">public</span> <span class="kw4">void</span> onDrawFrame<span class="br0">&#40;</span>GL10 glUnused<span class="br0">&#41;</span> 
	<span class="br0">&#123;</span>
		GLES20.<span class="me1">glClear</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_DEPTH_BUFFER_BIT</span> <span class="sy0">|</span> GLES20.<span class="me1">GL_COLOR_BUFFER_BIT</span><span class="br0">&#41;</span><span class="sy0">;</span>			        
&nbsp;
        <span class="co1">// Do a complete rotation every 10 seconds.</span>
        <span class="kw4">long</span> time <span class="sy0">=</span> SystemClock.<span class="me1">uptimeMillis</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">%</span> 10000L<span class="sy0">;</span>
        <span class="kw4">float</span> angleInDegrees <span class="sy0">=</span> <span class="br0">&#40;</span>360.0f <span class="sy0">/</span> 10000.0f<span class="br0">&#41;</span> <span class="sy0">*</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> time<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Draw the triangle facing straight on.</span>
        Matrix.<span class="me1">setIdentityM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">rotateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, angleInDegrees, 0.0f, 0.0f, 1.0f<span class="br0">&#41;</span><span class="sy0">;</span>        
        drawTriangle<span class="br0">&#40;</span>mTriangle1Vertices<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Draw one translated a bit down and rotated to be flat on the ground.</span>
        Matrix.<span class="me1">setIdentityM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">translateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, 0.0f, <span class="sy0">-</span>1.0f, 0.0f<span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">rotateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, 90.0f, 1.0f, 0.0f, 0.0f<span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">rotateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, angleInDegrees, 0.0f, 0.0f, 1.0f<span class="br0">&#41;</span><span class="sy0">;</span>        
        drawTriangle<span class="br0">&#40;</span>mTriangle2Vertices<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Draw one translated a bit to the right and rotated to be facing to the left.</span>
        Matrix.<span class="me1">setIdentityM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">translateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, 1.0f, 0.0f, 0.0f<span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">rotateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, 90.0f, 0.0f, 1.0f, 0.0f<span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">rotateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, angleInDegrees, 0.0f, 0.0f, 1.0f<span class="br0">&#41;</span><span class="sy0">;</span>
        drawTriangle<span class="br0">&#40;</span>mTriangle3Vertices<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>	
&nbsp;
	<span class="co3">/**
	 * Draws a triangle from the given vertex data.
	 * 
	 * @param aTriangleBuffer The buffer containing the vertex data.
	 */</span>
	<span class="kw1">private</span> <span class="kw4">void</span> drawTriangle<span class="br0">&#40;</span><span class="kw1">final</span> FloatBuffer aTriangleBuffer<span class="br0">&#41;</span>
	<span class="br0">&#123;</span>		
		<span class="co1">// Pass in the position information</span>
		aTriangleBuffer.<span class="me1">position</span><span class="br0">&#40;</span>mPositionOffset<span class="br0">&#41;</span><span class="sy0">;</span>
        GLES20.<span class="me1">glVertexAttribPointer</span><span class="br0">&#40;</span>mPositionHandle, mPositionDataSize, GLES20.<span class="me1">GL_FLOAT</span>, <span class="kw2">false</span>,
        		mStrideBytes, aTriangleBuffer<span class="br0">&#41;</span><span class="sy0">;</span>        
&nbsp;
        GLES20.<span class="me1">glEnableVertexAttribArray</span><span class="br0">&#40;</span>mPositionHandle<span class="br0">&#41;</span><span class="sy0">;</span>        
&nbsp;
        <span class="co1">// Pass in the color information</span>
        aTriangleBuffer.<span class="me1">position</span><span class="br0">&#40;</span>mColorOffset<span class="br0">&#41;</span><span class="sy0">;</span>
        GLES20.<span class="me1">glVertexAttribPointer</span><span class="br0">&#40;</span>mColorHandle, mColorDataSize, GLES20.<span class="me1">GL_FLOAT</span>, <span class="kw2">false</span>,
        		mStrideBytes, aTriangleBuffer<span class="br0">&#41;</span><span class="sy0">;</span>        
&nbsp;
        GLES20.<span class="me1">glEnableVertexAttribArray</span><span class="br0">&#40;</span>mColorHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// This multiplies the view matrix by the model matrix, and stores the result in the MVP matrix</span>
        <span class="co1">// (which currently contains model * view).</span>
        Matrix.<span class="me1">multiplyMM</span><span class="br0">&#40;</span>mMVPMatrix, <span class="nu0">0</span>, mViewMatrix, <span class="nu0">0</span>, mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// This multiplies the modelview matrix by the projection matrix, and stores the result in the MVP matrix</span>
        <span class="co1">// (which now contains model * view * projection).</span>
        Matrix.<span class="me1">multiplyMM</span><span class="br0">&#40;</span>mMVPMatrix, <span class="nu0">0</span>, mProjectionMatrix, <span class="nu0">0</span>, mMVPMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        GLES20.<span class="me1">glUniformMatrix4fv</span><span class="br0">&#40;</span>mMVPMatrixHandle, <span class="nu0">1</span>, <span class="kw2">false</span>, mMVPMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        GLES20.<span class="me1">glDrawArrays</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_TRIANGLES</span>, <span class="nu0">0</span>, <span class="nu0">3</span><span class="br0">&#41;</span><span class="sy0">;</span>                               
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>

<p>
3.解析：
</p>

<p>
(1)定义顶点和颜色，并把顶点和颜色同时存放在一个数组当中，初始化buffer
</p>
<pre class="code java"><span class="co1">// New class members</span>
<span class="co3">/** Store our model data in a float buffer. */</span>
<span class="kw1">private</span> <span class="kw1">final</span> FloatBuffer mTriangle1Vertices<span class="sy0">;</span>
<span class="kw1">private</span> <span class="kw1">final</span> FloatBuffer mTriangle2Vertices<span class="sy0">;</span>
<span class="kw1">private</span> <span class="kw1">final</span> FloatBuffer mTriangle3Vertices<span class="sy0">;</span>
&nbsp;
<span class="co3">/** How many bytes per float. */</span>
<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mBytesPerFloat <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">;</span>
&nbsp;
<span class="co3">/**
 * Initialize the model data.
 */</span>
<span class="kw1">public</span> LessonOneRenderer<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// This triangle is red, green, and blue.</span>
    <span class="kw1">final</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> triangle1VerticesData <span class="sy0">=</span> <span class="br0">&#123;</span>
            <span class="co1">// X, Y, Z,</span>
            <span class="co1">// R, G, B, A</span>
            <span class="sy0">-</span>0.5f, <span class="sy0">-</span>0.25f, 0.0f,
            1.0f, 0.0f, 0.0f, 1.0f,
&nbsp;
            0.5f, <span class="sy0">-</span>0.25f, 0.0f,
            0.0f, 0.0f, 1.0f, 1.0f,
&nbsp;
            0.0f, 0.559016994f, 0.0f,
            0.0f, 1.0f, 0.0f, 1.0f<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
    ...
&nbsp;
    <span class="co1">// Initialize the buffers.</span>
    mTriangle1Vertices <span class="sy0">=</span> ByteBuffer.<span class="me1">allocateDirect</span><span class="br0">&#40;</span>triangle1VerticesData.<span class="me1">length</span> <span class="sy0">*</span> mBytesPerFloat<span class="br0">&#41;</span>
    .<span class="me1">order</span><span class="br0">&#40;</span>ByteOrder.<span class="me1">nativeOrder</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>.<span class="me1">asFloatBuffer</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    ...
&nbsp;
    <span class="me1">mTriangle1Vertices</span>.<span class="me1">put</span><span class="br0">&#40;</span>triangle1VerticesData<span class="br0">&#41;</span>.<span class="me1">position</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    ...
<span class="br0">&#125;</span></pre>

<p>
(2)定义顶点着色器和片元着色器，每个着色器由三部分组成，input, output, program,任何需要显示到屏幕上的东西，首先都需要通过顶点着色器和片元着色器。
</p>
<pre class="code java"><span class="co1">//顶点着色器</span>
<span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> vertexShader <span class="sy0">=</span>
    <span class="st0">&quot;uniform mat4 u_MVPMatrix;      <span class="es0">\n</span>&quot;</span>     <span class="co1">// A constant representing the combined model/view/projection matrix.</span>
&nbsp;
  <span class="sy0">+</span> <span class="st0">&quot;attribute vec4 a_Position;     <span class="es0">\n</span>&quot;</span>     <span class="co1">// Per-vertex position information we will pass in.</span>
  <span class="sy0">+</span> <span class="st0">&quot;attribute vec4 a_Color;        <span class="es0">\n</span>&quot;</span>     <span class="co1">// Per-vertex color information we will pass in.</span>
&nbsp;
  <span class="sy0">+</span> <span class="st0">&quot;varying vec4 v_Color;          <span class="es0">\n</span>&quot;</span>     <span class="co1">// This will be passed into the fragment shader.</span>
&nbsp;
  <span class="sy0">+</span> <span class="st0">&quot;void main()                    <span class="es0">\n</span>&quot;</span>     <span class="co1">// The entry point for our vertex shader.</span>
  <span class="sy0">+</span> <span class="st0">&quot;{                              <span class="es0">\n</span>&quot;</span>
  <span class="sy0">+</span> <span class="st0">&quot;   v_Color = a_Color;          <span class="es0">\n</span>&quot;</span>     <span class="co1">// Pass the color through to the fragment shader.</span>
                                            <span class="co1">// It will be interpolated across the triangle.</span>
  <span class="sy0">+</span> <span class="st0">&quot;   gl_Position = u_MVPMatrix   <span class="es0">\n</span>&quot;</span>     <span class="co1">// gl_Position is a special variable used to store the final position.</span>
  <span class="sy0">+</span> <span class="st0">&quot;               * a_Position;   <span class="es0">\n</span>&quot;</span>     <span class="co1">// Multiply the vertex by the matrix to get the final point in</span>
  <span class="sy0">+</span> <span class="st0">&quot;}                              <span class="es0">\n</span>&quot;</span><span class="sy0">;</span>    <span class="co1">// normalized screen coordinates.</span></pre>
<pre class="code java"><span class="co1">//片元着色器</span>
<span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> fragmentShader <span class="sy0">=</span>
    <span class="st0">&quot;precision mediump float;       <span class="es0">\n</span>&quot;</span>     <span class="co1">// Set the default precision to medium. We don't need as high of a</span>
                                            <span class="co1">// precision in the fragment shader.</span>
  <span class="sy0">+</span> <span class="st0">&quot;varying vec4 v_Color;          <span class="es0">\n</span>&quot;</span>     <span class="co1">// This is the color from the vertex shader interpolated across the</span>
                                            <span class="co1">// triangle per fragment.</span>
  <span class="sy0">+</span> <span class="st0">&quot;void main()                    <span class="es0">\n</span>&quot;</span>     <span class="co1">// The entry point for our fragment shader.</span>
  <span class="sy0">+</span> <span class="st0">&quot;{                              <span class="es0">\n</span>&quot;</span>
  <span class="sy0">+</span> <span class="st0">&quot;   gl_FragColor = v_Color;     <span class="es0">\n</span>&quot;</span>     <span class="co1">// Pass the color directly through the pipeline.</span>
  <span class="sy0">+</span> <span class="st0">&quot;}                              <span class="es0">\n</span>&quot;</span><span class="sy0">;</span></pre>

<p>
（3）加载着色器到OpenGL中
</p>
<pre class="code java"><span class="co1">// Load in the vertex shader.</span>
<span class="kw4">int</span> vertexShaderHandle <span class="sy0">=</span> GLES20.<span class="me1">glCreateShader</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_VERTEX_SHADER</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">if</span> <span class="br0">&#40;</span>vertexShaderHandle <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// Pass in the shader source.</span>
    GLES20.<span class="me1">glShaderSource</span><span class="br0">&#40;</span>vertexShaderHandle, vertexShader<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Compile the shader.</span>
    GLES20.<span class="me1">glCompileShader</span><span class="br0">&#40;</span>vertexShaderHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Get the compilation status.</span>
    <span class="kw1">final</span> <span class="kw4">int</span><span class="br0">&#91;</span><span class="br0">&#93;</span> compileStatus <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">int</span><span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy0">;</span>
    GLES20.<span class="me1">glGetShaderiv</span><span class="br0">&#40;</span>vertexShaderHandle, GLES20.<span class="me1">GL_COMPILE_STATUS</span>, compileStatus, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// If the compilation failed, delete the shader.</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>compileStatus<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        GLES20.<span class="me1">glDeleteShader</span><span class="br0">&#40;</span>vertexShaderHandle<span class="br0">&#41;</span><span class="sy0">;</span>
        vertexShaderHandle <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw1">if</span> <span class="br0">&#40;</span>vertexShaderHandle <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw1">throw</span> <span class="kw1">new</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+runtimeexception"><span class="kw3">RuntimeException</span></a><span class="br0">&#40;</span><span class="st0">&quot;Error creating vertex shader.&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
(4)把顶点着色器和片元着色器链接到porgram当中
</p>
<pre class="code java"><span class="co1">// Create a program object and store the handle to it.</span>
<span class="kw4">int</span> programHandle <span class="sy0">=</span> GLES20.<span class="me1">glCreateProgram</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">if</span> <span class="br0">&#40;</span>programHandle <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// Bind the vertex shader to the program.</span>
    GLES20.<span class="me1">glAttachShader</span><span class="br0">&#40;</span>programHandle, vertexShaderHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Bind the fragment shader to the program.</span>
    GLES20.<span class="me1">glAttachShader</span><span class="br0">&#40;</span>programHandle, fragmentShaderHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Bind attributes</span>
    GLES20.<span class="me1">glBindAttribLocation</span><span class="br0">&#40;</span>programHandle, <span class="nu0">0</span>, <span class="st0">&quot;a_Position&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    GLES20.<span class="me1">glBindAttribLocation</span><span class="br0">&#40;</span>programHandle, <span class="nu0">1</span>, <span class="st0">&quot;a_Color&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Link the two shaders together into a program.</span>
    GLES20.<span class="me1">glLinkProgram</span><span class="br0">&#40;</span>programHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Get the link status.</span>
    <span class="kw1">final</span> <span class="kw4">int</span><span class="br0">&#91;</span><span class="br0">&#93;</span> linkStatus <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">int</span><span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy0">;</span>
    GLES20.<span class="me1">glGetProgramiv</span><span class="br0">&#40;</span>programHandle, GLES20.<span class="me1">GL_LINK_STATUS</span>, linkStatus, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// If the link failed, delete the program.</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>linkStatus<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        GLES20.<span class="me1">glDeleteProgram</span><span class="br0">&#40;</span>programHandle<span class="br0">&#41;</span><span class="sy0">;</span>
        programHandle <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw1">if</span> <span class="br0">&#40;</span>programHandle <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw1">throw</span> <span class="kw1">new</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+runtimeexception"><span class="kw3">RuntimeException</span></a><span class="br0">&#40;</span><span class="st0">&quot;Error creating program.&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
(5)获取顶点着色器或者片元着色器的属性的引用，然后通过它们传递数据到program当中，最后通知Opengl使用我们自定义的program来绘制图形
</p>
<pre class="code java"><span class="co1">//New class members</span>
<span class="co3">/** This will be used to pass in the transformation matrix. */</span>
<span class="kw1">private</span> <span class="kw4">int</span> mMVPMatrixHandle<span class="sy0">;</span>
&nbsp;
<span class="co3">/** This will be used to pass in model position information. */</span>
<span class="kw1">private</span> <span class="kw4">int</span> mPositionHandle<span class="sy0">;</span>
&nbsp;
<span class="co3">/** This will be used to pass in model color information. */</span>
<span class="kw1">private</span> <span class="kw4">int</span> mColorHandle<span class="sy0">;</span>
&nbsp;
@Override
<span class="kw1">public</span> <span class="kw4">void</span> onSurfaceCreated<span class="br0">&#40;</span>GL10 glUnused, EGLConfig config<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    ...
&nbsp;
    <span class="co1">// Set program handles. These will later be used to pass in values to the program.</span>
    mMVPMatrixHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetUniformLocation</span><span class="br0">&#40;</span>programHandle, <span class="st0">&quot;u_MVPMatrix&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    mPositionHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetAttribLocation</span><span class="br0">&#40;</span>programHandle, <span class="st0">&quot;a_Position&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    mColorHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetAttribLocation</span><span class="br0">&#40;</span>programHandle, <span class="st0">&quot;a_Color&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Tell OpenGL to use this program when rendering.</span>
    GLES20.<span class="me1">glUseProgram</span><span class="br0">&#40;</span>programHandle<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
(6)设置view matrix
</p>
<pre class="code java"><span class="co1">// New class definitions</span>
 <span class="co3">/**
 * Store the view matrix. This can be thought of as our camera. This matrix transforms world space to eye space;
 * it positions things relative to our eye.
 */</span>
<span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mViewMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
@Override
<span class="kw1">public</span> <span class="kw4">void</span> onSurfaceCreated<span class="br0">&#40;</span>GL10 glUnused, EGLConfig config<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// Set the background clear color to gray.</span>
    GLES20.<span class="me1">glClearColor</span><span class="br0">&#40;</span>0.5f, 0.5f, 0.5f, 0.5f<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Position the eye behind the origin.</span>
    <span class="kw1">final</span> <span class="kw4">float</span> eyeX <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
    <span class="kw1">final</span> <span class="kw4">float</span> eyeY <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
    <span class="kw1">final</span> <span class="kw4">float</span> eyeZ <span class="sy0">=</span> 1.5f<span class="sy0">;</span>
&nbsp;
    <span class="co1">// We are looking toward the distance</span>
    <span class="kw1">final</span> <span class="kw4">float</span> lookX <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
    <span class="kw1">final</span> <span class="kw4">float</span> lookY <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
    <span class="kw1">final</span> <span class="kw4">float</span> lookZ <span class="sy0">=</span> <span class="sy0">-</span>5.0f<span class="sy0">;</span>
&nbsp;
    <span class="co1">// Set our up vector. This is where our head would be pointing were we holding the camera.</span>
    <span class="kw1">final</span> <span class="kw4">float</span> upX <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
    <span class="kw1">final</span> <span class="kw4">float</span> upY <span class="sy0">=</span> 1.0f<span class="sy0">;</span>
    <span class="kw1">final</span> <span class="kw4">float</span> upZ <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
&nbsp;
    <span class="co1">// Set the view matrix. This matrix can be said to represent the camera position.</span>
    <span class="co1">// NOTE: In OpenGL 1, a ModelView matrix is used, which is a combination of a model and</span>
    <span class="co1">// view matrix. In OpenGL 2, we can keep track of these matrices separately if we choose.</span>
    Matrix.<span class="me1">setLookAtM</span><span class="br0">&#40;</span>mViewMatrix, <span class="nu0">0</span>, eyeX, eyeY, eyeZ, lookX, lookY, lookZ, upX, upY, upZ<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    ...
｝</pre>

<p>
(7)设置projection matrix
</p>
<pre class="code java"><span class="co1">// New class members</span>
<span class="co3">/** Store the projection matrix. This is used to project the scene onto a 2D viewport. */</span>
<span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mProjectionMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
@Override
<span class="kw1">public</span> <span class="kw4">void</span> onSurfaceChanged<span class="br0">&#40;</span>GL10 glUnused, <span class="kw4">int</span> width, <span class="kw4">int</span> height<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// Set the OpenGL viewport to the same size as the surface.</span>
    GLES20.<span class="me1">glViewport</span><span class="br0">&#40;</span><span class="nu0">0</span>, <span class="nu0">0</span>, width, height<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Create a new perspective projection matrix. The height will stay the same</span>
    <span class="co1">// while the width will vary as per aspect ratio.</span>
    <span class="kw1">final</span> <span class="kw4">float</span> ratio <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">float</span><span class="br0">&#41;</span> width <span class="sy0">/</span> height<span class="sy0">;</span>
    <span class="kw1">final</span> <span class="kw4">float</span> left <span class="sy0">=</span> <span class="sy0">-</span>ratio<span class="sy0">;</span>
    <span class="kw1">final</span> <span class="kw4">float</span> right <span class="sy0">=</span> ratio<span class="sy0">;</span>
    <span class="kw1">final</span> <span class="kw4">float</span> bottom <span class="sy0">=</span> <span class="sy0">-</span>1.0f<span class="sy0">;</span>
    <span class="kw1">final</span> <span class="kw4">float</span> top <span class="sy0">=</span> 1.0f<span class="sy0">;</span>
    <span class="kw1">final</span> <span class="kw4">float</span> near <span class="sy0">=</span> 1.0f<span class="sy0">;</span>
    <span class="kw1">final</span> <span class="kw4">float</span> far <span class="sy0">=</span> 10.0f<span class="sy0">;</span>
&nbsp;
    Matrix.<span class="me1">frustumM</span><span class="br0">&#40;</span>mProjectionMatrix, <span class="nu0">0</span>, left, right, bottom, top, near, far<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
(8)绘制图形到屏幕上
</p>
<pre class="code java">    <span class="co1">// New class members</span>
    <span class="co3">/**
     * Store the model matrix. This matrix is used to move models from object space (where each model can be thought
     * of being located at the center of the universe) to world space.
     */</span>
    <span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mModelMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
    @Override
    <span class="kw1">public</span> <span class="kw4">void</span> onDrawFrame<span class="br0">&#40;</span>GL10 glUnused<span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        GLES20.<span class="me1">glClear</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_DEPTH_BUFFER_BIT</span> <span class="sy0">|</span> GLES20.<span class="me1">GL_COLOR_BUFFER_BIT</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Do a complete rotation every 10 seconds.</span>
        <span class="kw4">long</span> time <span class="sy0">=</span> SystemClock.<span class="me1">uptimeMillis</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">%</span> 10000L<span class="sy0">;</span>
        <span class="kw4">float</span> angleInDegrees <span class="sy0">=</span> <span class="br0">&#40;</span>360.0f <span class="sy0">/</span> 10000.0f<span class="br0">&#41;</span> <span class="sy0">*</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> time<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Draw the triangle facing straight on.</span>
        Matrix.<span class="me1">setIdentityM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">rotateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, angleInDegrees, 0.0f, 0.0f, 1.0f<span class="br0">&#41;</span><span class="sy0">;</span>
        drawTriangle<span class="br0">&#40;</span>mTriangle1Vertices<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        ...
<span class="br0">&#125;</span></pre>

<p>
实际绘制三角形的函数：
</p>
<pre class="code java"><span class="co1">// New class members</span>
<span class="co3">/** Allocate storage for the final combined matrix. This will be passed into the shader program. */</span>
<span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mMVPMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
<span class="co3">/** How many elements per vertex. */</span>
<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mStrideBytes <span class="sy0">=</span> <span class="nu0">7</span> <span class="sy0">*</span> mBytesPerFloat<span class="sy0">;</span>
&nbsp;
<span class="co3">/** Offset of the position data. */</span>
<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mPositionOffset <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
<span class="co3">/** Size of the position data in elements. */</span>
<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mPositionDataSize <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
&nbsp;
<span class="co3">/** Offset of the color data. */</span>
<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mColorOffset <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
&nbsp;
<span class="co3">/** Size of the color data in elements. */</span>
<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mColorDataSize <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">;</span>
&nbsp;
<span class="co3">/**
 * Draws a triangle from the given vertex data.
 *
 * @param aTriangleBuffer The buffer containing the vertex data.
 */</span>
<span class="kw1">private</span> <span class="kw4">void</span> drawTriangle<span class="br0">&#40;</span><span class="kw1">final</span> FloatBuffer aTriangleBuffer<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// Pass in the position information</span>
    aTriangleBuffer.<span class="me1">position</span><span class="br0">&#40;</span>mPositionOffset<span class="br0">&#41;</span><span class="sy0">;</span>
    GLES20.<span class="me1">glVertexAttribPointer</span><span class="br0">&#40;</span>mPositionHandle, mPositionDataSize, GLES20.<span class="me1">GL_FLOAT</span>, <span class="kw2">false</span>,
            mStrideBytes, aTriangleBuffer<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    GLES20.<span class="me1">glEnableVertexAttribArray</span><span class="br0">&#40;</span>mPositionHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Pass in the color information</span>
    aTriangleBuffer.<span class="me1">position</span><span class="br0">&#40;</span>mColorOffset<span class="br0">&#41;</span><span class="sy0">;</span>
    GLES20.<span class="me1">glVertexAttribPointer</span><span class="br0">&#40;</span>mColorHandle, mColorDataSize, GLES20.<span class="me1">GL_FLOAT</span>, <span class="kw2">false</span>,
            mStrideBytes, aTriangleBuffer<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    GLES20.<span class="me1">glEnableVertexAttribArray</span><span class="br0">&#40;</span>mColorHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// This multiplies the view matrix by the model matrix, and stores the result in the MVP matrix</span>
    <span class="co1">// (which currently contains model * view).</span>
    Matrix.<span class="me1">multiplyMM</span><span class="br0">&#40;</span>mMVPMatrix, <span class="nu0">0</span>, mViewMatrix, <span class="nu0">0</span>, mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// This multiplies the modelview matrix by the projection matrix, and stores the result in the MVP matrix</span>
    <span class="co1">// (which now contains model * view * projection).</span>
    Matrix.<span class="me1">multiplyMM</span><span class="br0">&#40;</span>mMVPMatrix, <span class="nu0">0</span>, mProjectionMatrix, <span class="nu0">0</span>, mMVPMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    GLES20.<span class="me1">glUniformMatrix4fv</span><span class="br0">&#40;</span>mMVPMatrixHandle, <span class="nu0">1</span>, <span class="kw2">false</span>, mMVPMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
    GLES20.<span class="me1">glDrawArrays</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_TRIANGLES</span>, <span class="nu0">0</span>, <span class="nu0">3</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
在编写opengl es2代码时，需要在AndroidManifest.xml文件中添加如下语句：
</p>
<pre class="code java"><span class="sy0">&lt;</span>uses<span class="sy0">-</span>feature
android<span class="sy0">:</span>glEsVersion<span class="sy0">=</span><span class="st0">&quot;0x00020000&quot;</span>
android<span class="sy0">:</span>required<span class="sy0">=</span><span class="st0">&quot;true&quot;</span> <span class="sy0">/&gt;</span></pre>
