a:430:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:0;}i:2;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:"NFC(近场通信)";}i:2;i:1;}i:3;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18;}i:4;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18;}i:5;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:374:"NFC是一套短距离的无线通信，通常距离是4厘米或更短。NFC工作频率是13.56M Hz,传输速率是106kbit/s 到848kbit/s. NFC总是在一个发起者和一个被动目标之间发生。发起者发出近场无线电波，这个近场可以给被动目标供电。这些被动的目标包括不需要电源的标签，卡，也可以是有电源的设备。";}i:2;i:20;}i:6;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:394;}i:7;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:394;}i:8;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:216:"与其他无线通信技术比较， 例如蓝牙和WiFi， NFC提供更低带宽和距离，并且低成本，不需要供电，不需要实现匹配，整个通信过程仅仅是短短的靠近一秒就能完成。";}i:2;i:396;}i:9;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:612;}i:10;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:612;}i:11;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:197:"一个带有NFC支持的android设备通常是一个发起者。也可以作为NFC的读写设备。他将检测NFC tags并且打开一个Activity来处理. Android 2.3.3还有支持有限的P2P。";}i:2;i:614;}i:12;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:811;}i:13;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:811;}i:14;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:262:"Tags分很多种，其中简单的只提供读写段，有的只能读。复杂的tags可以支持一些运算，加密来控制对tags里数据段的读写。甚至一些tags上有简单的操作系统，允许一些复杂的交互和可以执行一些代码。";}i:2;i:813;}i:15;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1075;}i:16;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1075;}i:17;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:"API概览";}i:2;i:1077;}i:18;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1086;}i:19;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1086;}i:20;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:134:"Android.nfc package包含顶层类用来与本地NFC适配器交互. 这些类可以表示被检测到的tags和用NDEF数据格式。";}i:2;i:1088;}i:21;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1222;}i:22;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1222;}i:23;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:"Class";}i:2;i:1224;}i:24;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1229;}i:25;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1229;}i:26;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:"Description";}i:2;i:1231;}i:27;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1242;}i:28;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1242;}i:29;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:"NfcManager";}i:2;i:1244;}i:30;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1254;}i:31;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1254;}i:32;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:244:"一个NFC adapter的管理器，可以列出所有此android设备支持的NFC adapter.只不过大部分android 设备只有一个NFC adapter，所以你大部分情况下可以直接用静态方法 getDefaultAdapter(context)来取适配器。";}i:2;i:1256;}i:33;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1500;}i:34;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1500;}i:35;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:"NfcAdapter";}i:2;i:1502;}i:36;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1512;}i:37;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1512;}i:38;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:255:"表示本设备的NFC adapter,可以定义Intent来请求将系统检测到tags的提醒发送到你的Activity.并提供方法去注册前台tag提醒发布和前台NDEF推送。 前台NDEF推送是当前android版本唯一支持的p2p NFC通信方式。";}i:2;i:1514;}i:39;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1769;}i:40;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1769;}i:41;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:"NdefMessage and NdefRecord";}i:2;i:1771;}i:42;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1797;}i:43;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1797;}i:44;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:457:"NDEF是NFC论坛定义的数据结构，用来有效的存数据到NFC tags.比如文本，URL，和其他MIME类型。一个NdefMessage扮演一个容器，这个容器存哪些发送和读到的数据。一个NdefMessage对象包含0或多个NdefRecord,每个NDEF record有一个类型，比如文本，URL，智慧型海报/广告，或其他MIME数据。在NDEFMessage里的第一个NfcRecord的类型用来发送tag到一个android设备上的activity.";}i:2;i:1799;}i:45;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2256;}i:46;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2256;}i:47;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"Tag";}i:2;i:2258;}i:48;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2261;}i:49;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2261;}i:50;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:107:"标示一个被动的NFC目标，比如tag，card，钥匙挂扣，甚至是一个电话模拟的的NFC卡.";}i:2;i:2263;}i:51;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2370;}i:52;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2370;}i:53;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:334:"当一个tag被检测到，一个tag对象将被创建并且封装到一个Intent里，然后NFC 发布系统将这个Intent用startActivity发送到注册了接受这种Intent的activity里。你可以用getTechList()方法来得到这个tag支持的技术细节和创建一个android.nfc.tech提供的相应的TagTechnology对象。";}i:2;i:2372;}i:54;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2706;}i:55;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2706;}i:56;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:148:"android.nfc.tech package 包含那些对tag查询属性和进行I/O操作的类。这些类分别标示一个tag支持的不同的NFC技术标准。";}i:2;i:2708;}i:57;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2856;}i:58;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2856;}i:59;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:"Class";}i:2;i:2858;}i:60;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2863;}i:61;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2863;}i:62;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:"Description";}i:2;i:2865;}i:63;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2876;}i:64;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2876;}i:65;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:"TagTechnology";}i:2;i:2878;}i:66;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2891;}i:67;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2891;}i:68;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:62:"这个接口是下面所有tag technology类必须实现的。";}i:2;i:2893;}i:69;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2955;}i:70;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2955;}i:71;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"NfcA";}i:2;i:2957;}i:72;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2961;}i:73;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2961;}i:74;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:107:"支持ISO 14443-3A 标准的操作。Provides access to NFC-A (ISO 14443-3A) properties and I/O operations.";}i:2;i:2963;}i:75;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3070;}i:76;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3070;}i:77;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:75:"NfcB Provides access to NFC-B (ISO 14443-3B) properties and I/O operations.";}i:2;i:3072;}i:78;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3147;}i:79;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3147;}i:80;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:73:"NfcF Provides access to NFC-F (JIS 6319-4) properties and I/O operations.";}i:2;i:3149;}i:81;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3222;}i:82;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3222;}i:83;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:72:"NfcV Provides access to NFC-V (ISO 15693) properties and I/O operations.";}i:2;i:3224;}i:84;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3296;}i:85;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3296;}i:86;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:78:"IsoDep Provides access to ISO-DEP (ISO 14443-4) properties and I/O operations.";}i:2;i:3298;}i:87;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3376;}i:88;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3376;}i:89;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:81:"Ndef 提供对那些被格式化为NDEF的tag的数据的访问和其他操作。";}i:2;i:3378;}i:90;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3459;}i:91;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3459;}i:92;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:89:"Provides access to NDEF data and operations on NFC tags that have been formatted as NDEF.";}i:2;i:3461;}i:93;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3550;}i:94;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3550;}i:95;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:14:"NdefFormatable";}i:2;i:3552;}i:96;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3566;}i:97;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3566;}i:98;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:76:"对那些可以被格式化成NDEF格式的tag提供一个格式化的操作";}i:2;i:3568;}i:99;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3644;}i:100;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3644;}i:101;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:"MifareClassic";}i:2;i:3646;}i:102;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3659;}i:103;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3659;}i:104;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:87:"如果android设备支持MIFARE，提供对MIFARE Classic目标的属性和I/O操作。";}i:2;i:3661;}i:105;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3748;}i:106;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3748;}i:107;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"MifareUltralight";}i:2;i:3750;}i:108;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3766;}i:109;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3766;}i:110;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:90:"如果android设备支持MIFARE，提供对MIFARE Ultralight目标的属性和I/O操作。";}i:2;i:3768;}i:111;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3858;}i:112;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3858;}i:113;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:35:"声明Android Manifest.xml的元素";}i:2;i:3860;}i:114;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3895;}i:115;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3895;}i:116;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:133:"在你能访问一个设备的NFC硬件和正确的处理NFC的Intent之前，需要在AndroidManifest.xml中先声明下面的项：";}i:2;i:3897;}i:117;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4030;}i:118;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4030;}i:119;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:56:"1. NFC使用 <uses-permission> 元素来访问NFC硬件:";}i:2;i:4032;}i:120;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4088;}i:121;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4088;}i:122;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:61:"<uses-permission android:name=“android.permission.NFC” />";}i:2;i:4090;}i:123;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4151;}i:124;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4151;}i:125;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:87:"2. 最小SDK版本需要设置正确，API level 9只包含有限的tag支持,包括：";}i:2;i:4153;}i:126;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4241;}i:127;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:148:".通过ACTION_TAG_DISCOVERED来发布Tag信息
.只有通过EXTRA_NDEF_MESSAGES扩展来访问NDEF消息
.其他的tag属性和I/O操作都不支持";}i:2;i:4241;}i:128;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4241;}i:129;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:78:"所以你可能想要用API level 10来实现对tag的广泛的读写支持。";}i:2;i:4397;}i:130;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4475;}i:131;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4475;}i:132;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:42:"<uses-sdk android:minSdkVersion=“10”/>";}i:2;i:4477;}i:133;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4519;}i:134;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4519;}i:135;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:89:"3. uses-feature 元素定义：你的程序可以再android市场里显示有NFC硬件。";}i:2;i:4521;}i:136;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4610;}i:137;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4610;}i:138;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:84:"<uses-feature android:name=“android.hardware.nfc” android:required=“true” />";}i:2;i:4612;}i:139;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4696;}i:140;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4696;}i:141;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:113:"4. NFC intent filter告诉android系统你的activity能处理NFC数据，可以定义1个或多个intent filter:";}i:2;i:4698;}i:142;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4811;}i:143;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4811;}i:144;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"<intent-filter>";}i:2;i:4813;}i:145;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4828;}i:146;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4828;}i:147;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:"<action android:name=";}i:2;i:4830;}i:148;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:4851;}i:149;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:34:"android.nfc.action.NDEF_DISCOVERED";}i:2;i:4852;}i:150;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:4886;}i:151;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:"/>
<data android:mimeType=";}i:2;i:4887;}i:152;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:4913;}i:153;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:"mime/type";}i:2;i:4914;}i:154;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:4923;}i:155;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:" />
</intent-filter>";}i:2;i:4924;}i:156;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4944;}i:157;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4944;}i:158;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"<intent-filter>";}i:2;i:4946;}i:159;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4961;}i:160;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4961;}i:161;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:"<action android:name=";}i:2;i:4963;}i:162;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:4984;}i:163;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:34:"android.nfc.action.TECH_DISCOVERED";}i:2;i:4985;}i:164;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:5019;}i:165;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:27:"/>
<meta-data android:name=";}i:2;i:5020;}i:166;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:5047;}i:167;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:34:"android.nfc.action.TECH_DISCOVERED";}i:2;i:5048;}i:168;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:5082;}i:169;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5083;}i:170;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:58:"            android:resource="@xml/nfc_tech_filter.xml" />";}i:2;i:5083;}i:171;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5083;}i:172;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"</intent-filter>";}i:2;i:5145;}i:173;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5161;}i:174;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5161;}i:175;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"<intent-filter>";}i:2;i:5163;}i:176;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5178;}i:177;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5178;}i:178;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:"<action android:name=";}i:2;i:5180;}i:179;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:5201;}i:180;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:33:"android.nfc.action.TAG_DISCOVERED";}i:2;i:5202;}i:181;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:5235;}i:182;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:"/>
</intent-filter>";}i:2;i:5236;}i:183;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5255;}i:184;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5255;}i:185;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:85:"上边3个intent filters 有优先级，更多信息可以看下面的Tag发布系统";}i:2;i:5257;}i:186;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5342;}i:187;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5342;}i:188;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:75:"也可以看NFCDemo例子的 AndroidManifest.xml来有个更深的理解。";}i:2;i:5344;}i:189;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5419;}i:190;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5419;}i:191;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"Tag发布系统";}i:2;i:5421;}i:192;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5436;}i:193;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5436;}i:194;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:611:"当android设备扫描到一个NFC tag，通用的行为是自动找最合适的Activity会处理这个tag Intent而不需要用户来选择哪个Activity来处理。因为设备扫描NFC tags是在很短的范围和时间，如果让用户选择的话，那就有可能需要移动设备，这样将会打断这个扫描过程。你应该开发你只处理需要处理的tags的Activity，以防止让用户选择使用哪个Activity来处理的情况。Android提供两个系统来帮助你正确的识别一个NFC tag是否是你的Activity想要处理的：Intent发布系统和前台Activity发布系统。";}i:2;i:5438;}i:195;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6049;}i:196;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6049;}i:197;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:315:"Intent发布系统检查所有Activities的intent filters，找出那些定义了可以处理此tag的Activity，如果有多个Activity都配置了处理同一个tag Intent，那么将使用Activity选择器来让用户选择使用哪个Activity。用户选择之后，将使用选择的Activity来处理此Intent.";}i:2;i:6051;}i:198;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6366;}i:199;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6366;}i:200;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:356:"前台发布系统允许一个Activity覆盖掉Intent发布系统而首先处理此tag Intent，这要求你将要处理Tag Intent的Activity运行在前台，这样当一个NFC tag被扫描到，系统先检测前台的Activity是否支持处理此Intent，如果支持，即将此Intent传给此Activity，如果不支持，则转到Intent发布系统。";}i:2;i:6368;}i:201;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6724;}i:202;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6724;}i:203;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:"使用Intent发布系统";}i:2;i:6726;}i:204;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6750;}i:205;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6750;}i:206;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:166:"Intent发布系统指定了3个intent有不同的优先级。通常当一个tag被检测到之后，Intent就被启动（start）了，这个启动遵循以下行为:";}i:2;i:6752;}i:207;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6918;}i:208;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6918;}i:209;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:521:"· android.nfc.action.NDEF_DISCOVERED: 这个intent是在一个包含NDEF负载的tag被检测到时启动，这是最高优先级的intent, android系统不会让你指定一个Intent能处理所有的NFC数据类型，你必须在AndroidManifest.xml中指定与NFC tag对应的<data>元素，这样当扫描到的tag传过来的数据类型与你定义的相匹配时，你的Activity就会被调用。例如想处理一个包含plain text 的 NDEF_DISCOVERED intent ，你要按照如下定义AndroidManifest.xml file:";}i:2;i:6920;}i:210;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7441;}i:211;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7441;}i:212;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"<intent-filter>";}i:2;i:7443;}i:213;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7459;}i:214;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:98:"<action android:name="android.nfc.action.NDEF_DISCOVERED"/>
<data android:mimeType="text/plain" />";}i:2;i:7459;}i:215;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7459;}i:216;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"</intent-filter>";}i:2;i:7563;}i:217;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7579;}i:218;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7579;}i:219;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:211:"如果NDEF_DISCOVERED intent 已经被启动，TECH_DISCOVERED 和 TAG_DISCOVERED intents 将不会被启动。假如一个未知的tag或者不包含NDEF负载的tag被检测到，此Intent就不会被启动。";}i:2;i:7581;}i:220;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7792;}i:221;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7792;}i:222;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:376:"· android.nfc.action.TECH_DISCOVERED: 如果 NDEF_DISCOVERED intent没启动或者没有一个Activity的filter检测NDEF_DISCOVERED ，并且此tag是已知的，那么此TECH_DISCOVERED Intent将会启动. TECH_DISCOVERED intent要求你在一个资源文件里(xml)里指定你要支持technologies列表。更多细节请看下面的Specifying tag technologies to handle.";}i:2;i:7794;}i:223;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8170;}i:224;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8170;}i:225;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:175:"· android.nfc.action.TAG_DISCOVERED: 如果没有一个activity处理_DISCOVERED and TECH_DISCOVERED intents或者tag被检测为未知的，那么此Intent将会被启动。";}i:2;i:8172;}i:226;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8347;}i:227;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8347;}i:228;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:64:"Specifying tag technologies to handle指定处理的technologies";}i:2;i:8349;}i:229;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8413;}i:230;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8413;}i:231;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:453:"假如你的Activity在AndroidManifest.xml文件里声明了处理android.nfc.action.TECH_DISCOVERED intent ，你必须创建一个Xml格式的资源文件，并加上你的activity支持的technologies到tech-list集合里。这样你的activity将被认作能处理这些tech-list的处理者，如果tag使用的technology属于你的定义的list里，你的Activity将接收此Intent。你可以用getTechList()来获得tag支持的technologies。";}i:2;i:8415;}i:232;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8868;}i:233;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8868;}i:234;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:191:"例如：如果一个tag被检测到支持MifareClassic, NdefFormatable, 和 NfcA，你的tech-list集合必须指定了其中的一项或者多项来保证你的Activity能处理此Intent。";}i:2;i:8870;}i:235;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9061;}i:236;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9061;}i:237;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:186:"下面是一个资源文件例子，定义了所有的technologies. 你可以根据需要删掉不需要的项，将此文件以任意名字+.xml保存到<project-root>/res/xml文件夹.";}i:2;i:9063;}i:238;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9249;}i:239;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9249;}i:240;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:67:"<resources xmlns:xliff=“urn:oasis:names:tc:xliff:document:1.2”>";}i:2;i:9251;}i:241;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9319;}i:242;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:416:"<tech-list>
    <tech>android.nfc.tech.IsoDep</tech>
    <tech>android.nfc.tech.NfcA</tech>        
    <tech>android.nfc.tech.NfcB</tech>
    <tech>android.nfc.tech.NfcF</tech>
    <tech>android.nfc.tech.NfcV</tech>
    <tech>android.nfc.tech.Ndef</tech>
    <tech>android.nfc.tech.NdefFormatable</tech>
    <tech>android.nfc.tech.MifareClassic</tech>
    <tech>android.nfc.tech.MifareUltralight</tech>
</tech-list>";}i:2;i:9319;}i:243;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9319;}i:244;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"</resources>";}i:2;i:9759;}i:245;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9771;}i:246;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9771;}i:247;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:332:"你也可以指定多个tech-list集合，每个集合都认做独立的。如果任何单个tech-list集合是getTechList()返回的technologies集合的子集，那么你的Activity将被认为匹配了。这个还提供’与’和’或’操作。下面的例子表示支持 NfcA和NDef的卡，或者支持NfcB和NDef的卡：";}i:2;i:9773;}i:248;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10105;}i:249;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10105;}i:250;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:67:"<resources xmlns:xliff=“urn:oasis:names:tc:xliff:document:1.2”>";}i:2;i:10107;}i:251;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10175;}i:252;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:110:"<tech-list>
    <tech>android.nfc.tech.NfcA</tech>        
    <tech>android.nfc.tech.Ndef</tech>
</tech-list>";}i:2;i:10175;}i:253;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10175;}i:254;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"</resources>";}i:2;i:10295;}i:255;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10307;}i:256;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10307;}i:257;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:67:"<resources xmlns:xliff=“urn:oasis:names:tc:xliff:document:1.2”>";}i:2;i:10309;}i:258;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10377;}i:259;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:110:"<tech-list>
    <tech>android.nfc.tech.NfcB</tech>        
    <tech>android.nfc.tech.Ndef</tech>
</tech-list>";}i:2;i:10377;}i:260;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10377;}i:261;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"</resources>";}i:2;i:10497;}i:262;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10509;}i:263;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10509;}i:264;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:148:"在 AndroidManifest.xml 文件中, 指定这个tech-list资源文件的方法是在<activity> 元素中创建<meta-data>元素，例如下面例子:";}i:2;i:10511;}i:265;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10659;}i:266;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10659;}i:267;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:30:"<activity> … <intent-filter>";}i:2;i:10661;}i:268;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10692;}i:269;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:59:"<action android:name="android.nfc.action.TECH_DISCOVERED"/>";}i:2;i:10692;}i:270;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10692;}i:271;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"</intent-filter>";}i:2;i:10755;}i:272;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10771;}i:273;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10771;}i:274;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:64:"<meta-data android:name=“android.nfc.action.TECH_DISCOVERED”";}i:2;i:10773;}i:275;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10838;}i:276;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:42:"android:resource="@xml/nfc_tech_filter" />";}i:2;i:10838;}i:277;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10838;}i:278;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"… </activity>";}i:2;i:10884;}i:279;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10899;}i:280;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10899;}i:281;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:"使用前台发布系统Using the foreground dispatch system";}i:2;i:10901;}i:282;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10961;}i:283;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10961;}i:284;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:134:"前台发布系统允许一个Activity 拦截一个tag Intent 获得最高优先级的处理，这种方式很容易使用和实现：";}i:2;i:10963;}i:285;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11097;}i:286;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11097;}i:287;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:55:"1. 添加下列代码到Activity的onCreate() 方法里";}i:2;i:11099;}i:288;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11154;}i:289;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11154;}i:290;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:111:"a. 创建一个 PendingIntent 对象, 这样Android系统就能在一个tag被检测到时定位到这个对象";}i:2;i:11156;}i:291;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11267;}i:292;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11267;}i:293;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:56:"PendingIntent pendingIntent = PendingIntent.getActivity(";}i:2;i:11269;}i:294;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11326;}i:295;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:84:"this, 0, new Intent(this, getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0);";}i:2;i:11326;}i:296;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11326;}i:297;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:439:"b. 在Intent filters里声明你想要处理的Intent，一个tag被检测到时先检查前台发布系统，如果前台Activity符合Intent filter的要求，那么前台的Activity的将处理此Intent。如果不符合，前台发布系统将Intent转到Intent发布系统。如果指定了null的Intent filters，当任意tag被检测到时，你将收到TAG_DISCOVERED intent。因此请注意你应该只处理你想要的Intent。";}i:2;i:11414;}i:298;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11854;}i:299;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:419:"IntentFilter ndef = new IntentFilter(NfcAdapter.ACTION_NDEF_DISCOVERED);
    try {
        ndef.addDataType("*/*");    /* Handles all MIME based dispatches.
                                       You should specify only the ones that you need. */
    }
    catch (MalformedMimeTypeException e) {
        throw new RuntimeException("fail", e);
    }
    intentFiltersArray = new IntentFilter[] {
            ndef,
    };";}i:2;i:11854;}i:300;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11854;}i:301;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:148:"c. 设置一个你程序要处理的Tag technologies的列表，调用Object.class.getName() 方法来获得你想要支持处理的technology类。";}i:2;i:12297;}i:302;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12445;}i:303;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12445;}i:304;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:425:"techListsArray = new String[][] { new String[] { NfcF.class.getName() } };
2. 覆盖下面的方法来打开或关闭前台发布系统。比如onPause()和onResume（）方法。必须在主线程里调用enableForegroundDispatch(Activity, PendingIntent, IntentFilter[], String[][]) 而且Activity在前台（可以在onResume()里调用来保证这点）。你也要覆盖onNewIntent回调来处理得到的NFC tag数据。";}i:2;i:12447;}i:305;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12872;}i:306;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12872;}i:307;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:"public void onPause() {";}i:2;i:12874;}i:308;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12898;}i:309;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:58:"super.onPause();
mAdapter.disableForegroundDispatch(this);";}i:2;i:12898;}i:310;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12898;}i:311;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"}";}i:2;i:12962;}i:312;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12963;}i:313;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12963;}i:314;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:"public void onResume() {";}i:2;i:12965;}i:315;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12990;}i:316;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:109:"super.onResume();
mAdapter.enableForegroundDispatch(this, pendingIntent, intentFiltersArray, techListsArray);";}i:2;i:12990;}i:317;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12990;}i:318;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"}";}i:2;i:13105;}i:319;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13106;}i:320;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13106;}i:321;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:40:"public void onNewIntent(Intent intent) {";}i:2;i:13108;}i:322;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13149;}i:323;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:102:"Tag tagFromIntent = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);
//do something with tagFromIntent";}i:2;i:13149;}i:324;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13149;}i:325;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"}";}i:2;i:13257;}i:326;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13258;}i:327;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13258;}i:328;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:39:"See the ForegroundDispatch sample from ";}i:2;i:13260;}i:329;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"API";}i:2;i:13299;}i:330;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:" Demos for the complete sample.";}i:2;i:13302;}i:331;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13333;}i:332;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13333;}i:333;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:25:"使用NFC tag上的数据";}i:2;i:13335;}i:334;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13360;}i:335;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13360;}i:336;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:757:"NFC tag上的数据是以字节存放，所以你可以将其转换成其他你想要的格式。当往tag写东西时，你必须以字节格式来写。Android提供API来帮助写符合NDEF标准的信息。使用此标准能保证你的数据在往tag写时能被所有Android NFC设备支持。然而，很多tag使用他们自己的标准来存储数据，这些标准也被Android支持。但你必须自己实现协议栈来读写这些tag。你可以在android.nfc.tech里找到所有支持的technologies，并且可以在TagTechnology接口里对technology有个了解。这一段是简单介绍在android系统里怎样使用NDEF 消息。这不意味着是一个完整的NDEF功能的介绍。但标出了主要需要注意和使用的东西。";}i:2;i:13362;}i:337;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14119;}i:338;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14119;}i:339;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:638:"为了方便使用NDEF消息，android提供NdefRecord 和 NdefMessage来包装原始字节数据为NDEF消息。一个NdefMessage是保存0个或多个NdefRecords的容器。每个NdefRecord有自己的唯一类型名字格式，记录类型和ID来与其他记录区分开。你可以存储不同类型的记录，不同的长度到同一个 NdefMessage。NFC tag容量的限制决定你的NdefMessage的大小。 那些支持Ndef和NdefFormatable技术的tag可以返回和接受NdefMessage对象为参数来进行读写操作。你需要创建你自己的逻辑来为其他在android.nfc.tech的tag技术实现读写字节的操作。";}i:2;i:14121;}i:340;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14759;}i:341;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14759;}i:342;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"你可以从NFC Forum(";}i:2;i:14761;}i:343;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:31:"http://www.nfc-forum.org/specs/";i:1;N;}i:2;i:14783;}i:344;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:145:")下载NDEF消息标准的技术文档，比如纯文本和智慧型海报. NFCDemo例子里声明了纯文本和智慧型海报的NDef 消息。";}i:2;i:14814;}i:345;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14959;}i:346;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14959;}i:347;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"读一个NFC tag";}i:2;i:14961;}i:348;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14977;}i:349;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14977;}i:350;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:241:"当一个NFC tag靠近一个NFC设备，一个相应的Intent将在设备上被创建。然后通知合适的程序来处理此Intent。 下面的方法处理TAG_DISCOVERED intent并且使用迭代器来获得包含在NDEF tag负载的数据";}i:2;i:14979;}i:351;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15220;}i:352;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15220;}i:353;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:46:"NdefMessage[] getNdefMessages(Intent intent) {";}i:2;i:15222;}i:354;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15269;}i:355;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:786:"// Parse the intent
NdefMessage[] msgs = null;
String action = intent.getAction();
if (NfcAdapter.ACTION_TAG_DISCOVERED.equals(action)) {
    Parcelable[] rawMsgs = intent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES);
    if (rawMsgs != null) {
        msgs = new NdefMessage[rawMsgs.length];
        for (int i = 0; i < rawMsgs.length; i++) {
            msgs[i] = (NdefMessage) rawMsgs[i];
        }
    }
    else {
    // Unknown tag type
        byte[] empty = new byte[] {};
        NdefRecord record = new NdefRecord(NdefRecord.TNF_UNKNOWN, empty, empty, empty);
        NdefMessage msg = new NdefMessage(new NdefRecord[] {record});
        msgs = new NdefMessage[] {msg};
    }
}        
else {
    Log.e(TAG, "Unknown intent " + intent);
    finish();
}
return msgs;";}i:2;i:15269;}i:356;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15269;}i:357;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"}";}i:2;i:16105;}i:358;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16106;}i:359;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16106;}i:360;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:243:"请记住NFC设备读到的数据是byte类型，所以你可能需要将他转成其他格式来呈现给用户。NFCDemo例子展示了怎样用com.example.android.nfc.record中的类来解析NDEF消息，比如纯文本和智慧型海报。";}i:2;i:16108;}i:361;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16351;}i:362;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16351;}i:363;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:"写NFC tag";}i:2;i:16353;}i:364;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16363;}i:365;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16363;}i:366;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:162:"往NFC tag写东西涉及到构造一个NDEF 消息和使用与tag匹配的Tag技术。下面的代码展示怎样写一个简单的文本到NdefFormatable tag：";}i:2;i:16365;}i:367;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16527;}i:368;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16527;}i:369;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:138:"NdefFormatable tag = NdefFormatable.get(t); Locale locale = Locale.US; final byte[] langBytes = locale.getLanguage().getBytes(Charsets.US_";}i:2;i:16529;}i:370;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:5:"ASCII";}i:2;i:16667;}i:371;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:362:"); String text = “Tag, you're it!”; final byte[] textBytes = text.getBytes(Charsets.UTF_8); final int utfBit = 0; final char status = (char) (utfBit + langBytes.length); final byte[] data = Bytes.concat(new byte[] {(byte) status}, langBytes, textBytes); NdefRecord record = NdefRecord(NdefRecord.TNF_WELL_KNOWN, NdefRecord.RTD_TEXT, new byte[0], data); try {";}i:2;i:16672;}i:372;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17035;}i:373;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:114:"NdefRecord[] records = {text};
NdefMessage message = new NdefMessage(records);
tag.connect();
tag.format(message);";}i:2;i:17035;}i:374;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17035;}i:375;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"} catch (Exception e){";}i:2;i:17159;}i:376;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17182;}i:377;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:19:"//do error handling";}i:2;i:17182;}i:378;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17182;}i:379;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"}";}i:2;i:17205;}i:380;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17206;}i:381;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17206;}i:382;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:"点对点的数据交换";}i:2;i:17208;}i:383;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17232;}i:384;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17232;}i:385;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:167:"前台推送技术支持简单点对点的数据交换，你可以用enableForegroundNdefPush(Activity, NdefMessage) 方法来打开此功能. 为了用这个功能：";}i:2;i:17234;}i:386;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17401;}i:387;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17401;}i:388;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:52:"· 推送数据的Activity必须是前台Activity。";}i:2;i:17403;}i:389;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17455;}i:390;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17455;}i:391;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:68:"· 你必须将你要发送的数据封装到NdefMessage对象里。";}i:2;i:17457;}i:392;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17525;}i:393;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17525;}i:394;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:114:"· 接收推送数据的设备必须支持com.android.npp NDEF推送协议，这个对于Android设备是可选的";}i:2;i:17527;}i:395;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17641;}i:396;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17641;}i:397;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:262:"假如你的Activity打开了前台推送功能并且位于前台，这时标准的Intent发布系统是禁止的。然而，如果你的Activity允许前台发布系统，那么此时检测tag的功能仍然是可用的，不过只适用于前台发布系统。";}i:2;i:17643;}i:398;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17905;}i:399;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17905;}i:400;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"要打开前台推送:";}i:2;i:17907;}i:401;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17929;}i:402;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17929;}i:403;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:82:"1. 创建一个你要推送给其他NFC设备的包含NdefRecords的NdefMessage。";}i:2;i:17931;}i:404;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18013;}i:405;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18013;}i:406;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:268:"2. 在你的Activity里实现onResume() 和 onPause() 的回调来正确处理前台推送的生命周期。你必须在你的Activity位于前台并在主线程里调用enableForegroundNdefPush(Activity, NdefMessage) （可以在onResume()里调用来保证这点）.";}i:2;i:18015;}i:407;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18283;}i:408;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18283;}i:409;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:"public void onResume() {";}i:2;i:18285;}i:410;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18310;}i:411;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:99:"super.onResume();
if (mAdapter != null)
    mAdapter.enableForegroundNdefPush(this, myNdefMessage);";}i:2;i:18310;}i:412;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18310;}i:413;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:25:"} public void onPause() {";}i:2;i:18417;}i:414;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18443;}i:415;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:84:"super.onPause();
if (mAdapter != null)
    mAdapter.disableForegroundNdefPush(this);";}i:2;i:18443;}i:416;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18443;}i:417;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"}";}i:2;i:18535;}i:418;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18536;}i:419;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18536;}i:420;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:148:"当Activity位于前台，你可以靠近另外一个NFC设备来推送数据。请参考例子ForegroundNdefPush来了解点对点数据交换。
 ";}i:2;i:18538;}i:421;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"---";}i:2;i:18686;}i:422;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:18689;}i:423;a:3:{i:0;s:13:"emphasis_open";i:1;a:0:{}i:2;i:18690;}i:424;a:3:{i:0;s:9:"emaillink";i:1;a:2:{i:0;s:17:"ting.yang@sim.com";i:1;s:9:"ting.yang";}i:2;i:18692;}i:425;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:" 2014/04/17 11:57";}i:2;i:18723;}i:426;a:3:{i:0;s:14:"emphasis_close";i:1;a:0:{}i:2;i:18740;}i:427;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:0:"";}i:2;i:18742;}i:428;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18742;}i:429;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:18742;}}