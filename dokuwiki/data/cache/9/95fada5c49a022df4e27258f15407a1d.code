<span class="kw4">static</span> irqreturn_t e1000_intr<span class="br0">&#40;</span><span class="kw4">int</span> irq<span class="sy0">,</span> <span class="kw4">void</span> <span class="sy0">*</span>data<span class="sy0">,</span> <span class="kw4">struct</span> pt_regs <span class="sy0">*</span>regs<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
       <span class="kw4">struct</span> net_device <span class="sy0">*</span>netdev <span class="sy0">=</span> data<span class="sy0">;</span>
       <span class="kw4">struct</span> e1000_adapter <span class="sy0">*</span>adapter <span class="sy0">=</span> netdev<span class="sy0">-&gt;</span>priv<span class="sy0">;</span>
       <span class="kw4">uint32_t</span> icr <span class="sy0">=</span> E1000_READ_REG<span class="br0">&#40;</span><span class="sy0">&amp;</span>adapter<span class="sy0">-&gt;</span>hw<span class="sy0">,</span> ICR<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co2">#ifndef CONFIG_E1000_NAPI</span>
       <span class="kw4">unsigned</span> <span class="kw4">int</span> i<span class="sy0">;</span>
<span class="co2">#endif</span>
&nbsp;
       <span class="kw1">if</span><span class="br0">&#40;</span><span class="sy0">!</span>icr<span class="br0">&#41;</span>
              <span class="kw1">return</span> IRQ_NONE<span class="sy0">;</span> <span class="coMULTI">/* Not our interrupt */</span>
&nbsp;
<span class="co2">#ifdef CONFIG_E1000_NAPI</span>
       <span class="coMULTI">/*
       如果定义了采用NAPI模式接收数据包，则进入这个调用点。
首先调用netif_rx_schedule_prep(dev)，确定设备处于运行，而且设备还没有被添加到网络层的 POLL 处理队列中，在调用 netif_rx_schedule之前会调用这个函数。
接下来调用 __netif_rx_schedule(dev)，将设备的 POLL 方法添加到网络层次的 POLL 处理队列中去，排队并且准备接收数据包，在使用之前需要调用 netif_rx_reschedule_prep，并且返回的数为 1，并且触发一个 NET_RX_SOFTIRQ 的软中断通知网络层接收数据包。
处理完成。
       */</span>
       <span class="kw1">if</span><span class="br0">&#40;</span>netif_rx_schedule_prep<span class="br0">&#40;</span>netdev<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
&nbsp;
              <span class="coMULTI">/* Disable interrupts and register for poll. The flush
               of the posted write is intentionally left out.
              */</span>
&nbsp;
              atomic_inc<span class="br0">&#40;</span><span class="sy0">&amp;</span>adapter<span class="sy0">-&gt;</span>irq_sem<span class="br0">&#41;</span><span class="sy0">;</span>
              E1000_WRITE_REG<span class="br0">&#40;</span><span class="sy0">&amp;</span>adapter<span class="sy0">-&gt;</span>hw<span class="sy0">,</span> IMC<span class="sy0">,</span> ~<span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
              __netif_rx_schedule<span class="br0">&#40;</span>netdev<span class="br0">&#41;</span><span class="sy0">;</span>
       <span class="br0">&#125;</span>
<span class="co2">#else</span>
       <span class="coMULTI">/*
       在中断模式下，就会调用net_if（）函数将数据包插入接收队列中，等待软中断处理。
       */</span>
       <span class="kw1">for</span><span class="br0">&#40;</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> E1000_MAX_INTR<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span>
              <span class="kw1">if</span><span class="br0">&#40;</span><span class="sy0">!</span>e1000_clean_rx_irq<span class="br0">&#40;</span>adapter<span class="br0">&#41;</span> <span class="sy0">&amp;</span>
                 <span class="sy0">!</span>e1000_clean_tx_irq<span class="br0">&#40;</span>adapter<span class="br0">&#41;</span><span class="br0">&#41;</span>
                     <span class="kw2">break</span><span class="sy0">;</span>
<span class="co2">#endif</span>
&nbsp;
       <span class="kw1">return</span> IRQ_HANDLED<span class="sy0">;</span>
<span class="br0">&#125;</span>