
<p>
1.参考网址：<a href="http://www.learnopengles.com/android-lesson-four-introducing-basic-texturing/" class="urlextern" title="http://www.learnopengles.com/android-lesson-four-introducing-basic-texturing/"  rel="nofollow">http://www.learnopengles.com/android-lesson-four-introducing-basic-texturing/</a>
</p>

<p>
2.添加纹理到着色器中：
</p>

<p>
（1）定点着色器(Vertex Shader)中需要添加如下代码：
</p>
<pre class="code java">attribute vec2 a_TexCoordinate<span class="sy0">;</span> <span class="co1">// Per-vertex texture coordinate information we will pass in.</span>
...
<span class="me1">varying</span> vec2 v_TexCoordinate<span class="sy0">;</span>   <span class="co1">// This will be passed into the fragment shader.</span>
...
<span class="co1">// Pass through the texture coordinate.</span>
v_TexCoordinate <span class="sy0">=</span> a_TexCoordinate<span class="sy0">;</span></pre>

<p>
(2)片元着色器(Fragment Shader)中需要添加如下代码：
</p>
<pre class="code java">uniform sampler2D u_Texture<span class="sy0">;</span>    <span class="co1">// The input texture.</span>
...
<span class="me1">varying</span> vec2 v_TexCoordinate<span class="sy0">;</span> <span class="co1">// Interpolated texture coordinate per fragment.</span>
... 
<span class="co1">// Add attenuation.</span>
 diffuse <span class="sy0">=</span> diffuse <span class="sy0">*</span> <span class="br0">&#40;</span><span class="nu0">1.0</span> <span class="sy0">/</span> <span class="br0">&#40;</span><span class="nu0">1.0</span> <span class="sy0">+</span> <span class="br0">&#40;</span><span class="nu0">0.10</span> <span class="sy0">*</span> distance<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
...
<span class="co1">// Add ambient lighting</span>
 diffuse <span class="sy0">=</span> diffuse <span class="sy0">+</span> <span class="nu0">0.3</span><span class="sy0">;</span>
...
<span class="co1">// Multiply the color by the diffuse illumination level and texture value to get final output color.</span>
&nbsp;
gl_FragColor <span class="sy0">=</span> <span class="br0">&#40;</span>v_Color <span class="sy0">*</span> diffuse <span class="sy0">*</span> texture2D<span class="br0">&#40;</span>u_Texture, v_TexCoordinate<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
3.加载纹理
</p>
<pre class="code java"><span class="kw1">public</span> <span class="kw1">static</span> <span class="kw4">int</span> loadTexture<span class="br0">&#40;</span><span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+context"><span class="kw3">Context</span></a> context, <span class="kw1">final</span> <span class="kw4">int</span> resourceId<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw1">final</span> <span class="kw4">int</span><span class="br0">&#91;</span><span class="br0">&#93;</span> textureHandle <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">int</span><span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
    GLES20.<span class="me1">glGenTextures</span><span class="br0">&#40;</span><span class="nu0">1</span>, textureHandle, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>textureHandle<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        <span class="kw1">final</span> BitmapFactory.<span class="me1">Options</span> options <span class="sy0">=</span> <span class="kw1">new</span> BitmapFactory.<span class="me1">Options</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        options.<span class="me1">inScaled</span> <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span>   <span class="co1">// No pre-scaling</span>
&nbsp;
        <span class="co1">// Read in the resource</span>
        <span class="kw1">final</span> Bitmap bitmap <span class="sy0">=</span> BitmapFactory.<span class="me1">decodeResource</span><span class="br0">&#40;</span>context.<span class="me1">getResources</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, resourceId, options<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Bind to the texture in OpenGL</span>
        GLES20.<span class="me1">glBindTexture</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_TEXTURE_2D</span>, textureHandle<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Set filtering</span>
        GLES20.<span class="me1">glTexParameteri</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_TEXTURE_2D</span>, GLES20.<span class="me1">GL_TEXTURE_MIN_FILTER</span>, GLES20.<span class="me1">GL_NEAREST</span><span class="br0">&#41;</span><span class="sy0">;</span>
        GLES20.<span class="me1">glTexParameteri</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_TEXTURE_2D</span>, GLES20.<span class="me1">GL_TEXTURE_MAG_FILTER</span>, GLES20.<span class="me1">GL_NEAREST</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Load the bitmap into the bound texture.</span>
        GLUtils.<span class="me1">texImage2D</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_TEXTURE_2D</span>, <span class="nu0">0</span>, bitmap, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Recycle the bitmap, since its data has been loaded into OpenGL.</span>
        bitmap.<span class="me1">recycle</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>textureHandle<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        <span class="kw1">throw</span> <span class="kw1">new</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+runtimeexception"><span class="kw3">RuntimeException</span></a><span class="br0">&#40;</span><span class="st0">&quot;Error loading texture.&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">return</span> textureHandle<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
在loadTexture()方法中主要分4步进行
</p>

<p>
（1）通知Opengl创建Texture handle,它是指向texture的唯一标识符
</p>
<pre class="code java"><span class="kw1">final</span> <span class="kw4">int</span><span class="br0">&#91;</span><span class="br0">&#93;</span> textureHandle <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">int</span><span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy0">;</span>
GLES20.<span class="me1">glGenTextures</span><span class="br0">&#40;</span><span class="nu0">1</span>, textureHandle, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
(2)创建Bitmap对象
</p>
<pre class="code java"><span class="kw1">final</span> BitmapFactory.<span class="me1">Options</span> options <span class="sy0">=</span> <span class="kw1">new</span> BitmapFactory.<span class="me1">Options</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
options.<span class="me1">inScaled</span> <span class="sy0">=</span> <span class="kw2">false</span><span class="sy0">;</span>   <span class="co1">// No pre-scaling</span>
&nbsp;
<span class="co1">// Read in the resource</span>
<span class="kw1">final</span> Bitmap bitmap <span class="sy0">=</span> BitmapFactory.<span class="me1">decodeResource</span><span class="br0">&#40;</span>context.<span class="me1">getResources</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, resourceId, options<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
(3)绑定纹理
</p>
<pre class="code java"><span class="co1">// Bind to the texture in OpenGL</span>
GLES20.<span class="me1">glBindTexture</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_TEXTURE_2D</span>, textureHandle<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// Set filtering</span>
GLES20.<span class="me1">glTexParameteri</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_TEXTURE_2D</span>, GLES20.<span class="me1">GL_TEXTURE_MIN_FILTER</span>, GLES20.<span class="me1">GL_NEAREST</span><span class="br0">&#41;</span><span class="sy0">;</span>
GLES20.<span class="me1">glTexParameteri</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_TEXTURE_2D</span>, GLES20.<span class="me1">GL_TEXTURE_MAG_FILTER</span>, GLES20.<span class="me1">GL_NEAREST</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
(4)把创建的bitmap贴到纹理中
</p>
<pre class="code java"><span class="co1">// Load the bitmap into the bound texture.</span>
GLUtils.<span class="me1">texImage2D</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_TEXTURE_2D</span>, <span class="nu0">0</span>, bitmap, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// Recycle the bitmap, since its data has been loaded into OpenGL.</span>
bitmap.<span class="me1">recycle</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>
4.把纹理应用到场景中
</p>

<p>
（1）定义纹理数据，纹理是通过平面坐标表示（s,t）或者（x,y），可以自定义纹理坐标
</p>
<pre class="code java"><span class="co3">/** Store our model data in a float buffer. */</span>
<span class="kw1">private</span> <span class="kw1">final</span> FloatBuffer mCubeTextureCoordinates<span class="sy0">;</span>
&nbsp;
<span class="co3">/** This will be used to pass in the texture. */</span>
<span class="kw1">private</span> <span class="kw4">int</span> mTextureUniformHandle<span class="sy0">;</span>
&nbsp;
<span class="co3">/** This will be used to pass in model texture coordinate information. */</span>
<span class="kw1">private</span> <span class="kw4">int</span> mTextureCoordinateHandle<span class="sy0">;</span>
&nbsp;
<span class="co3">/** Size of the texture coordinate data in elements. */</span>
<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mTextureCoordinateDataSize <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span>
&nbsp;
<span class="co3">/** This is a handle to our texture data. */</span>
<span class="kw1">private</span> <span class="kw4">int</span> mTextureDataHandle<span class="sy0">;</span>
&nbsp;
We basically need to add <span class="kw1">new</span> members to track what we added to the shaders, as well as hold a reference to our texture.
<span class="me1">Defining</span> the texture coordinates
&nbsp;
We define our texture coordinates in the constructor<span class="sy0">:</span>
<span class="co1">// S, T (or X, Y)</span>
<span class="co1">// Texture coordinate data.</span>
<span class="co1">// Because images have a Y axis pointing downward (values increase as you move down the image) while</span>
<span class="co1">// OpenGL has a Y axis pointing upward, we adjust for that here by flipping the Y axis.</span>
<span class="co1">// What's more is that the texture coordinates are the same for every face.</span>
<span class="kw1">final</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> cubeTextureCoordinateData <span class="sy0">=</span>
<span class="br0">&#123;</span>
        <span class="co1">// Front face</span>
        0.0f, 0.0f,
        0.0f, 1.0f,
        1.0f, 0.0f,
        0.0f, 1.0f,
        1.0f, 1.0f,
        1.0f, 0.0f,
&nbsp;
        .......
<span class="br0">&#125;</span></pre>

<p>
(2)创建纹理
</p>
<pre class="code java"><span class="kw1">public</span> <span class="kw4">void</span> onSurfaceCreated<span class="br0">&#40;</span>GL10 glUnused, EGLConfig config<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
&nbsp;
    ...
&nbsp;
    <span class="co1">// The below glEnable() call is a holdover from OpenGL ES 1, and is not needed in OpenGL ES 2.</span>
    <span class="co1">// Enable texture mapping</span>
    <span class="co1">// GLES20.glEnable(GLES20.GL_TEXTURE_2D);</span>
&nbsp;
    ...
&nbsp;
    <span class="me1">mProgramHandle</span> <span class="sy0">=</span> ShaderHelper.<span class="me1">createAndLinkProgram</span><span class="br0">&#40;</span>vertexShaderHandle, fragmentShaderHandle,
            <span class="kw1">new</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a><span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="br0">&#123;</span><span class="st0">&quot;a_Position&quot;</span>,  <span class="st0">&quot;a_Color&quot;</span>, <span class="st0">&quot;a_Normal&quot;</span>, <span class="st0">&quot;a_TexCoordinate&quot;</span><span class="br0">&#125;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    ...
&nbsp;
    <span class="co1">// Load the texture</span>
    mTextureDataHandle <span class="sy0">=</span> TextureHelper.<span class="me1">loadTexture</span><span class="br0">&#40;</span>mActivityContext, R.<span class="me1">drawable</span>.<span class="me1">bumpy_bricks_public_domain</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
（3）使用纹理
</p>
<pre class="code java">@Override
<span class="kw1">public</span> <span class="kw4">void</span> onDrawFrame<span class="br0">&#40;</span>GL10 glUnused<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
&nbsp;
    ...
&nbsp;
    <span class="me1">mTextureUniformHandle</span> <span class="sy0">=</span> GLES20.<span class="me1">glGetUniformLocation</span><span class="br0">&#40;</span>mProgramHandle, <span class="st0">&quot;u_Texture&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    mTextureCoordinateHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetAttribLocation</span><span class="br0">&#40;</span>mProgramHandle, <span class="st0">&quot;a_TexCoordinate&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Set the active texture unit to texture unit 0.</span>
    GLES20.<span class="me1">glActiveTexture</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_TEXTURE0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Bind the texture to this unit.</span>
    GLES20.<span class="me1">glBindTexture</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_TEXTURE_2D</span>, mTextureDataHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Tell the texture uniform sampler to use this texture in the shader by binding to texture unit 0.</span>
    GLES20.<span class="me1">glUniform1i</span><span class="br0">&#40;</span>mTextureUniformHandle, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>
5.加载着色器，顶点着色器（Vertex Shader）和片元着色器(Fragment Shader)可以通过着色器语言编写成独立的文件（.glsl为后缀的文件）,也可以直接在
当前文件中编写。
</p>

<p>
（1）per_pixel_vertex_shader.glsl文件
</p>
<pre class="code java">uniform mat4 u_MVPMatrix<span class="sy0">;</span>		<span class="co1">// A constant representing the combined model/view/projection matrix.      		       </span>
uniform mat4 u_MVMatrix<span class="sy0">;</span>		<span class="co1">// A constant representing the combined model/view matrix.       		</span>
&nbsp;
attribute vec4 a_Position<span class="sy0">;</span>		<span class="co1">// Per-vertex position information we will pass in.   				</span>
attribute vec4 a_Color<span class="sy0">;</span>			<span class="co1">// Per-vertex color information we will pass in. 				</span>
attribute vec3 a_Normal<span class="sy0">;</span>		<span class="co1">// Per-vertex normal information we will pass in.      </span>
attribute vec2 a_TexCoordinate<span class="sy0">;</span> <span class="co1">// Per-vertex texture coordinate information we will pass in. 		</span>
&nbsp;
varying vec3 v_Position<span class="sy0">;</span>		<span class="co1">// This will be passed into the fragment shader.       		</span>
varying vec4 v_Color<span class="sy0">;</span>			<span class="co1">// This will be passed into the fragment shader.          		</span>
varying vec3 v_Normal<span class="sy0">;</span>			<span class="co1">// This will be passed into the fragment shader.  </span>
varying vec2 v_TexCoordinate<span class="sy0">;</span>   <span class="co1">// This will be passed into the fragment shader.    		</span>
&nbsp;
<span class="co1">// The entry point for our vertex shader.  </span>
<span class="kw4">void</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>                                                 	
<span class="br0">&#123;</span>                                                         
	<span class="co1">// Transform the vertex into eye space. 	</span>
	v_Position <span class="sy0">=</span> vec3<span class="br0">&#40;</span>u_MVMatrix <span class="sy0">*</span> a_Position<span class="br0">&#41;</span><span class="sy0">;</span>            
&nbsp;
	<span class="co1">// Pass through the color.</span>
	v_Color <span class="sy0">=</span> a_Color<span class="sy0">;</span>
&nbsp;
	<span class="co1">// Pass through the texture coordinate.</span>
	v_TexCoordinate <span class="sy0">=</span> a_TexCoordinate<span class="sy0">;</span>                                      
&nbsp;
	<span class="co1">// Transform the normal's orientation into eye space.</span>
    v_Normal <span class="sy0">=</span> vec3<span class="br0">&#40;</span>u_MVMatrix <span class="sy0">*</span> vec4<span class="br0">&#40;</span>a_Normal, <span class="nu0">0.0</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="co1">// gl_Position is a special variable used to store the final position.</span>
	<span class="co1">// Multiply the vertex by the matrix to get the final point in normalized screen coordinates.</span>
	gl_Position <span class="sy0">=</span> u_MVPMatrix <span class="sy0">*</span> a_Position<span class="sy0">;</span>                       		  
<span class="br0">&#125;</span></pre>

<p>
（2）per_pixel_fragment_shader.glsl
</p>
<pre class="code java">precision mediump <span class="kw4">float</span><span class="sy0">;</span>       	<span class="co1">// Set the default precision to medium. We don't need as high of a </span>
								<span class="co1">// precision in the fragment shader.</span>
uniform vec3 u_LightPos<span class="sy0">;</span>       	<span class="co1">// The position of the light in eye space.</span>
uniform sampler2D u_Texture<span class="sy0">;</span>    <span class="co1">// The input texture.</span>
&nbsp;
varying vec3 v_Position<span class="sy0">;</span>		<span class="co1">// Interpolated position for this fragment.</span>
varying vec4 v_Color<span class="sy0">;</span>          	<span class="co1">// This is the color from the vertex shader interpolated across the </span>
  								<span class="co1">// triangle per fragment.</span>
varying vec3 v_Normal<span class="sy0">;</span>         	<span class="co1">// Interpolated normal for this fragment.</span>
varying vec2 v_TexCoordinate<span class="sy0">;</span>   <span class="co1">// Interpolated texture coordinate per fragment.</span>
&nbsp;
<span class="co1">// The entry point for our fragment shader.</span>
<span class="kw4">void</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>                    		
<span class="br0">&#123;</span>                              
    <span class="co1">// Will be used for attenuation.</span>
    <span class="kw4">float</span> distance <span class="sy0">=</span> length<span class="br0">&#40;</span>u_LightPos <span class="sy0">-</span> v_Position<span class="br0">&#41;</span><span class="sy0">;</span>                  
&nbsp;
    <span class="co1">// Get a lighting direction vector from the light to the vertex.</span>
    vec3 lightVector <span class="sy0">=</span> normalize<span class="br0">&#40;</span>u_LightPos <span class="sy0">-</span> v_Position<span class="br0">&#41;</span><span class="sy0">;</span>              	
&nbsp;
    <span class="co1">// Calculate the dot product of the light vector and vertex normal. If the normal and light vector are</span>
    <span class="co1">// pointing in the same direction then it will get max illumination.</span>
    <span class="kw4">float</span> diffuse <span class="sy0">=</span> max<span class="br0">&#40;</span>dot<span class="br0">&#40;</span>v_Normal, lightVector<span class="br0">&#41;</span>, <span class="nu0">0.0</span><span class="br0">&#41;</span><span class="sy0">;</span>               	  		  													  
&nbsp;
    <span class="co1">// Add attenuation. </span>
    diffuse <span class="sy0">=</span> diffuse <span class="sy0">*</span> <span class="br0">&#40;</span><span class="nu0">1.0</span> <span class="sy0">/</span> <span class="br0">&#40;</span><span class="nu0">1.0</span> <span class="sy0">+</span> <span class="br0">&#40;</span><span class="nu0">0.10</span> <span class="sy0">*</span> distance<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Add ambient lighting</span>
    diffuse <span class="sy0">=</span> diffuse <span class="sy0">+</span> <span class="nu0">0.3</span><span class="sy0">;</span>  
    <span class="co1">// Multiply the color by the diffuse illumination level and texture value to get final output color.</span>
    gl_FragColor <span class="sy0">=</span> <span class="br0">&#40;</span>v_Color <span class="sy0">*</span> diffuse <span class="sy0">*</span> texture2D<span class="br0">&#40;</span>u_Texture, v_TexCoordinate<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>                                  		
<span class="br0">&#125;</span>                                                                     	</pre>

<p>
(3)加载.glsl文件
</p>
<pre class="code java"><span class="kw1">public</span> <span class="kw1">class</span> RawResourceReader <span class="br0">&#123;</span>
&nbsp;
    <span class="kw1">public</span> <span class="kw1">static</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> readTextFileFromRawResource<span class="br0">&#40;</span><span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+context"><span class="kw3">Context</span></a> context, <span class="kw1">final</span> <span class="kw4">int</span> resourceId<span class="br0">&#41;</span><span class="br0">&#123;</span>
&nbsp;
        <span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+inputstream"><span class="kw3">InputStream</span></a> inputStream <span class="sy0">=</span> context.<span class="me1">getResources</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">openRawResource</span><span class="br0">&#40;</span>resourceId<span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+inputstreamreader"><span class="kw3">InputStreamReader</span></a> inputStreamReader <span class="sy0">=</span> <span class="kw1">new</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+inputstreamreader"><span class="kw3">InputStreamReader</span></a><span class="br0">&#40;</span>inputStream<span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+bufferedreader"><span class="kw3">BufferedReader</span></a> bufferedReader <span class="sy0">=</span> <span class="kw1">new</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+bufferedreader"><span class="kw3">BufferedReader</span></a><span class="br0">&#40;</span>inputStreamReader<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> nextLine<span class="sy0">;</span>
        <span class="kw1">final</span> StringBuilder body <span class="sy0">=</span> <span class="kw1">new</span> StringBuilder<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw1">try</span><span class="br0">&#123;</span>
            <span class="kw1">while</span><span class="br0">&#40;</span><span class="br0">&#40;</span>nextLine <span class="sy0">=</span> bufferedReader.<span class="me1">readLine</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">&#41;</span><span class="br0">&#123;</span>
                body.<span class="me1">append</span><span class="br0">&#40;</span>nextLine<span class="br0">&#41;</span><span class="sy0">;</span>
                body.<span class="me1">append</span><span class="br0">&#40;</span><span class="st0">'<span class="es0">\n</span>'</span><span class="br0">&#41;</span><span class="sy0">;</span>
            <span class="br0">&#125;</span>
        <span class="br0">&#125;</span><span class="kw1">catch</span> <span class="br0">&#40;</span><a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+ioexception"><span class="kw3">IOException</span></a> e<span class="br0">&#41;</span><span class="br0">&#123;</span>
            <span class="kw1">return</span> <span class="kw2">null</span><span class="sy0">;</span>
        <span class="br0">&#125;</span>
&nbsp;
        <span class="kw1">return</span> body.<span class="me1">toString</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>

<p>
6.详细案例
</p>

<p>
（1）创建Activity
</p>
<pre class="code java"><span class="kw1">package</span> <span class="co2">com.learnopengles.android.lesson4</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">import</span> <span class="co2">android.app.Activity</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.app.ActivityManager</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.content.Context</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.content.pm.ConfigurationInfo</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.opengl.GLSurfaceView</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.os.Bundle</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">public</span> <span class="kw1">class</span> LessonFourActivity <span class="kw1">extends</span> Activity 
<span class="br0">&#123;</span>
	<span class="co3">/** Hold a reference to our GLSurfaceView */</span>
	<span class="kw1">private</span> GLSurfaceView mGLSurfaceView<span class="sy0">;</span>
&nbsp;
	@Override
	<span class="kw1">public</span> <span class="kw4">void</span> onCreate<span class="br0">&#40;</span>Bundle savedInstanceState<span class="br0">&#41;</span> 
	<span class="br0">&#123;</span>
		<span class="kw1">super</span>.<span class="me1">onCreate</span><span class="br0">&#40;</span>savedInstanceState<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		mGLSurfaceView <span class="sy0">=</span> <span class="kw1">new</span> GLSurfaceView<span class="br0">&#40;</span><span class="kw1">this</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Check if the system supports OpenGL ES 2.0.</span>
		<span class="kw1">final</span> ActivityManager activityManager <span class="sy0">=</span> <span class="br0">&#40;</span>ActivityManager<span class="br0">&#41;</span> getSystemService<span class="br0">&#40;</span><a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+context"><span class="kw3">Context</span></a>.<span class="me1">ACTIVITY_SERVICE</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="kw1">final</span> ConfigurationInfo configurationInfo <span class="sy0">=</span> activityManager.<span class="me1">getDeviceConfigurationInfo</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">boolean</span> supportsEs2 <span class="sy0">=</span> configurationInfo.<span class="me1">reqGlEsVersion</span> <span class="sy0">&gt;=</span> 0x20000<span class="sy0">;</span>
&nbsp;
		<span class="kw1">if</span> <span class="br0">&#40;</span>supportsEs2<span class="br0">&#41;</span> 
		<span class="br0">&#123;</span>
			<span class="co1">// Request an OpenGL ES 2.0 compatible context.</span>
			mGLSurfaceView.<span class="me1">setEGLContextClientVersion</span><span class="br0">&#40;</span><span class="nu0">2</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
			<span class="co1">// Set the renderer to our demo renderer, defined below.</span>
			mGLSurfaceView.<span class="me1">setRenderer</span><span class="br0">&#40;</span><span class="kw1">new</span> LessonFourRenderer<span class="br0">&#40;</span><span class="kw1">this</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="br0">&#125;</span> 
		<span class="kw1">else</span> 
		<span class="br0">&#123;</span>
			<span class="co1">// This is where you could create an OpenGL ES 1.x compatible</span>
			<span class="co1">// renderer if you wanted to support both ES 1 and ES 2.</span>
			<span class="kw1">return</span><span class="sy0">;</span>
		<span class="br0">&#125;</span>
&nbsp;
		setContentView<span class="br0">&#40;</span>mGLSurfaceView<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	@Override
	<span class="kw1">protected</span> <span class="kw4">void</span> onResume<span class="br0">&#40;</span><span class="br0">&#41;</span> 
	<span class="br0">&#123;</span>
		<span class="co1">// The activity must call the GL surface view's onResume() on activity onResume().</span>
		<span class="kw1">super</span>.<span class="me1">onResume</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		mGLSurfaceView.<span class="me1">onResume</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	@Override
	<span class="kw1">protected</span> <span class="kw4">void</span> onPause<span class="br0">&#40;</span><span class="br0">&#41;</span> 
	<span class="br0">&#123;</span>
		<span class="co1">// The activity must call the GL surface view's onPause() on activity onPause().</span>
		<span class="kw1">super</span>.<span class="me1">onPause</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		mGLSurfaceView.<span class="me1">onPause</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>	
<span class="br0">&#125;</span></pre>

<p>
(2)创建renderer
</p>
<pre class="code java"><span class="kw1">package</span> <span class="co2">com.learnopengles.android.lesson4</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">import</span> <span class="co2">java.nio.ByteBuffer</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.nio.ByteOrder</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.nio.FloatBuffer</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">import</span> <span class="co2">javax.microedition.khronos.egl.EGLConfig</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">javax.microedition.khronos.opengles.GL10</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">import</span> <span class="co2">android.content.Context</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.opengl.GLES20</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.opengl.GLSurfaceView</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.opengl.Matrix</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.os.SystemClock</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">import</span> <span class="co2">com.learnopengles.android.R</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">com.learnopengles.android.common.RawResourceReader</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">com.learnopengles.android.common.ShaderHelper</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">com.learnopengles.android.common.TextureHelper</span><span class="sy0">;</span>
&nbsp;
<span class="co3">/**
 * This class implements our custom renderer. Note that the GL10 parameter passed in is unused for OpenGL ES 2.0
 * renderers -- the static class GLES20 is used instead.
 */</span>
<span class="kw1">public</span> <span class="kw1">class</span> LessonFourRenderer <span class="kw1">implements</span> GLSurfaceView.<a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+renderer"><span class="kw3">Renderer</span></a> 
<span class="br0">&#123;</span>	
	<span class="co3">/** Used for debug logs. */</span>
	<span class="kw1">private</span> <span class="kw1">static</span> <span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> TAG <span class="sy0">=</span> <span class="st0">&quot;LessonFourRenderer&quot;</span><span class="sy0">;</span>
&nbsp;
	<span class="kw1">private</span> <span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+context"><span class="kw3">Context</span></a> mActivityContext<span class="sy0">;</span>
&nbsp;
	<span class="co3">/**
	 * Store the model matrix. This matrix is used to move models from object space (where each model can be thought
	 * of being located at the center of the universe) to world space.
	 */</span>
	<span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mModelMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/**
	 * Store the view matrix. This can be thought of as our camera. This matrix transforms world space to eye space;
	 * it positions things relative to our eye.
	 */</span>
	<span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mViewMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** Store the projection matrix. This is used to project the scene onto a 2D viewport. */</span>
	<span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mProjectionMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** Allocate storage for the final combined matrix. This will be passed into the shader program. */</span>
	<span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mMVPMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** 
	 * Stores a copy of the model matrix specifically for the light position.
	 */</span>
	<span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mLightModelMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>	
&nbsp;
	<span class="co3">/** Store our model data in a float buffer. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> FloatBuffer mCubePositions<span class="sy0">;</span>
	<span class="kw1">private</span> <span class="kw1">final</span> FloatBuffer mCubeColors<span class="sy0">;</span>
	<span class="kw1">private</span> <span class="kw1">final</span> FloatBuffer mCubeNormals<span class="sy0">;</span>
	<span class="kw1">private</span> <span class="kw1">final</span> FloatBuffer mCubeTextureCoordinates<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This will be used to pass in the transformation matrix. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mMVPMatrixHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This will be used to pass in the modelview matrix. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mMVMatrixHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This will be used to pass in the light position. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mLightPosHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This will be used to pass in the texture. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mTextureUniformHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This will be used to pass in model position information. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mPositionHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This will be used to pass in model color information. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mColorHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This will be used to pass in model normal information. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mNormalHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This will be used to pass in model texture coordinate information. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mTextureCoordinateHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** How many bytes per float. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mBytesPerFloat <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">;</span>	
&nbsp;
	<span class="co3">/** Size of the position data in elements. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mPositionDataSize <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>	
&nbsp;
	<span class="co3">/** Size of the color data in elements. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mColorDataSize <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">;</span>	
&nbsp;
	<span class="co3">/** Size of the normal data in elements. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mNormalDataSize <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** Size of the texture coordinate data in elements. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mTextureCoordinateDataSize <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** Used to hold a light centered on the origin in model space. We need a 4th coordinate so we can get translations to work when
	 *  we multiply this by our transformation matrices. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mLightPosInModelSpace <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="br0">&#123;</span>0.0f, 0.0f, 0.0f, 1.0f<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** Used to hold the current position of the light in world space (after transformation via model matrix). */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mLightPosInWorldSpace <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">4</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** Used to hold the transformed position of the light in eye space (after transformation via modelview matrix) */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mLightPosInEyeSpace <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">4</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This is a handle to our cube shading program. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mProgramHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This is a handle to our light point program. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mPointProgramHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This is a handle to our texture data. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mTextureDataHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/**
	 * Initialize the model data.
	 */</span>
	<span class="kw1">public</span> LessonFourRenderer<span class="br0">&#40;</span><span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+context"><span class="kw3">Context</span></a> activityContext<span class="br0">&#41;</span>
	<span class="br0">&#123;</span>	
		mActivityContext <span class="sy0">=</span> activityContext<span class="sy0">;</span>
&nbsp;
		<span class="co1">// Define points for a cube.		</span>
&nbsp;
		<span class="co1">// X, Y, Z</span>
		<span class="kw1">final</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> cubePositionData <span class="sy0">=</span>
		<span class="br0">&#123;</span>
				<span class="co1">// In OpenGL counter-clockwise winding is default. This means that when we look at a triangle, </span>
				<span class="co1">// if the points are counter-clockwise we are looking at the &quot;front&quot;. If not we are looking at</span>
				<span class="co1">// the back. OpenGL has an optimization where all back-facing triangles are culled, since they</span>
				<span class="co1">// usually represent the backside of an object and aren't visible anyways.</span>
&nbsp;
				<span class="co1">// Front face</span>
				<span class="sy0">-</span>1.0f, 1.0f, 1.0f,				
				<span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f, 1.0f,
				1.0f, 1.0f, 1.0f, 
				<span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f, 1.0f, 				
				1.0f, <span class="sy0">-</span>1.0f, 1.0f,
				1.0f, 1.0f, 1.0f,
&nbsp;
				<span class="co1">// Right face</span>
				1.0f, 1.0f, 1.0f,				
				1.0f, <span class="sy0">-</span>1.0f, 1.0f,
				1.0f, 1.0f, <span class="sy0">-</span>1.0f,
				1.0f, <span class="sy0">-</span>1.0f, 1.0f,				
				1.0f, <span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f,
				1.0f, 1.0f, <span class="sy0">-</span>1.0f,
&nbsp;
				<span class="co1">// Back face</span>
				1.0f, 1.0f, <span class="sy0">-</span>1.0f,				
				1.0f, <span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f,
				<span class="sy0">-</span>1.0f, 1.0f, <span class="sy0">-</span>1.0f,
				1.0f, <span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f,				
				<span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f,
				<span class="sy0">-</span>1.0f, 1.0f, <span class="sy0">-</span>1.0f,
&nbsp;
				<span class="co1">// Left face</span>
				<span class="sy0">-</span>1.0f, 1.0f, <span class="sy0">-</span>1.0f,				
				<span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f,
				<span class="sy0">-</span>1.0f, 1.0f, 1.0f, 
				<span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f,				
				<span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f, 1.0f, 
				<span class="sy0">-</span>1.0f, 1.0f, 1.0f, 
&nbsp;
				<span class="co1">// Top face</span>
				<span class="sy0">-</span>1.0f, 1.0f, <span class="sy0">-</span>1.0f,				
				<span class="sy0">-</span>1.0f, 1.0f, 1.0f, 
				1.0f, 1.0f, <span class="sy0">-</span>1.0f, 
				<span class="sy0">-</span>1.0f, 1.0f, 1.0f, 				
				1.0f, 1.0f, 1.0f, 
				1.0f, 1.0f, <span class="sy0">-</span>1.0f,
&nbsp;
				<span class="co1">// Bottom face</span>
				1.0f, <span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f,				
				1.0f, <span class="sy0">-</span>1.0f, 1.0f, 
				<span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f,
				1.0f, <span class="sy0">-</span>1.0f, 1.0f, 				
				<span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f, 1.0f,
				<span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f,
		<span class="br0">&#125;</span><span class="sy0">;</span>	
&nbsp;
		<span class="co1">// R, G, B, A</span>
		<span class="kw1">final</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> cubeColorData <span class="sy0">=</span>
		<span class="br0">&#123;</span>				
				<span class="co1">// Front face (red)</span>
				1.0f, 0.0f, 0.0f, 1.0f,				
				1.0f, 0.0f, 0.0f, 1.0f,
				1.0f, 0.0f, 0.0f, 1.0f,
				1.0f, 0.0f, 0.0f, 1.0f,				
				1.0f, 0.0f, 0.0f, 1.0f,
				1.0f, 0.0f, 0.0f, 1.0f,
&nbsp;
				<span class="co1">// Right face (green)</span>
				0.0f, 1.0f, 0.0f, 1.0f,				
				0.0f, 1.0f, 0.0f, 1.0f,
				0.0f, 1.0f, 0.0f, 1.0f,
				0.0f, 1.0f, 0.0f, 1.0f,				
				0.0f, 1.0f, 0.0f, 1.0f,
				0.0f, 1.0f, 0.0f, 1.0f,
&nbsp;
				<span class="co1">// Back face (blue)</span>
				0.0f, 0.0f, 1.0f, 1.0f,				
				0.0f, 0.0f, 1.0f, 1.0f,
				0.0f, 0.0f, 1.0f, 1.0f,
				0.0f, 0.0f, 1.0f, 1.0f,				
				0.0f, 0.0f, 1.0f, 1.0f,
				0.0f, 0.0f, 1.0f, 1.0f,
&nbsp;
				<span class="co1">// Left face (yellow)</span>
				1.0f, 1.0f, 0.0f, 1.0f,				
				1.0f, 1.0f, 0.0f, 1.0f,
				1.0f, 1.0f, 0.0f, 1.0f,
				1.0f, 1.0f, 0.0f, 1.0f,				
				1.0f, 1.0f, 0.0f, 1.0f,
				1.0f, 1.0f, 0.0f, 1.0f,
&nbsp;
				<span class="co1">// Top face (cyan)</span>
				0.0f, 1.0f, 1.0f, 1.0f,				
				0.0f, 1.0f, 1.0f, 1.0f,
				0.0f, 1.0f, 1.0f, 1.0f,
				0.0f, 1.0f, 1.0f, 1.0f,				
				0.0f, 1.0f, 1.0f, 1.0f,
				0.0f, 1.0f, 1.0f, 1.0f,
&nbsp;
				<span class="co1">// Bottom face (magenta)</span>
				1.0f, 0.0f, 1.0f, 1.0f,				
				1.0f, 0.0f, 1.0f, 1.0f,
				1.0f, 0.0f, 1.0f, 1.0f,
				1.0f, 0.0f, 1.0f, 1.0f,				
				1.0f, 0.0f, 1.0f, 1.0f,
				1.0f, 0.0f, 1.0f, 1.0f
		<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// X, Y, Z</span>
		<span class="co1">// The normal is used in light calculations and is a vector which points</span>
		<span class="co1">// orthogonal to the plane of the surface. For a cube model, the normals</span>
		<span class="co1">// should be orthogonal to the points of each face.</span>
		<span class="kw1">final</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> cubeNormalData <span class="sy0">=</span>
		<span class="br0">&#123;</span>												
				<span class="co1">// Front face</span>
				0.0f, 0.0f, 1.0f,				
				0.0f, 0.0f, 1.0f,
				0.0f, 0.0f, 1.0f,
				0.0f, 0.0f, 1.0f,				
				0.0f, 0.0f, 1.0f,
				0.0f, 0.0f, 1.0f,
&nbsp;
				<span class="co1">// Right face </span>
				1.0f, 0.0f, 0.0f,				
				1.0f, 0.0f, 0.0f,
				1.0f, 0.0f, 0.0f,
				1.0f, 0.0f, 0.0f,				
				1.0f, 0.0f, 0.0f,
				1.0f, 0.0f, 0.0f,
&nbsp;
				<span class="co1">// Back face </span>
				0.0f, 0.0f, <span class="sy0">-</span>1.0f,				
				0.0f, 0.0f, <span class="sy0">-</span>1.0f,
				0.0f, 0.0f, <span class="sy0">-</span>1.0f,
				0.0f, 0.0f, <span class="sy0">-</span>1.0f,				
				0.0f, 0.0f, <span class="sy0">-</span>1.0f,
				0.0f, 0.0f, <span class="sy0">-</span>1.0f,
&nbsp;
				<span class="co1">// Left face </span>
				<span class="sy0">-</span>1.0f, 0.0f, 0.0f,				
				<span class="sy0">-</span>1.0f, 0.0f, 0.0f,
				<span class="sy0">-</span>1.0f, 0.0f, 0.0f,
				<span class="sy0">-</span>1.0f, 0.0f, 0.0f,				
				<span class="sy0">-</span>1.0f, 0.0f, 0.0f,
				<span class="sy0">-</span>1.0f, 0.0f, 0.0f,
&nbsp;
				<span class="co1">// Top face </span>
				0.0f, 1.0f, 0.0f,			
				0.0f, 1.0f, 0.0f,
				0.0f, 1.0f, 0.0f,
				0.0f, 1.0f, 0.0f,				
				0.0f, 1.0f, 0.0f,
				0.0f, 1.0f, 0.0f,
&nbsp;
				<span class="co1">// Bottom face </span>
				0.0f, <span class="sy0">-</span>1.0f, 0.0f,			
				0.0f, <span class="sy0">-</span>1.0f, 0.0f,
				0.0f, <span class="sy0">-</span>1.0f, 0.0f,
				0.0f, <span class="sy0">-</span>1.0f, 0.0f,				
				0.0f, <span class="sy0">-</span>1.0f, 0.0f,
				0.0f, <span class="sy0">-</span>1.0f, 0.0f
		<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// S, T (or X, Y)</span>
		<span class="co1">// Texture coordinate data.</span>
		<span class="co1">// Because images have a Y axis pointing downward (values increase as you move down the image) while</span>
		<span class="co1">// OpenGL has a Y axis pointing upward, we adjust for that here by flipping the Y axis.</span>
		<span class="co1">// What's more is that the texture coordinates are the same for every face.</span>
		<span class="kw1">final</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> cubeTextureCoordinateData <span class="sy0">=</span>
		<span class="br0">&#123;</span>												
				<span class="co1">// Front face</span>
				0.0f, 0.0f, 				
				0.0f, 1.0f,
				1.0f, 0.0f,
				0.0f, 1.0f,
				1.0f, 1.0f,
				1.0f, 0.0f,				
&nbsp;
				<span class="co1">// Right face </span>
				0.0f, 0.0f, 				
				0.0f, 1.0f,
				1.0f, 0.0f,
				0.0f, 1.0f,
				1.0f, 1.0f,
				1.0f, 0.0f,	
&nbsp;
				<span class="co1">// Back face </span>
				0.0f, 0.0f, 				
				0.0f, 1.0f,
				1.0f, 0.0f,
				0.0f, 1.0f,
				1.0f, 1.0f,
				1.0f, 0.0f,	
&nbsp;
				<span class="co1">// Left face </span>
				0.0f, 0.0f, 				
				0.0f, 1.0f,
				1.0f, 0.0f,
				0.0f, 1.0f,
				1.0f, 1.0f,
				1.0f, 0.0f,	
&nbsp;
				<span class="co1">// Top face </span>
				0.0f, 0.0f, 				
				0.0f, 1.0f,
				1.0f, 0.0f,
				0.0f, 1.0f,
				1.0f, 1.0f,
				1.0f, 0.0f,	
&nbsp;
				<span class="co1">// Bottom face </span>
				0.0f, 0.0f, 				
				0.0f, 1.0f,
				1.0f, 0.0f,
				0.0f, 1.0f,
				1.0f, 1.0f,
				1.0f, 0.0f
		<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Initialize the buffers.</span>
		mCubePositions <span class="sy0">=</span> ByteBuffer.<span class="me1">allocateDirect</span><span class="br0">&#40;</span>cubePositionData.<span class="me1">length</span> <span class="sy0">*</span> mBytesPerFloat<span class="br0">&#41;</span>
        .<span class="me1">order</span><span class="br0">&#40;</span>ByteOrder.<span class="me1">nativeOrder</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>.<span class="me1">asFloatBuffer</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>							
		mCubePositions.<span class="me1">put</span><span class="br0">&#40;</span>cubePositionData<span class="br0">&#41;</span>.<span class="me1">position</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>		
&nbsp;
		mCubeColors <span class="sy0">=</span> ByteBuffer.<span class="me1">allocateDirect</span><span class="br0">&#40;</span>cubeColorData.<span class="me1">length</span> <span class="sy0">*</span> mBytesPerFloat<span class="br0">&#41;</span>
        .<span class="me1">order</span><span class="br0">&#40;</span>ByteOrder.<span class="me1">nativeOrder</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>.<span class="me1">asFloatBuffer</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>							
		mCubeColors.<span class="me1">put</span><span class="br0">&#40;</span>cubeColorData<span class="br0">&#41;</span>.<span class="me1">position</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		mCubeNormals <span class="sy0">=</span> ByteBuffer.<span class="me1">allocateDirect</span><span class="br0">&#40;</span>cubeNormalData.<span class="me1">length</span> <span class="sy0">*</span> mBytesPerFloat<span class="br0">&#41;</span>
        .<span class="me1">order</span><span class="br0">&#40;</span>ByteOrder.<span class="me1">nativeOrder</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>.<span class="me1">asFloatBuffer</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>							
		mCubeNormals.<span class="me1">put</span><span class="br0">&#40;</span>cubeNormalData<span class="br0">&#41;</span>.<span class="me1">position</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		mCubeTextureCoordinates <span class="sy0">=</span> ByteBuffer.<span class="me1">allocateDirect</span><span class="br0">&#40;</span>cubeTextureCoordinateData.<span class="me1">length</span> <span class="sy0">*</span> mBytesPerFloat<span class="br0">&#41;</span>
		.<span class="me1">order</span><span class="br0">&#40;</span>ByteOrder.<span class="me1">nativeOrder</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>.<span class="me1">asFloatBuffer</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		mCubeTextureCoordinates.<span class="me1">put</span><span class="br0">&#40;</span>cubeTextureCoordinateData<span class="br0">&#41;</span>.<span class="me1">position</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw1">protected</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> getVertexShader<span class="br0">&#40;</span><span class="br0">&#41;</span>
	<span class="br0">&#123;</span>
		<span class="kw1">return</span> RawResourceReader.<span class="me1">readTextFileFromRawResource</span><span class="br0">&#40;</span>mActivityContext, R.<span class="me1">raw</span>.<span class="me1">per_pixel_vertex_shader</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw1">protected</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> getFragmentShader<span class="br0">&#40;</span><span class="br0">&#41;</span>
	<span class="br0">&#123;</span>
		<span class="kw1">return</span> RawResourceReader.<span class="me1">readTextFileFromRawResource</span><span class="br0">&#40;</span>mActivityContext, R.<span class="me1">raw</span>.<span class="me1">per_pixel_fragment_shader</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	@Override
	<span class="kw1">public</span> <span class="kw4">void</span> onSurfaceCreated<span class="br0">&#40;</span>GL10 glUnused, EGLConfig config<span class="br0">&#41;</span> 
	<span class="br0">&#123;</span>
		<span class="co1">// Set the background clear color to black.</span>
		GLES20.<span class="me1">glClearColor</span><span class="br0">&#40;</span>0.0f, 0.0f, 0.0f, 0.0f<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Use culling to remove back faces.</span>
		GLES20.<span class="me1">glEnable</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_CULL_FACE</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Enable depth testing</span>
		GLES20.<span class="me1">glEnable</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_DEPTH_TEST</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// The below glEnable() call is a holdover from OpenGL ES 1, and is not needed in OpenGL ES 2.</span>
		<span class="co1">// Enable texture mapping</span>
		<span class="co1">// GLES20.glEnable(GLES20.GL_TEXTURE_2D);</span>
&nbsp;
		<span class="co1">// Position the eye in front of the origin.</span>
		<span class="kw1">final</span> <span class="kw4">float</span> eyeX <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> eyeY <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> eyeZ <span class="sy0">=</span> <span class="sy0">-</span>0.5f<span class="sy0">;</span>
&nbsp;
		<span class="co1">// We are looking toward the distance</span>
		<span class="kw1">final</span> <span class="kw4">float</span> lookX <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> lookY <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> lookZ <span class="sy0">=</span> <span class="sy0">-</span>5.0f<span class="sy0">;</span>
&nbsp;
		<span class="co1">// Set our up vector. This is where our head would be pointing were we holding the camera.</span>
		<span class="kw1">final</span> <span class="kw4">float</span> upX <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> upY <span class="sy0">=</span> 1.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> upZ <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
&nbsp;
		<span class="co1">// Set the view matrix. This matrix can be said to represent the camera position.</span>
		<span class="co1">// NOTE: In OpenGL 1, a ModelView matrix is used, which is a combination of a model and</span>
		<span class="co1">// view matrix. In OpenGL 2, we can keep track of these matrices separately if we choose.</span>
		Matrix.<span class="me1">setLookAtM</span><span class="br0">&#40;</span>mViewMatrix, <span class="nu0">0</span>, eyeX, eyeY, eyeZ, lookX, lookY, lookZ, upX, upY, upZ<span class="br0">&#41;</span><span class="sy0">;</span>		
&nbsp;
		<span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> vertexShader <span class="sy0">=</span> getVertexShader<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   		
 		<span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> fragmentShader <span class="sy0">=</span> getFragmentShader<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>			
&nbsp;
		<span class="kw1">final</span> <span class="kw4">int</span> vertexShaderHandle <span class="sy0">=</span> ShaderHelper.<span class="me1">compileShader</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_VERTEX_SHADER</span>, vertexShader<span class="br0">&#41;</span><span class="sy0">;</span>		
		<span class="kw1">final</span> <span class="kw4">int</span> fragmentShaderHandle <span class="sy0">=</span> ShaderHelper.<span class="me1">compileShader</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_FRAGMENT_SHADER</span>, fragmentShader<span class="br0">&#41;</span><span class="sy0">;</span>		
&nbsp;
		mProgramHandle <span class="sy0">=</span> ShaderHelper.<span class="me1">createAndLinkProgram</span><span class="br0">&#40;</span>vertexShaderHandle, fragmentShaderHandle, 
				<span class="kw1">new</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a><span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="br0">&#123;</span><span class="st0">&quot;a_Position&quot;</span>,  <span class="st0">&quot;a_Color&quot;</span>, <span class="st0">&quot;a_Normal&quot;</span>, <span class="st0">&quot;a_TexCoordinate&quot;</span><span class="br0">&#125;</span><span class="br0">&#41;</span><span class="sy0">;</span>								                                							       
&nbsp;
        <span class="co1">// Define a simple shader program for our point.</span>
        <span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> pointVertexShader <span class="sy0">=</span> RawResourceReader.<span class="me1">readTextFileFromRawResource</span><span class="br0">&#40;</span>mActivityContext, R.<span class="me1">raw</span>.<span class="me1">point_vertex_shader</span><span class="br0">&#41;</span><span class="sy0">;</span>        	       
        <span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> pointFragmentShader <span class="sy0">=</span> RawResourceReader.<span class="me1">readTextFileFromRawResource</span><span class="br0">&#40;</span>mActivityContext, R.<span class="me1">raw</span>.<span class="me1">point_fragment_shader</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="kw1">final</span> <span class="kw4">int</span> pointVertexShaderHandle <span class="sy0">=</span> ShaderHelper.<span class="me1">compileShader</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_VERTEX_SHADER</span>, pointVertexShader<span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw1">final</span> <span class="kw4">int</span> pointFragmentShaderHandle <span class="sy0">=</span> ShaderHelper.<span class="me1">compileShader</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_FRAGMENT_SHADER</span>, pointFragmentShader<span class="br0">&#41;</span><span class="sy0">;</span>
        mPointProgramHandle <span class="sy0">=</span> ShaderHelper.<span class="me1">createAndLinkProgram</span><span class="br0">&#40;</span>pointVertexShaderHandle, pointFragmentShaderHandle, 
        		<span class="kw1">new</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a><span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="br0">&#123;</span><span class="st0">&quot;a_Position&quot;</span><span class="br0">&#125;</span><span class="br0">&#41;</span><span class="sy0">;</span> 
&nbsp;
        <span class="co1">// Load the texture</span>
        mTextureDataHandle <span class="sy0">=</span> TextureHelper.<span class="me1">loadTexture</span><span class="br0">&#40;</span>mActivityContext, R.<span class="me1">drawable</span>.<span class="me1">bumpy_bricks_public_domain</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>	
&nbsp;
	@Override
	<span class="kw1">public</span> <span class="kw4">void</span> onSurfaceChanged<span class="br0">&#40;</span>GL10 glUnused, <span class="kw4">int</span> width, <span class="kw4">int</span> height<span class="br0">&#41;</span> 
	<span class="br0">&#123;</span>
		<span class="co1">// Set the OpenGL viewport to the same size as the surface.</span>
		GLES20.<span class="me1">glViewport</span><span class="br0">&#40;</span><span class="nu0">0</span>, <span class="nu0">0</span>, width, height<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Create a new perspective projection matrix. The height will stay the same</span>
		<span class="co1">// while the width will vary as per aspect ratio.</span>
		<span class="kw1">final</span> <span class="kw4">float</span> ratio <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">float</span><span class="br0">&#41;</span> width <span class="sy0">/</span> height<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> left <span class="sy0">=</span> <span class="sy0">-</span>ratio<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> right <span class="sy0">=</span> ratio<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> bottom <span class="sy0">=</span> <span class="sy0">-</span>1.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> top <span class="sy0">=</span> 1.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> near <span class="sy0">=</span> 1.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> far <span class="sy0">=</span> 10.0f<span class="sy0">;</span>
&nbsp;
		Matrix.<span class="me1">frustumM</span><span class="br0">&#40;</span>mProjectionMatrix, <span class="nu0">0</span>, left, right, bottom, top, near, far<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>	
&nbsp;
	@Override
	<span class="kw1">public</span> <span class="kw4">void</span> onDrawFrame<span class="br0">&#40;</span>GL10 glUnused<span class="br0">&#41;</span> 
	<span class="br0">&#123;</span>
		GLES20.<span class="me1">glClear</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_COLOR_BUFFER_BIT</span> <span class="sy0">|</span> GLES20.<span class="me1">GL_DEPTH_BUFFER_BIT</span><span class="br0">&#41;</span><span class="sy0">;</span>			        
&nbsp;
        <span class="co1">// Do a complete rotation every 10 seconds.</span>
        <span class="kw4">long</span> time <span class="sy0">=</span> SystemClock.<span class="me1">uptimeMillis</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">%</span> 10000L<span class="sy0">;</span>        
        <span class="kw4">float</span> angleInDegrees <span class="sy0">=</span> <span class="br0">&#40;</span>360.0f <span class="sy0">/</span> 10000.0f<span class="br0">&#41;</span> <span class="sy0">*</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> time<span class="br0">&#41;</span><span class="sy0">;</span>                
&nbsp;
        <span class="co1">// Set our per-vertex lighting program.</span>
        GLES20.<span class="me1">glUseProgram</span><span class="br0">&#40;</span>mProgramHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Set program handles for cube drawing.</span>
        mMVPMatrixHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetUniformLocation</span><span class="br0">&#40;</span>mProgramHandle, <span class="st0">&quot;u_MVPMatrix&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        mMVMatrixHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetUniformLocation</span><span class="br0">&#40;</span>mProgramHandle, <span class="st0">&quot;u_MVMatrix&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> 
        mLightPosHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetUniformLocation</span><span class="br0">&#40;</span>mProgramHandle, <span class="st0">&quot;u_LightPos&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        mTextureUniformHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetUniformLocation</span><span class="br0">&#40;</span>mProgramHandle, <span class="st0">&quot;u_Texture&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        mPositionHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetAttribLocation</span><span class="br0">&#40;</span>mProgramHandle, <span class="st0">&quot;a_Position&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        mColorHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetAttribLocation</span><span class="br0">&#40;</span>mProgramHandle, <span class="st0">&quot;a_Color&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        mNormalHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetAttribLocation</span><span class="br0">&#40;</span>mProgramHandle, <span class="st0">&quot;a_Normal&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> 
        mTextureCoordinateHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetAttribLocation</span><span class="br0">&#40;</span>mProgramHandle, <span class="st0">&quot;a_TexCoordinate&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Set the active texture unit to texture unit 0.</span>
        GLES20.<span class="me1">glActiveTexture</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_TEXTURE0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Bind the texture to this unit.</span>
        GLES20.<span class="me1">glBindTexture</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_TEXTURE_2D</span>, mTextureDataHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Tell the texture uniform sampler to use this texture in the shader by binding to texture unit 0.</span>
        GLES20.<span class="me1">glUniform1i</span><span class="br0">&#40;</span>mTextureUniformHandle, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>        
&nbsp;
        <span class="co1">// Calculate position of the light. Rotate and then push into the distance.</span>
        Matrix.<span class="me1">setIdentityM</span><span class="br0">&#40;</span>mLightModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">translateM</span><span class="br0">&#40;</span>mLightModelMatrix, <span class="nu0">0</span>, 0.0f, 0.0f, <span class="sy0">-</span>5.0f<span class="br0">&#41;</span><span class="sy0">;</span>      
        Matrix.<span class="me1">rotateM</span><span class="br0">&#40;</span>mLightModelMatrix, <span class="nu0">0</span>, angleInDegrees, 0.0f, 1.0f, 0.0f<span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">translateM</span><span class="br0">&#40;</span>mLightModelMatrix, <span class="nu0">0</span>, 0.0f, 0.0f, 2.0f<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        Matrix.<span class="me1">multiplyMV</span><span class="br0">&#40;</span>mLightPosInWorldSpace, <span class="nu0">0</span>, mLightModelMatrix, <span class="nu0">0</span>, mLightPosInModelSpace, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">multiplyMV</span><span class="br0">&#40;</span>mLightPosInEyeSpace, <span class="nu0">0</span>, mViewMatrix, <span class="nu0">0</span>, mLightPosInWorldSpace, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>                        
&nbsp;
        <span class="co1">// Draw some cubes.        </span>
        Matrix.<span class="me1">setIdentityM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">translateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, 4.0f, 0.0f, <span class="sy0">-</span>7.0f<span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">rotateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, angleInDegrees, 1.0f, 0.0f, 0.0f<span class="br0">&#41;</span><span class="sy0">;</span>        
        drawCube<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        Matrix.<span class="me1">setIdentityM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">translateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, <span class="sy0">-</span>4.0f, 0.0f, <span class="sy0">-</span>7.0f<span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">rotateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, angleInDegrees, 0.0f, 1.0f, 0.0f<span class="br0">&#41;</span><span class="sy0">;</span>        
        drawCube<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        Matrix.<span class="me1">setIdentityM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">translateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, 0.0f, 4.0f, <span class="sy0">-</span>7.0f<span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">rotateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, angleInDegrees, 0.0f, 0.0f, 1.0f<span class="br0">&#41;</span><span class="sy0">;</span>        
        drawCube<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        Matrix.<span class="me1">setIdentityM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">translateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, 0.0f, <span class="sy0">-</span>4.0f, <span class="sy0">-</span>7.0f<span class="br0">&#41;</span><span class="sy0">;</span>
        drawCube<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        Matrix.<span class="me1">setIdentityM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">translateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, 0.0f, 0.0f, <span class="sy0">-</span>5.0f<span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">rotateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, angleInDegrees, 1.0f, 1.0f, 0.0f<span class="br0">&#41;</span><span class="sy0">;</span>        
        drawCube<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>      
&nbsp;
        <span class="co1">// Draw a point to indicate the light.</span>
        GLES20.<span class="me1">glUseProgram</span><span class="br0">&#40;</span>mPointProgramHandle<span class="br0">&#41;</span><span class="sy0">;</span>        
        drawLight<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>				
&nbsp;
	<span class="co3">/**
	 * Draws a cube.
	 */</span>			
	<span class="kw1">private</span> <span class="kw4">void</span> drawCube<span class="br0">&#40;</span><span class="br0">&#41;</span>
	<span class="br0">&#123;</span>		
		<span class="co1">// Pass in the position information</span>
		mCubePositions.<span class="me1">position</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>		
        GLES20.<span class="me1">glVertexAttribPointer</span><span class="br0">&#40;</span>mPositionHandle, mPositionDataSize, GLES20.<span class="me1">GL_FLOAT</span>, <span class="kw2">false</span>,
        		<span class="nu0">0</span>, mCubePositions<span class="br0">&#41;</span><span class="sy0">;</span>        
&nbsp;
        GLES20.<span class="me1">glEnableVertexAttribArray</span><span class="br0">&#40;</span>mPositionHandle<span class="br0">&#41;</span><span class="sy0">;</span>        
&nbsp;
        <span class="co1">// Pass in the color information</span>
        mCubeColors.<span class="me1">position</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        GLES20.<span class="me1">glVertexAttribPointer</span><span class="br0">&#40;</span>mColorHandle, mColorDataSize, GLES20.<span class="me1">GL_FLOAT</span>, <span class="kw2">false</span>,
        		<span class="nu0">0</span>, mCubeColors<span class="br0">&#41;</span><span class="sy0">;</span>        
&nbsp;
        GLES20.<span class="me1">glEnableVertexAttribArray</span><span class="br0">&#40;</span>mColorHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Pass in the normal information</span>
        mCubeNormals.<span class="me1">position</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        GLES20.<span class="me1">glVertexAttribPointer</span><span class="br0">&#40;</span>mNormalHandle, mNormalDataSize, GLES20.<span class="me1">GL_FLOAT</span>, <span class="kw2">false</span>, 
        		<span class="nu0">0</span>, mCubeNormals<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        GLES20.<span class="me1">glEnableVertexAttribArray</span><span class="br0">&#40;</span>mNormalHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Pass in the texture coordinate information</span>
        mCubeTextureCoordinates.<span class="me1">position</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        GLES20.<span class="me1">glVertexAttribPointer</span><span class="br0">&#40;</span>mTextureCoordinateHandle, mTextureCoordinateDataSize, GLES20.<span class="me1">GL_FLOAT</span>, <span class="kw2">false</span>, 
        		<span class="nu0">0</span>, mCubeTextureCoordinates<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        GLES20.<span class="me1">glEnableVertexAttribArray</span><span class="br0">&#40;</span>mTextureCoordinateHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// This multiplies the view matrix by the model matrix, and stores the result in the MVP matrix</span>
        <span class="co1">// (which currently contains model * view).</span>
        Matrix.<span class="me1">multiplyMM</span><span class="br0">&#40;</span>mMVPMatrix, <span class="nu0">0</span>, mViewMatrix, <span class="nu0">0</span>, mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>   
&nbsp;
        <span class="co1">// Pass in the modelview matrix.</span>
        GLES20.<span class="me1">glUniformMatrix4fv</span><span class="br0">&#40;</span>mMVMatrixHandle, <span class="nu0">1</span>, <span class="kw2">false</span>, mMVPMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>                
&nbsp;
        <span class="co1">// This multiplies the modelview matrix by the projection matrix, and stores the result in the MVP matrix</span>
        <span class="co1">// (which now contains model * view * projection).</span>
        Matrix.<span class="me1">multiplyMM</span><span class="br0">&#40;</span>mMVPMatrix, <span class="nu0">0</span>, mProjectionMatrix, <span class="nu0">0</span>, mMVPMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Pass in the combined matrix.</span>
        GLES20.<span class="me1">glUniformMatrix4fv</span><span class="br0">&#40;</span>mMVPMatrixHandle, <span class="nu0">1</span>, <span class="kw2">false</span>, mMVPMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Pass in the light position in eye space.        </span>
        GLES20.<span class="me1">glUniform3f</span><span class="br0">&#40;</span>mLightPosHandle, mLightPosInEyeSpace<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>, mLightPosInEyeSpace<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span>, mLightPosInEyeSpace<span class="br0">&#91;</span><span class="nu0">2</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Draw the cube.</span>
        GLES20.<span class="me1">glDrawArrays</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_TRIANGLES</span>, <span class="nu0">0</span>, <span class="nu0">36</span><span class="br0">&#41;</span><span class="sy0">;</span>                               
	<span class="br0">&#125;</span>	
&nbsp;
	<span class="co3">/**
	 * Draws a point representing the position of the light.
	 */</span>
	<span class="kw1">private</span> <span class="kw4">void</span> drawLight<span class="br0">&#40;</span><span class="br0">&#41;</span>
	<span class="br0">&#123;</span>
		<span class="kw1">final</span> <span class="kw4">int</span> pointMVPMatrixHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetUniformLocation</span><span class="br0">&#40;</span>mPointProgramHandle, <span class="st0">&quot;u_MVPMatrix&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw1">final</span> <span class="kw4">int</span> pointPositionHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetAttribLocation</span><span class="br0">&#40;</span>mPointProgramHandle, <span class="st0">&quot;a_Position&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Pass in the position.</span>
		GLES20.<span class="me1">glVertexAttrib3f</span><span class="br0">&#40;</span>pointPositionHandle, mLightPosInModelSpace<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>, mLightPosInModelSpace<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span>, mLightPosInModelSpace<span class="br0">&#91;</span><span class="nu0">2</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Since we are not using a buffer object, disable vertex arrays for this attribute.</span>
        GLES20.<span class="me1">glDisableVertexAttribArray</span><span class="br0">&#40;</span>pointPositionHandle<span class="br0">&#41;</span><span class="sy0">;</span>  
&nbsp;
		<span class="co1">// Pass in the transformation matrix.</span>
		Matrix.<span class="me1">multiplyMM</span><span class="br0">&#40;</span>mMVPMatrix, <span class="nu0">0</span>, mViewMatrix, <span class="nu0">0</span>, mLightModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
		Matrix.<span class="me1">multiplyMM</span><span class="br0">&#40;</span>mMVPMatrix, <span class="nu0">0</span>, mProjectionMatrix, <span class="nu0">0</span>, mMVPMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
		GLES20.<span class="me1">glUniformMatrix4fv</span><span class="br0">&#40;</span>pointMVPMatrixHandle, <span class="nu0">1</span>, <span class="kw2">false</span>, mMVPMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Draw the point.</span>
		GLES20.<span class="me1">glDrawArrays</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_POINTS</span>, <span class="nu0">0</span>, <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
