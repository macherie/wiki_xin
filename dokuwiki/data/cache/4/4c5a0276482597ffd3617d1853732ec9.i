a:151:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:6:"概述";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:83:"音乐模块主要有4个分类界面，通过Tabhost来实现界面间的切换。";}i:2;i:20;}i:5;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:103;}i:6;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:103;}i:7;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:103;}i:8;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:103;}i:9;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:" TrackBrowserActivity.java                歌曲列表界面";}i:2;i:107;}i:10;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:167;}i:11;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:167;}i:12;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:167;}i:13;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:167;}i:14;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:" PlaylistBrowserActivity.java             播放列表界面";}i:2;i:171;}i:15;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:231;}i:16;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:231;}i:17;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:231;}i:18;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:231;}i:19;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:" AlbumBrowserActivity.java                专辑浏览界面";}i:2;i:235;}i:20;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:295;}i:21;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:295;}i:22;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:295;}i:23;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:295;}i:24;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:63:" ArtistAlbumBrowserActivity.java          艺术家浏览界面";}i:2;i:299;}i:25;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:362;}i:26;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:362;}i:27;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:362;}i:28;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:362;}i:29;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:48:"其中音乐模块中最重要的两个类如下";}i:2;i:363;}i:30;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:411;}i:31;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:411;}i:32;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:411;}i:33;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:411;}i:34;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:" MediaPlayerbackActivity.java             音乐播放界面";}i:2;i:415;}i:35;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:475;}i:36;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:475;}i:37;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:475;}i:38;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:475;}i:39;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:63:" MediaPlaybackService.java                音乐播放器服务";}i:2;i:479;}i:40;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:542;}i:41;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:542;}i:42;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:542;}i:43;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:542;}i:44;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:51:"音乐模块中比较重要的两个工具类如下";}i:2;i:543;}i:45;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:594;}i:46;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:594;}i:47;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:594;}i:48;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:594;}i:49;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:108:" MusicPicker.java                         音乐选择界面，这是给其它应用程序调用的界面。";}i:2;i:598;}i:50;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:706;}i:51;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:706;}i:52;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:706;}i:53;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:706;}i:54;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:66:" MusicUtils.java                          播放器公共方法类";}i:2;i:710;}i:55;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:776;}i:56;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:776;}i:57;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:776;}i:58;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:777;}i:59;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:12:"程序启动";i:1;i:1;i:2;i:777;}i:2;i:777;}i:60;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:777;}i:61;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:777;}i:62;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:317:"音乐模块的程序入口是MusicBrowserActivity.java。在该类中读取Shareprefence中的参数判断进入到音乐模块中的具体某个分类界面中。因此音乐模块具有记录功能，记录上次用户是在哪个界面退出应用的，在下次进入时之间展现用户上次所在的界面。";}i:2;i:802;}i:63;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1125;}i:64;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:362:"
     int activeTab = MusicUtils.getIntPref(this, "activetab", R.id.artisttab);
        if (activeTab != R.id.artisttab
                && activeTab != R.id.albumtab
                && activeTab != R.id.songtab
                && activeTab != R.id.playlisttab) {
            activeTab = R.id.artisttab;
        }
        MusicUtils.activateTab(this, activeTab);
";i:1;s:4:"java";i:2;N;}i:2;i:1125;}i:65;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:952:"
    static void activateTab(Activity a, int id) {
        Intent intent = new Intent(Intent.ACTION_PICK);
        switch (id) {
            case R.id.artisttab:
                intent.setDataAndType(Uri.EMPTY, "vnd.android.cursor.dir/artistalbum");
                break;
            case R.id.albumtab:
                intent.setDataAndType(Uri.EMPTY, "vnd.android.cursor.dir/album");
                break;
            case R.id.songtab:
                intent.setDataAndType(Uri.EMPTY, "vnd.android.cursor.dir/track");
                break;
            case R.id.playlisttab:
                intent.setDataAndType(Uri.EMPTY, MediaStore.Audio.Playlists.CONTENT_TYPE);
                break;
            default:
                return;
        }
        intent.putExtra("withtabs", true);
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
        a.startActivity(intent);
        a.finish();
        a.overridePendingTransition(0, 0);
    }
";i:1;s:4:"java";i:2;N;}i:2;i:1506;}i:66;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2472;}i:67;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:18:"歌曲列表界面";i:1;i:1;i:2;i:2472;}i:2;i:2472;}i:68;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:2472;}i:69;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2472;}i:70;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:191:"音乐列表界面的展示是由TrackBrowserActivity.java类来实现的，该类实现了ServiceConnection接口。在onCreate方法中对变量及页面组件进行初始化工作，其中";}i:2;i:2503;}i:71;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2700;}i:72;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:52:"
    mToken = MusicUtils.bindToService(this, this);
";i:1;s:4:"java";i:2;N;}i:2;i:2700;}i:73;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2700;}i:74;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:125:"代码段将TrackBrowserActivity.java这个Activity绑定到MediaPlaybackService.java这个Service上，具体代码如下：";}i:2;i:2766;}i:75;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2897;}i:76;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:682:"
     public static ServiceToken bindToService(Activity context, ServiceConnection callback) {
        Activity realActivity = context.getParent();
        if (realActivity == null) {
            realActivity = context;
        }
        ContextWrapper cw = new ContextWrapper(realActivity);
        cw.startService(new Intent(cw, MediaPlaybackService.class));
        ServiceBinder sb = new ServiceBinder(callback);
        if (cw.bindService((new Intent()).setClass(cw, MediaPlaybackService.class), sb, 0)) {
            sConnectionMap.put(cw, sb);
            return new ServiceToken(cw);
        }
        Log.e("Music", "Failed to bind to service");
        return null;
    }
";i:1;s:4:"java";i:2;N;}i:2;i:2897;}i:77;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2897;}i:78;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:126:"对bindService返回的IBinder对象处理的类ServiceBinder，其方法实际上仍是调用TrackBrowserActivity类的方法";}i:2;i:3593;}i:79;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3725;}i:80;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:773:"
    private static class ServiceBinder implements ServiceConnection {
        ServiceConnection mCallback;
        ServiceBinder(ServiceConnection callback) {
            mCallback = callback;
        }
        
        public void onServiceConnected(ComponentName className, android.os.IBinder service) {
            sService = IMediaPlaybackService.Stub.asInterface(service);
            initAlbumArtCache();
            if (mCallback != null) {
                mCallback.onServiceConnected(className, service);
            }
        }
        
        public void onServiceDisconnected(ComponentName className) {
            if (mCallback != null) {
                mCallback.onServiceDisconnected(className);
            }
            sService = null;
        }
    }
";i:1;s:4:"java";i:2;N;}i:2;i:3725;}i:81;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3725;}i:82;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:114:"ServiceBinder类的onServiceConnected方法实际上是调用TrackBrowserActivity类中的onServiceConnected方法";}i:2;i:4512;}i:83;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4632;}i:84;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:1979:"
    public void onServiceConnected(ComponentName name, IBinder service)
    {
        IntentFilter f = new IntentFilter();
        f.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);
        f.addAction(Intent.ACTION_MEDIA_SCANNER_FINISHED);
        f.addAction(Intent.ACTION_MEDIA_UNMOUNTED);
        f.addDataScheme("file");
        registerReceiver(mScanListener, f);

        if (mAdapter == null) {
            //Log.i("@@@", "starting query");
            mAdapter = new TrackListAdapter(
                    getApplication(), // need to use application context to avoid leaks
                    this,
                    mEditMode ? R.layout.edit_track_list_item : R.layout.track_list_item,
                    null, // cursor
                    new String[] {},
                    new int[] {},
                    "nowplaying".equals(mPlaylist),
                    mPlaylist != null &&
                    !(mPlaylist.equals("podcasts") || mPlaylist.equals("recentlyadded")));
            setListAdapter(mAdapter);
            setTitle(R.string.working_songs);
            getTrackCursor(mAdapter.getQueryHandler(), null, true);
        } else {
            mTrackCursor = mAdapter.getCursor();
            // If mTrackCursor is null, this can be because it doesn't have
            // a cursor yet (because the initial query that sets its cursor
            // is still in progress), or because the query failed.
            // In order to not flash the error dialog at the user for the
            // first case, simply retry the query when the cursor is null.
            // Worst case, we end up doing the same query twice.
            if (mTrackCursor != null) {
                init(mTrackCursor, false);
            } else {
                setTitle(R.string.working_songs);
                getTrackCursor(mAdapter.getQueryHandler(), null, true);
            }
        }
        if (!mEditMode) {
            MusicUtils.updateNowPlaying(this);
        }
    }
";i:1;s:4:"java";i:2;N;}i:2;i:4632;}i:85;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4632;}i:86;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:314:"其中getTrackCursor(mAdapter.getQueryHandler(), null, true);方法实现对音乐播放列表的刷新与显示操作,该方法中uri是查询链接，mSortOrder是对查询结果排序，where是查询条件，具体的查询动作是由TrackQueryHandler类型的变量queryhandler的doQuery方法来实现的。";}i:2;i:6625;}i:87;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6945;}i:88;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:4388:"
    private Cursor getTrackCursor(TrackListAdapter.TrackQueryHandler queryhandler, String filter,
            boolean async) {

        if (queryhandler == null) {
            throw new IllegalArgumentException();
        }

        Cursor ret = null;
        mSortOrder = MediaStore.Audio.Media.TITLE_KEY;
        StringBuilder where = new StringBuilder();
        where.append(MediaStore.Audio.Media.TITLE + " != ''");

        if (mGenre != null) {
            Uri uri = MediaStore.Audio.Genres.Members.getContentUri("external",
                    Integer.valueOf(mGenre));
            if (!TextUtils.isEmpty(filter)) {
                uri = uri.buildUpon().appendQueryParameter("filter", Uri.encode(filter)).build();
            }
            mSortOrder = MediaStore.Audio.Genres.Members.DEFAULT_SORT_ORDER;
            ret = queryhandler.doQuery(uri,
                    mCursorCols, where.toString(), null, mSortOrder, async);
        } else if (mPlaylist != null) {
            if (mPlaylist.equals("nowplaying")) {
                if (MusicUtils.sService != null) {
                    ret = new NowPlayingCursor(MusicUtils.sService, mCursorCols);
                    if (ret.getCount() == 0) {
                        finish();
                    }
                } else {
                    // Nothing is playing.
                }
            } else if (mPlaylist.equals("podcasts")) {
                where.append(" AND " + MediaStore.Audio.Media.IS_PODCAST + "=1");
                Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
                if (!TextUtils.isEmpty(filter)) {
                    uri = uri.buildUpon().appendQueryParameter("filter", Uri.encode(filter)).build();
                }
                ret = queryhandler.doQuery(uri,
                        mCursorCols, where.toString(), null,
                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);
            } else if (mPlaylist.equals("recentlyadded")) {
                // do a query for all songs added in the last X weeks
                Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
                if (!TextUtils.isEmpty(filter)) {
                    uri = uri.buildUpon().appendQueryParameter("filter", Uri.encode(filter)).build();
                }
                int X = MusicUtils.getIntPref(this, "numweeks", 2) * (3600 * 24 * 7);
                where.append(" AND " + MediaStore.MediaColumns.DATE_ADDED + ">");
                where.append(System.currentTimeMillis() / 1000 - X);
                ret = queryhandler.doQuery(uri,
                        mCursorCols, where.toString(), null,
                        MediaStore.Audio.Media.DEFAULT_SORT_ORDER, async);
            } else {
                Uri uri = MediaStore.Audio.Playlists.Members.getContentUri("external",
                        Long.valueOf(mPlaylist));
                if (!TextUtils.isEmpty(filter)) {
                    uri = uri.buildUpon().appendQueryParameter("filter", Uri.encode(filter)).build();
                }
                mSortOrder = MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER;
                ret = queryhandler.doQuery(uri, mPlaylistMemberCols,
                        where.toString(), null, mSortOrder, async);
            }
        } else {
            if (mAlbumId != null) {
                where.append(" AND " + MediaStore.Audio.Media.ALBUM_ID + "=" + mAlbumId);
                mSortOrder = MediaStore.Audio.Media.TRACK + ", " + mSortOrder;
            }
            if (mArtistId != null) {
                where.append(" AND " + MediaStore.Audio.Media.ARTIST_ID + "=" + mArtistId);
            }
            where.append(" AND " + MediaStore.Audio.Media.IS_MUSIC + "=1");
            Uri uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
            if (!TextUtils.isEmpty(filter)) {
                uri = uri.buildUpon().appendQueryParameter("filter", Uri.encode(filter)).build();
            }
            ret = queryhandler.doQuery(uri,
                    mCursorCols, where.toString() , null, mSortOrder, async);
        }
        
        // This special case is for the "nowplaying" cursor, which cannot be handled
        // asynchronously using AsyncQueryHandler, so we do some extra initialization here.
        if (ret != null && async) {
            init(ret, false);
            setTitle();
        }
        return ret;
    }
";i:1;s:4:"java";i:2;N;}i:2;i:6945;}i:89;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6945;}i:90;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:180:"TrackQueryHandler类型的变量queryhandler的doQuery方法返回的查询结果是Cursor对象，更新adapter刷新界面显示信息的操作是有init(ret, false);来实现的";}i:2;i:11347;}i:91;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11533;}i:92;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:309:"
    public void init(Cursor newCursor, boolean isLimited) {

        if (mAdapter == null) {
            mDataAvailable = false;
            return;
        }
        mAdapter.changeCursor(newCursor); // also sets mTrackCursor
        String status = Environment.getExternalStorageState();
        ...
    }
";i:1;s:4:"java";i:2;N;}i:2;i:11533;}i:93;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11533;}i:94;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:133:"音乐列表显示的TouchInterceptor是继承自ListView的自定义组件，其每个Item被点击后会跳转到音乐播放界面";}i:2;i:11856;}i:95;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11995;}i:96;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:1311:"
    protected void onListItemClick(ListView l, View v, int position, long id)
    {
        if ((mTrackCursor == null) || (mTrackCursor.getCount() == 0)) {
            return;
        }
        // When selecting a track from the queue, just jump there instead of
        // reloading the queue. This is both faster, and prevents accidentally
        // dropping out of party shuffle.
        if (mTrackCursor instanceof NowPlayingCursor) {
            if (MusicUtils.sService != null) {
                try {
                    MusicUtils.sService.setQueuePosition(position);
                    return;
                } catch (RemoteException ex) {
                }
            }
        }
        if(getSongDuration(mTrackCursor) > 1200){
            PlayTask task = new PlayTask(this);
            task.execute(position);
        } else {
            MusicUtils.playAll(this, mTrackCursor, position);
            if (mEditMode && !mPlaylist.equals("nowplaying")) {
                MusicUtils.setPlayListId(Long.valueOf(mPlaylist));
            }
            if(mEditMode && !mPlaylist.equals("nowplaying") && !mPlaylist.equals("podcasts")
                    && !mPlaylist.equals("recentlyadded")) {
                MusicUtils.REAL_PLAYLIST_ID = Integer.valueOf(mPlaylist);
            }
        }
    }
";i:1;s:4:"java";i:2;N;}i:2;i:11995;}i:97;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11995;}i:98;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:124:"task.execute(position);方法执行的动作主要如下，与 MusicUtils.playAll(this, mTrackCursor, position);方法类似";}i:2;i:13320;}i:99;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13450;}i:100;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:195:"
    protected Void doInBackground(Integer... params) {
            int position = params[0];
            MusicUtils.playAll(mContext, mTrackCursor, position);
            return null;
        }
";i:1;s:4:"java";i:2;N;}i:2;i:13450;}i:101;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13450;}i:102;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:81:"MusicUtils.playAll方法是具体进入音乐播放页面的功能实现承担者";}i:2;i:13659;}i:103;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13746;}i:104;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:2657:"
    private static void playAll(Context context, long [] list, int position, boolean force_shuffle) {
      try{
           IVideoTelephony vtInterface = null;
           vtInterface = IVideoTelephony.Stub.asInterface(ServiceManager.checkService("videophone"));
          if(vtInterface != null) {
             if (vtInterface.isVtActive()) {
                Toast.makeText(context, R.string.vt_playback_failed, Toast.LENGTH_SHORT).show();
                return;
            }
         }
       } catch (RemoteException e){

       }

        if (list.length == 0 || sService == null) {
            Log.d("MusicUtils", "attempt to play empty song list");
            // Don't try to play empty playlists. Nothing good will come of it.
            String message = context.getString(R.string.emptyplaylist, list.length);
            Toast.makeText(context, message, Toast.LENGTH_SHORT).show();
            return;
        }
        try {
            if (force_shuffle) {
                sService.setShuffleMode(MediaPlaybackService.SHUFFLE_NORMAL);
                //If the repeat mode is REPEAT_CURRENT, we should change mode to REPEAT_ALL
                if (sService.getRepeatMode() == MediaPlaybackService.REPEAT_CURRENT) {
                    sService.setRepeatMode(MediaPlaybackService.REPEAT_ALL);
                }
            }
            if (mPlayAllFromMenu){
                sService.setShuffleMode(MediaPlaybackService.SHUFFLE_NONE);
                mPlayAllFromMenu = false;
            }
            long curid = sService.getAudioId();
            int curpos = sService.getQueuePosition();
            if (position != -1 && curpos == position && curid == list[position]) {
                // The selected file is the file that's currently playing;
                // figure out if we need to restart with a new playlist,
                // or just launch the playback activity.
                long [] playlist = sService.getQueue();
                if (Arrays.equals(list, playlist)) {
                    // we don't need to set a new list, but we should resume playback if needed
                    sService.play();
                    return; // the 'finally' block will still run
                }
            }
            if (position < 0) {
                position = 0;
            }
            sService.open(list, force_shuffle ? -1 : position);
            sService.play();
        } catch (RemoteException ex) {
        } finally {
            Intent intent = new Intent("com.android.music.PLAYBACK_VIEWER")
                .setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
            context.startActivity(intent);
        }
    }
";i:1;s:4:"java";i:2;N;}i:2;i:13746;}i:105;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:16417;}i:106;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:18:"其余三个界面";i:1;i:1;i:2;i:16417;}i:2;i:16417;}i:107;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:16417;}i:108;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16417;}i:109;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:442:"播放列表界面是由PlaylistBrowserActivity来呈现，专辑浏览界面是有AlbumBrowserActivity来呈现，艺术家浏览界面是由ArtistAlbumBrowserActivity来呈现。这三个界面内部功能的实现方式与歌曲列表界面TrackBrowserActivity大体一致，主要的区别就是在执行异步查询时的查询链接或查询参数不同。比如PlaylistBrowserActivity在呈现界面时执行的异步查询操作如下";}i:2;i:16448;}i:110;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16896;}i:111;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:1415:"
    private Cursor getPlaylistCursor(AsyncQueryHandler async, String filterstring) {

        StringBuilder where = new StringBuilder();
        where.append(MediaStore.Audio.Playlists.NAME + " != ''");
        
        // Add in the filtering constraints
        String [] keywords = null;
        if (filterstring != null) {
            String [] searchWords = filterstring.split(" ");
            keywords = new String[searchWords.length];
            Collator col = Collator.getInstance();
            col.setStrength(Collator.PRIMARY);
            for (int i = 0; i < searchWords.length; i++) {
                keywords[i] = '%' + searchWords[i] + '%';
            }
            for (int i = 0; i < searchWords.length; i++) {
                where.append(" AND ");
                where.append(MediaStore.Audio.Playlists.NAME + " LIKE ?");
            }
        }
        
        String whereclause = where.toString();
        
        
        if (async != null) {
            async.startQuery(0, null, MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
                    mCols, whereclause, keywords, MediaStore.Audio.Playlists.NAME);
            return null;
        }
        Cursor c = null;
        c = MusicUtils.query(this, MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
                mCols, whereclause, keywords, MediaStore.Audio.Playlists.NAME);
        
        return mergedCursor(c);
    }
";i:1;s:4:"java";i:2;N;}i:2;i:16896;}i:112;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16896;}i:113;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:71:"AlbumBrowserActivity在呈现界面时执行的异步查询操作如下";}i:2;i:18325;}i:114;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18402;}i:115;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:1644:"
    private Cursor getAlbumCursor(AsyncQueryHandler async, String filter) {
        String[] cols = new String[] {
                MediaStore.Audio.Albums._ID,
                MediaStore.Audio.Albums.ARTIST,
                MediaStore.Audio.Albums.ALBUM,
                MediaStore.Audio.Albums.ALBUM_ART
        };


        Cursor ret = null;
        if (mArtistId != null) {
            Uri uri = MediaStore.Audio.Artists.Albums.getContentUri("external",
                    Long.valueOf(mArtistId));
            if (!TextUtils.isEmpty(filter)) {
                uri = uri.buildUpon().appendQueryParameter("filter", Uri.encode(filter)).build();
            }
            if (async != null) {
                async.startQuery(0, null, uri,
                        cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);
            } else {
                ret = MusicUtils.query(this, uri,
                        cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);
            }
        } else {
            Uri uri = MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI;
            if (!TextUtils.isEmpty(filter)) {
                uri = uri.buildUpon().appendQueryParameter("filter", Uri.encode(filter)).build();
            }
            if (async != null) {
                async.startQuery(0, null,
                        uri,
                        cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);
            } else {
                ret = MusicUtils.query(this, uri,
                        cols, null, null, MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);
            }
        }
        return ret;
    }
";i:1;s:4:"java";i:2;N;}i:2;i:18402;}i:116;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18402;}i:117;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:77:"ArtistAlbumBrowserActivity在呈现界面时执行的异步查询操作如下";}i:2;i:20060;}i:118;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:20143;}i:119;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:906:"
    private Cursor getArtistCursor(AsyncQueryHandler async, String filter) {

        String[] cols = new String[] {
                MediaStore.Audio.Artists._ID,
                MediaStore.Audio.Artists.ARTIST,
                MediaStore.Audio.Artists.NUMBER_OF_ALBUMS,
                MediaStore.Audio.Artists.NUMBER_OF_TRACKS
        };

        Uri uri = MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI;
        if (!TextUtils.isEmpty(filter)) {
            uri = uri.buildUpon().appendQueryParameter("filter", Uri.encode(filter)).build();
        }

        Cursor ret = null;
        if (async != null) {
            async.startQuery(0, null, uri,
                    cols, null , null, MediaStore.Audio.Artists.ARTIST_KEY);
        } else {
            ret = MusicUtils.query(this, uri,
                    cols, null , null, MediaStore.Audio.Artists.ARTIST_KEY);
        }
        return ret;
    }
";i:1;s:4:"java";i:2;N;}i:2;i:20143;}i:120;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:21063;}i:121;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:18:"音乐播放界面";i:1;i:1;i:2;i:21063;}i:2;i:21063;}i:122;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:21063;}i:123;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:21063;}i:124;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:276:"音乐播放界面主要是由MediaPlaybackActivity来呈现。该Activity的onCreate方法主要是初始化页面组件，在onStart方法中绑定MediaPlaybackService类,ServiceConnection类型的变量osc的onServiceConnected方法得以执行，从而初始化mService。";}i:2;i:21094;}i:125;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:21376;}i:126;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:798:"
    public void onStart() {
        super.onStart();
        paused = false;
        mToken = MusicUtils.bindToService(this, osc);
        if (mToken == null) {
            // something went wrong
            mHandler.sendEmptyMessage(QUIT);
        }
        
        IntentFilter f = new IntentFilter();
        f.addAction(MediaPlaybackService.PLAYSTATE_CHANGED);
        f.addAction(MediaPlaybackService.META_CHANGED);
        registerReceiver(mStatusListener, new IntentFilter(f));

        IntentFilter s = new IntentFilter();
        s.addAction(Intent.ACTION_SCREEN_ON);
        s.addAction(Intent.ACTION_SCREEN_OFF);
        registerReceiver(mScreenTimeoutListener, new IntentFilter(s));

        updateTrackInfo();
        long next = refreshNow();
        queueNextRefresh(next);
    }
";i:1;s:4:"java";i:2;N;}i:2;i:21376;}i:127;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:1812:"
    private ServiceConnection osc = new ServiceConnection() {
            public void onServiceConnected(ComponentName classname, IBinder obj) {
                mService = IMediaPlaybackService.Stub.asInterface(obj);
                startPlayback();
                try {
                    // Assume something is playing when the service says it is,
                    // but also if the audio ID is valid but the service is paused.
                    if (mService.getAudioId() >= 0 || mService.isPlaying() ||
                            mService.getPath() != null) {
                        // something is playing now, we're done
                        mRepeatButton.setVisibility(View.VISIBLE);
                        mShuffleButton.setVisibility(View.VISIBLE);
                        mQueueButton.setVisibility(View.VISIBLE);
                        setRepeatButtonImage();
                        setShuffleButtonImage();
                        setPauseButtonImage();
                        return;
                    }
                } catch (RemoteException ex) {
                }
                // Service is dead or not playing anything. If we got here as part
                // of a "play this file" Intent, exit. Otherwise go to the Music
                // app start screen.
                if (getIntent().getData() == null) {
                    Intent intent = new Intent(Intent.ACTION_MAIN);
                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    intent.setClass(MediaPlaybackActivity.this, MusicBrowserActivity.class);
                    startActivity(intent);
                }
                finish();
            }
            public void onServiceDisconnected(ComponentName classname) {
                mService = null;
            }
    };
";i:1;s:4:"java";i:2;N;}i:2;i:22194;}i:128;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:22194;}i:129;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:144:"在onServiceConnected方法中初始化mService之后，执行startPlayback();方法，即开始根据传递过来的参数开始播放音乐。";}i:2;i:24020;}i:130;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:24170;}i:131;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:1012:"
    private void startPlayback() {

        if(mService == null)
            return;
        Intent intent = getIntent();
        String filename = "";
        Uri uri = intent.getData();
        if (uri != null && uri.toString().length() > 0) {
            // If this is a file:// URI, just use the path directly instead
            // of going through the open-from-filedescriptor codepath.
            String scheme = uri.getScheme();
            if ("file".equals(scheme)) {
                filename = uri.getPath();
            } else {
                filename = uri.toString();
            }
            try {
                mService.stop();
                mService.openFile(filename);
                mService.play();
                setIntent(new Intent());
            } catch (Exception ex) {
                Log.d("MediaPlaybackActivity", "couldn't start playback: " + ex);
            }
        }
        updateTrackInfo();
        long next = refreshNow();
        queueNextRefresh(next);
    }
";i:1;s:4:"java";i:2;N;}i:2;i:24170;}i:132;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:24170;}i:133;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:108:"在音乐播放界面可以选择上一首，下一首，开始或者暂停，选择上一首的代码如下";}i:2;i:25196;}i:134;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:25310;}i:135;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:816:"
    private View.OnClickListener mPrevListener = new View.OnClickListener() {
        public void onClick(View v) {
            if (mService == null) return;
            try {
                int shuffle = mService.getShuffleMode();
                int histSize = mService.getHistSize();
                if (mService.position() < 2000) {
                    if ((shuffle == MediaPlaybackService.SHUFFLE_NORMAL)&&(histSize == 0 || histSize == 1)) {
                        mService.seek(0);
                        mService.play();
                    } else {
                        mService.prev();
                    }
                } else {
                    mService.seek(0);
                    mService.play();
                }
            } catch (RemoteException ex) {
            }
        }
    };
";i:1;s:4:"java";i:2;N;}i:2;i:25310;}i:136;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:25310;}i:137;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:30:"选择下一首的代码如下";}i:2;i:26140;}i:138;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:26176;}i:139;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:284:"
    private View.OnClickListener mNextListener = new View.OnClickListener() {
        public void onClick(View v) {
            if (mService == null) return;
            try {
                mService.next();
            } catch (RemoteException ex) {
            }
        }
    };
";i:1;s:4:"java";i:2;N;}i:2;i:26176;}i:140;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:26176;}i:141;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:36:"选择开始或暂停的代码如下";}i:2;i:26474;}i:142;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:26516;}i:143;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:164:"
    private View.OnClickListener mPauseListener = new View.OnClickListener() {
        public void onClick(View v) {
            doPauseResume();
        }
    };
";i:1;s:4:"java";i:2;N;}i:2;i:26516;}i:144;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:385:"
    private void doPauseResume() {
        try {
            if(mService != null) {
                if (mService.isPlaying()) {
                    mService.pause();
                } else {
                    mService.play();
                }
                refreshNow();
                setPauseButtonImage();
            }
        } catch (RemoteException ex) {
        }
    }
";i:1;s:4:"java";i:2;N;}i:2;i:26699;}i:145;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:26699;}i:146;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:118:"开始或暂停按键在不同状态下有不同的显示效果，setPauseButtonImage();方法负责完成该功能。";}i:2;i:27098;}i:147;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:27222;}i:148;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:369:"
    private void setPauseButtonImage() {
        try {
            if (mService != null && mService.isPlaying()) {
                mPauseButton.setImageResource(android.R.drawable.ic_media_pause);
            } else {
                mPauseButton.setImageResource(android.R.drawable.ic_media_play);
            }
        } catch (RemoteException ex) {
        }
    }
";i:1;s:4:"java";i:2;N;}i:2;i:27222;}i:149;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:27604;}i:150;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:27604;}}