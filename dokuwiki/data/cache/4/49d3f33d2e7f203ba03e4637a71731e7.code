<span class="kw1">package</span> <span class="co2">com.learnopengles.android.lesson2</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">import</span> <span class="co2">java.nio.ByteBuffer</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.nio.ByteOrder</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">java.nio.FloatBuffer</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">import</span> <span class="co2">javax.microedition.khronos.egl.EGLConfig</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">javax.microedition.khronos.opengles.GL10</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">import</span> <span class="co2">android.opengl.GLES20</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.opengl.GLSurfaceView</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.opengl.Matrix</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.os.SystemClock</span><span class="sy0">;</span>
<span class="kw1">import</span> <span class="co2">android.util.Log</span><span class="sy0">;</span>
&nbsp;
<span class="co3">/**
 * This class implements our custom renderer. Note that the GL10 parameter passed in is unused for OpenGL ES 2.0
 * renderers -- the static class GLES20 is used instead.
 */</span>
<span class="kw1">public</span> <span class="kw1">class</span> LessonTwoRenderer <span class="kw1">implements</span> GLSurfaceView.<a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+renderer"><span class="kw3">Renderer</span></a> 
<span class="br0">&#123;</span>
	<span class="co3">/** Used for debug logs. */</span>
	<span class="kw1">private</span> <span class="kw1">static</span> <span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> TAG <span class="sy0">=</span> <span class="st0">&quot;LessonTwoRenderer&quot;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/**
	 * Store the model matrix. This matrix is used to move models from object space (where each model can be thought
	 * of being located at the center of the universe) to world space.
	 */</span>
	<span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mModelMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/**
	 * Store the view matrix. This can be thought of as our camera. This matrix transforms world space to eye space;
	 * it positions things relative to our eye.
	 */</span>
	<span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mViewMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** Store the projection matrix. This is used to project the scene onto a 2D viewport. */</span>
	<span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mProjectionMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** Allocate storage for the final combined matrix. This will be passed into the shader program. */</span>
	<span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mMVPMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** 
	 * Stores a copy of the model matrix specifically for the light position.
	 */</span>
	<span class="kw1">private</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mLightModelMatrix <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">16</span><span class="br0">&#93;</span><span class="sy0">;</span>	
&nbsp;
	<span class="co3">/** Store our model data in a float buffer. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> FloatBuffer mCubePositions<span class="sy0">;</span>
	<span class="kw1">private</span> <span class="kw1">final</span> FloatBuffer mCubeColors<span class="sy0">;</span>
	<span class="kw1">private</span> <span class="kw1">final</span> FloatBuffer mCubeNormals<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This will be used to pass in the transformation matrix. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mMVPMatrixHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This will be used to pass in the modelview matrix. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mMVMatrixHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This will be used to pass in the light position. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mLightPosHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This will be used to pass in model position information. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mPositionHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This will be used to pass in model color information. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mColorHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This will be used to pass in model normal information. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mNormalHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** How many bytes per float. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mBytesPerFloat <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">;</span>	
&nbsp;
	<span class="co3">/** Size of the position data in elements. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mPositionDataSize <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>	
&nbsp;
	<span class="co3">/** Size of the color data in elements. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mColorDataSize <span class="sy0">=</span> <span class="nu0">4</span><span class="sy0">;</span>	
&nbsp;
	<span class="co3">/** Size of the normal data in elements. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">int</span> mNormalDataSize <span class="sy0">=</span> <span class="nu0">3</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** Used to hold a light centered on the origin in model space. We need a 4th coordinate so we can get translations to work when
	 *  we multiply this by our transformation matrices. */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mLightPosInModelSpace <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="br0">&#123;</span>0.0f, 0.0f, 0.0f, 1.0f<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** Used to hold the current position of the light in world space (after transformation via model matrix). */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mLightPosInWorldSpace <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">4</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** Used to hold the transformed position of the light in eye space (after transformation via modelview matrix) */</span>
	<span class="kw1">private</span> <span class="kw1">final</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> mLightPosInEyeSpace <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="nu0">4</span><span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This is a handle to our per-vertex cube shading program. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mPerVertexProgramHandle<span class="sy0">;</span>
&nbsp;
	<span class="co3">/** This is a handle to our light point program. */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> mPointProgramHandle<span class="sy0">;</span>	
&nbsp;
	<span class="co3">/**
	 * Initialize the model data.
	 */</span>
	<span class="kw1">public</span> LessonTwoRenderer<span class="br0">&#40;</span><span class="br0">&#41;</span>
	<span class="br0">&#123;</span>	
		<span class="co1">// Define points for a cube.		</span>
&nbsp;
		<span class="co1">// X, Y, Z</span>
		<span class="kw1">final</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> cubePositionData <span class="sy0">=</span>
		<span class="br0">&#123;</span>
				<span class="co1">// In OpenGL counter-clockwise winding is default. This means that when we look at a triangle, </span>
				<span class="co1">// if the points are counter-clockwise we are looking at the &quot;front&quot;. If not we are looking at</span>
				<span class="co1">// the back. OpenGL has an optimization where all back-facing triangles are culled, since they</span>
				<span class="co1">// usually represent the backside of an object and aren't visible anyways.</span>
&nbsp;
				<span class="co1">// Front face</span>
				<span class="sy0">-</span>1.0f, 1.0f, 1.0f,				
				<span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f, 1.0f,
				1.0f, 1.0f, 1.0f, 
				<span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f, 1.0f, 				
				1.0f, <span class="sy0">-</span>1.0f, 1.0f,
				1.0f, 1.0f, 1.0f,
&nbsp;
				<span class="co1">// Right face</span>
				1.0f, 1.0f, 1.0f,				
				1.0f, <span class="sy0">-</span>1.0f, 1.0f,
				1.0f, 1.0f, <span class="sy0">-</span>1.0f,
				1.0f, <span class="sy0">-</span>1.0f, 1.0f,				
				1.0f, <span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f,
				1.0f, 1.0f, <span class="sy0">-</span>1.0f,
&nbsp;
				<span class="co1">// Back face</span>
				1.0f, 1.0f, <span class="sy0">-</span>1.0f,				
				1.0f, <span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f,
				<span class="sy0">-</span>1.0f, 1.0f, <span class="sy0">-</span>1.0f,
				1.0f, <span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f,				
				<span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f,
				<span class="sy0">-</span>1.0f, 1.0f, <span class="sy0">-</span>1.0f,
&nbsp;
				<span class="co1">// Left face</span>
				<span class="sy0">-</span>1.0f, 1.0f, <span class="sy0">-</span>1.0f,				
				<span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f,
				<span class="sy0">-</span>1.0f, 1.0f, 1.0f, 
				<span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f,				
				<span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f, 1.0f, 
				<span class="sy0">-</span>1.0f, 1.0f, 1.0f, 
&nbsp;
				<span class="co1">// Top face</span>
				<span class="sy0">-</span>1.0f, 1.0f, <span class="sy0">-</span>1.0f,				
				<span class="sy0">-</span>1.0f, 1.0f, 1.0f, 
				1.0f, 1.0f, <span class="sy0">-</span>1.0f, 
				<span class="sy0">-</span>1.0f, 1.0f, 1.0f, 				
				1.0f, 1.0f, 1.0f, 
				1.0f, 1.0f, <span class="sy0">-</span>1.0f,
&nbsp;
				<span class="co1">// Bottom face</span>
				1.0f, <span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f,				
				1.0f, <span class="sy0">-</span>1.0f, 1.0f, 
				<span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f,
				1.0f, <span class="sy0">-</span>1.0f, 1.0f, 				
				<span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f, 1.0f,
				<span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f, <span class="sy0">-</span>1.0f,
		<span class="br0">&#125;</span><span class="sy0">;</span>	
&nbsp;
		<span class="co1">// R, G, B, A</span>
		<span class="kw1">final</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> cubeColorData <span class="sy0">=</span>
		<span class="br0">&#123;</span>				
				<span class="co1">// Front face (red)</span>
				1.0f, 0.0f, 0.0f, 1.0f,				
				1.0f, 0.0f, 0.0f, 1.0f,
				1.0f, 0.0f, 0.0f, 1.0f,
				1.0f, 0.0f, 0.0f, 1.0f,				
				1.0f, 0.0f, 0.0f, 1.0f,
				1.0f, 0.0f, 0.0f, 1.0f,
&nbsp;
				<span class="co1">// Right face (green)</span>
				0.0f, 1.0f, 0.0f, 1.0f,				
				0.0f, 1.0f, 0.0f, 1.0f,
				0.0f, 1.0f, 0.0f, 1.0f,
				0.0f, 1.0f, 0.0f, 1.0f,				
				0.0f, 1.0f, 0.0f, 1.0f,
				0.0f, 1.0f, 0.0f, 1.0f,
&nbsp;
				<span class="co1">// Back face (blue)</span>
				0.0f, 0.0f, 1.0f, 1.0f,				
				0.0f, 0.0f, 1.0f, 1.0f,
				0.0f, 0.0f, 1.0f, 1.0f,
				0.0f, 0.0f, 1.0f, 1.0f,				
				0.0f, 0.0f, 1.0f, 1.0f,
				0.0f, 0.0f, 1.0f, 1.0f,
&nbsp;
				<span class="co1">// Left face (yellow)</span>
				1.0f, 1.0f, 0.0f, 1.0f,				
				1.0f, 1.0f, 0.0f, 1.0f,
				1.0f, 1.0f, 0.0f, 1.0f,
				1.0f, 1.0f, 0.0f, 1.0f,				
				1.0f, 1.0f, 0.0f, 1.0f,
				1.0f, 1.0f, 0.0f, 1.0f,
&nbsp;
				<span class="co1">// Top face (cyan)</span>
				0.0f, 1.0f, 1.0f, 1.0f,				
				0.0f, 1.0f, 1.0f, 1.0f,
				0.0f, 1.0f, 1.0f, 1.0f,
				0.0f, 1.0f, 1.0f, 1.0f,				
				0.0f, 1.0f, 1.0f, 1.0f,
				0.0f, 1.0f, 1.0f, 1.0f,
&nbsp;
				<span class="co1">// Bottom face (magenta)</span>
				1.0f, 0.0f, 1.0f, 1.0f,				
				1.0f, 0.0f, 1.0f, 1.0f,
				1.0f, 0.0f, 1.0f, 1.0f,
				1.0f, 0.0f, 1.0f, 1.0f,				
				1.0f, 0.0f, 1.0f, 1.0f,
				1.0f, 0.0f, 1.0f, 1.0f
		<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// X, Y, Z</span>
		<span class="co1">// The normal is used in light calculations and is a vector which points</span>
		<span class="co1">// orthogonal to the plane of the surface. For a cube model, the normals</span>
		<span class="co1">// should be orthogonal to the points of each face.</span>
		<span class="kw1">final</span> <span class="kw4">float</span><span class="br0">&#91;</span><span class="br0">&#93;</span> cubeNormalData <span class="sy0">=</span>
		<span class="br0">&#123;</span>												
				<span class="co1">// Front face</span>
				0.0f, 0.0f, 1.0f,				
				0.0f, 0.0f, 1.0f,
				0.0f, 0.0f, 1.0f,
				0.0f, 0.0f, 1.0f,				
				0.0f, 0.0f, 1.0f,
				0.0f, 0.0f, 1.0f,
&nbsp;
				<span class="co1">// Right face </span>
				1.0f, 0.0f, 0.0f,				
				1.0f, 0.0f, 0.0f,
				1.0f, 0.0f, 0.0f,
				1.0f, 0.0f, 0.0f,				
				1.0f, 0.0f, 0.0f,
				1.0f, 0.0f, 0.0f,
&nbsp;
				<span class="co1">// Back face </span>
				0.0f, 0.0f, <span class="sy0">-</span>1.0f,				
				0.0f, 0.0f, <span class="sy0">-</span>1.0f,
				0.0f, 0.0f, <span class="sy0">-</span>1.0f,
				0.0f, 0.0f, <span class="sy0">-</span>1.0f,				
				0.0f, 0.0f, <span class="sy0">-</span>1.0f,
				0.0f, 0.0f, <span class="sy0">-</span>1.0f,
&nbsp;
				<span class="co1">// Left face </span>
				<span class="sy0">-</span>1.0f, 0.0f, 0.0f,				
				<span class="sy0">-</span>1.0f, 0.0f, 0.0f,
				<span class="sy0">-</span>1.0f, 0.0f, 0.0f,
				<span class="sy0">-</span>1.0f, 0.0f, 0.0f,				
				<span class="sy0">-</span>1.0f, 0.0f, 0.0f,
				<span class="sy0">-</span>1.0f, 0.0f, 0.0f,
&nbsp;
				<span class="co1">// Top face </span>
				0.0f, 1.0f, 0.0f,			
				0.0f, 1.0f, 0.0f,
				0.0f, 1.0f, 0.0f,
				0.0f, 1.0f, 0.0f,				
				0.0f, 1.0f, 0.0f,
				0.0f, 1.0f, 0.0f,
&nbsp;
				<span class="co1">// Bottom face </span>
				0.0f, <span class="sy0">-</span>1.0f, 0.0f,			
				0.0f, <span class="sy0">-</span>1.0f, 0.0f,
				0.0f, <span class="sy0">-</span>1.0f, 0.0f,
				0.0f, <span class="sy0">-</span>1.0f, 0.0f,				
				0.0f, <span class="sy0">-</span>1.0f, 0.0f,
				0.0f, <span class="sy0">-</span>1.0f, 0.0f
		<span class="br0">&#125;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Initialize the buffers.</span>
		mCubePositions <span class="sy0">=</span> ByteBuffer.<span class="me1">allocateDirect</span><span class="br0">&#40;</span>cubePositionData.<span class="me1">length</span> <span class="sy0">*</span> mBytesPerFloat<span class="br0">&#41;</span>
        .<span class="me1">order</span><span class="br0">&#40;</span>ByteOrder.<span class="me1">nativeOrder</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>.<span class="me1">asFloatBuffer</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>							
		mCubePositions.<span class="me1">put</span><span class="br0">&#40;</span>cubePositionData<span class="br0">&#41;</span>.<span class="me1">position</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>		
&nbsp;
		mCubeColors <span class="sy0">=</span> ByteBuffer.<span class="me1">allocateDirect</span><span class="br0">&#40;</span>cubeColorData.<span class="me1">length</span> <span class="sy0">*</span> mBytesPerFloat<span class="br0">&#41;</span>
        .<span class="me1">order</span><span class="br0">&#40;</span>ByteOrder.<span class="me1">nativeOrder</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>.<span class="me1">asFloatBuffer</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>							
		mCubeColors.<span class="me1">put</span><span class="br0">&#40;</span>cubeColorData<span class="br0">&#41;</span>.<span class="me1">position</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		mCubeNormals <span class="sy0">=</span> ByteBuffer.<span class="me1">allocateDirect</span><span class="br0">&#40;</span>cubeNormalData.<span class="me1">length</span> <span class="sy0">*</span> mBytesPerFloat<span class="br0">&#41;</span>
        .<span class="me1">order</span><span class="br0">&#40;</span>ByteOrder.<span class="me1">nativeOrder</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>.<span class="me1">asFloatBuffer</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>							
		mCubeNormals.<span class="me1">put</span><span class="br0">&#40;</span>cubeNormalData<span class="br0">&#41;</span>.<span class="me1">position</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw1">protected</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> getVertexShader<span class="br0">&#40;</span><span class="br0">&#41;</span>
	<span class="br0">&#123;</span>
		<span class="co1">// TODO: Explain why we normalize the vectors, explain some of the vector math behind it all. Explain what is eye space.</span>
		<span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> vertexShader <span class="sy0">=</span>
			<span class="st0">&quot;uniform mat4 u_MVPMatrix;      <span class="es0">\n</span>&quot;</span>		<span class="co1">// A constant representing the combined model/view/projection matrix.</span>
		  <span class="sy0">+</span> <span class="st0">&quot;uniform mat4 u_MVMatrix;       <span class="es0">\n</span>&quot;</span>		<span class="co1">// A constant representing the combined model/view matrix.	</span>
		  <span class="sy0">+</span> <span class="st0">&quot;uniform vec3 u_LightPos;       <span class="es0">\n</span>&quot;</span>	    <span class="co1">// The position of the light in eye space.</span>
&nbsp;
		  <span class="sy0">+</span> <span class="st0">&quot;attribute vec4 a_Position;     <span class="es0">\n</span>&quot;</span>		<span class="co1">// Per-vertex position information we will pass in.</span>
		  <span class="sy0">+</span> <span class="st0">&quot;attribute vec4 a_Color;        <span class="es0">\n</span>&quot;</span>		<span class="co1">// Per-vertex color information we will pass in.</span>
		  <span class="sy0">+</span> <span class="st0">&quot;attribute vec3 a_Normal;       <span class="es0">\n</span>&quot;</span>		<span class="co1">// Per-vertex normal information we will pass in.</span>
&nbsp;
		  <span class="sy0">+</span> <span class="st0">&quot;varying vec4 v_Color;          <span class="es0">\n</span>&quot;</span>		<span class="co1">// This will be passed into the fragment shader.</span>
&nbsp;
		  <span class="sy0">+</span> <span class="st0">&quot;void main()                    <span class="es0">\n</span>&quot;</span> 	<span class="co1">// The entry point for our vertex shader.</span>
		  <span class="sy0">+</span> <span class="st0">&quot;{                              <span class="es0">\n</span>&quot;</span>		
		<span class="co1">// Transform the vertex into eye space.</span>
		  <span class="sy0">+</span> <span class="st0">&quot;   vec3 modelViewVertex = vec3(u_MVMatrix * a_Position);              <span class="es0">\n</span>&quot;</span>
		<span class="co1">// Transform the normal's orientation into eye space.</span>
		  <span class="sy0">+</span> <span class="st0">&quot;   vec3 modelViewNormal = vec3(u_MVMatrix * vec4(a_Normal, 0.0));     <span class="es0">\n</span>&quot;</span>
		<span class="co1">// Will be used for attenuation.</span>
		  <span class="sy0">+</span> <span class="st0">&quot;   float distance = length(u_LightPos - modelViewVertex);             <span class="es0">\n</span>&quot;</span>
		<span class="co1">// Get a lighting direction vector from the light to the vertex.</span>
		  <span class="sy0">+</span> <span class="st0">&quot;   vec3 lightVector = normalize(u_LightPos - modelViewVertex);        <span class="es0">\n</span>&quot;</span>
		<span class="co1">// Calculate the dot product of the light vector and vertex normal. If the normal and light vector are</span>
		<span class="co1">// pointing in the same direction then it will get max illumination.</span>
		  <span class="sy0">+</span> <span class="st0">&quot;   float diffuse = max(dot(modelViewNormal, lightVector), 0.1);       <span class="es0">\n</span>&quot;</span> 	  		  													  
		<span class="co1">// Attenuate the light based on distance.</span>
		  <span class="sy0">+</span> <span class="st0">&quot;   diffuse = diffuse * (1.0 / (1.0 + (0.25 * distance * distance)));  <span class="es0">\n</span>&quot;</span>
		<span class="co1">// Multiply the color by the illumination level. It will be interpolated across the triangle.</span>
		  <span class="sy0">+</span> <span class="st0">&quot;   v_Color = a_Color * diffuse;                                       <span class="es0">\n</span>&quot;</span> 	 
		<span class="co1">// gl_Position is a special variable used to store the final position.</span>
		<span class="co1">// Multiply the vertex by the matrix to get the final point in normalized screen coordinates.		</span>
		  <span class="sy0">+</span> <span class="st0">&quot;   gl_Position = u_MVPMatrix * a_Position;                            <span class="es0">\n</span>&quot;</span>     
		  <span class="sy0">+</span> <span class="st0">&quot;}                                                                     <span class="es0">\n</span>&quot;</span><span class="sy0">;</span> 
&nbsp;
		<span class="kw1">return</span> vertexShader<span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="kw1">protected</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> getFragmentShader<span class="br0">&#40;</span><span class="br0">&#41;</span>
	<span class="br0">&#123;</span>
		<span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> fragmentShader <span class="sy0">=</span>
		    <span class="st0">&quot;precision mediump float;       <span class="es0">\n</span>&quot;</span>	        <span class="co1">// Set the default precision to medium. We don't need as high of a </span>
								<span class="co1">// precision in the fragment shader.				</span>
		  <span class="sy0">+</span> <span class="st0">&quot;varying vec4 v_Color;          <span class="es0">\n</span>&quot;</span>		<span class="co1">// This is the color from the vertex shader interpolated across the </span>
		  						<span class="co1">// triangle per fragment.			  </span>
		  <span class="sy0">+</span> <span class="st0">&quot;void main()                    <span class="es0">\n</span>&quot;</span>		<span class="co1">// The entry point for our fragment shader.</span>
		  <span class="sy0">+</span> <span class="st0">&quot;{                              <span class="es0">\n</span>&quot;</span>
		  <span class="sy0">+</span> <span class="st0">&quot;   gl_FragColor = v_Color;     <span class="es0">\n</span>&quot;</span>		<span class="co1">// Pass the color directly through the pipeline.		  </span>
		  <span class="sy0">+</span> <span class="st0">&quot;}                              <span class="es0">\n</span>&quot;</span><span class="sy0">;</span>
&nbsp;
		<span class="kw1">return</span> fragmentShader<span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	@Override
	<span class="kw1">public</span> <span class="kw4">void</span> onSurfaceCreated<span class="br0">&#40;</span>GL10 glUnused, EGLConfig config<span class="br0">&#41;</span> 
	<span class="br0">&#123;</span>
		<span class="co1">// Set the background clear color to black.</span>
		GLES20.<span class="me1">glClearColor</span><span class="br0">&#40;</span>0.0f, 0.0f, 0.0f, 0.0f<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Use culling to remove back faces.</span>
		GLES20.<span class="me1">glEnable</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_CULL_FACE</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Enable depth testing</span>
		GLES20.<span class="me1">glEnable</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_DEPTH_TEST</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Position the eye in front of the origin.</span>
		<span class="kw1">final</span> <span class="kw4">float</span> eyeX <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> eyeY <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> eyeZ <span class="sy0">=</span> <span class="sy0">-</span>0.5f<span class="sy0">;</span>
&nbsp;
		<span class="co1">// We are looking toward the distance</span>
		<span class="kw1">final</span> <span class="kw4">float</span> lookX <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> lookY <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> lookZ <span class="sy0">=</span> <span class="sy0">-</span>5.0f<span class="sy0">;</span>
&nbsp;
		<span class="co1">// Set our up vector. This is where our head would be pointing were we holding the camera.</span>
		<span class="kw1">final</span> <span class="kw4">float</span> upX <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> upY <span class="sy0">=</span> 1.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> upZ <span class="sy0">=</span> 0.0f<span class="sy0">;</span>
&nbsp;
		<span class="co1">// Set the view matrix. This matrix can be said to represent the camera position.</span>
		<span class="co1">// NOTE: In OpenGL 1, a ModelView matrix is used, which is a combination of a model and</span>
		<span class="co1">// view matrix. In OpenGL 2, we can keep track of these matrices separately if we choose.</span>
		Matrix.<span class="me1">setLookAtM</span><span class="br0">&#40;</span>mViewMatrix, <span class="nu0">0</span>, eyeX, eyeY, eyeZ, lookX, lookY, lookZ, upX, upY, upZ<span class="br0">&#41;</span><span class="sy0">;</span>		
&nbsp;
		<span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> vertexShader <span class="sy0">=</span> getVertexShader<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   		
 		<span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> fragmentShader <span class="sy0">=</span> getFragmentShader<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>			
&nbsp;
		<span class="kw1">final</span> <span class="kw4">int</span> vertexShaderHandle <span class="sy0">=</span> compileShader<span class="br0">&#40;</span>GLES20.<span class="me1">GL_VERTEX_SHADER</span>, vertexShader<span class="br0">&#41;</span><span class="sy0">;</span>		
		<span class="kw1">final</span> <span class="kw4">int</span> fragmentShaderHandle <span class="sy0">=</span> compileShader<span class="br0">&#40;</span>GLES20.<span class="me1">GL_FRAGMENT_SHADER</span>, fragmentShader<span class="br0">&#41;</span><span class="sy0">;</span>		
&nbsp;
		mPerVertexProgramHandle <span class="sy0">=</span> createAndLinkProgram<span class="br0">&#40;</span>vertexShaderHandle, fragmentShaderHandle, 
				<span class="kw1">new</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a><span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="br0">&#123;</span><span class="st0">&quot;a_Position&quot;</span>,  <span class="st0">&quot;a_Color&quot;</span>, <span class="st0">&quot;a_Normal&quot;</span><span class="br0">&#125;</span><span class="br0">&#41;</span><span class="sy0">;</span>								                                							       
&nbsp;
        <span class="co1">// Define a simple shader program for our point.</span>
        <span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> pointVertexShader <span class="sy0">=</span>
        	<span class="st0">&quot;uniform mat4 u_MVPMatrix;      <span class="es0">\n</span>&quot;</span>		
          <span class="sy0">+</span>	<span class="st0">&quot;attribute vec4 a_Position;     <span class="es0">\n</span>&quot;</span>		
          <span class="sy0">+</span> <span class="st0">&quot;void main()                    <span class="es0">\n</span>&quot;</span>
          <span class="sy0">+</span> <span class="st0">&quot;{                              <span class="es0">\n</span>&quot;</span>
          <span class="sy0">+</span> <span class="st0">&quot;   gl_Position = u_MVPMatrix   <span class="es0">\n</span>&quot;</span>
          <span class="sy0">+</span> <span class="st0">&quot;               * a_Position;   <span class="es0">\n</span>&quot;</span>
          <span class="sy0">+</span> <span class="st0">&quot;   gl_PointSize = 5.0;         <span class="es0">\n</span>&quot;</span>
          <span class="sy0">+</span> <span class="st0">&quot;}                              <span class="es0">\n</span>&quot;</span><span class="sy0">;</span>
&nbsp;
        <span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> pointFragmentShader <span class="sy0">=</span> 
        	<span class="st0">&quot;precision mediump float;       <span class="es0">\n</span>&quot;</span>					          
          <span class="sy0">+</span> <span class="st0">&quot;void main()                    <span class="es0">\n</span>&quot;</span>
          <span class="sy0">+</span> <span class="st0">&quot;{                              <span class="es0">\n</span>&quot;</span>
          <span class="sy0">+</span> <span class="st0">&quot;   gl_FragColor = vec4(1.0,    <span class="es0">\n</span>&quot;</span> 
          <span class="sy0">+</span> <span class="st0">&quot;   1.0, 1.0, 1.0);             <span class="es0">\n</span>&quot;</span>
          <span class="sy0">+</span> <span class="st0">&quot;}                              <span class="es0">\n</span>&quot;</span><span class="sy0">;</span>
&nbsp;
        <span class="kw1">final</span> <span class="kw4">int</span> pointVertexShaderHandle <span class="sy0">=</span> compileShader<span class="br0">&#40;</span>GLES20.<span class="me1">GL_VERTEX_SHADER</span>, pointVertexShader<span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw1">final</span> <span class="kw4">int</span> pointFragmentShaderHandle <span class="sy0">=</span> compileShader<span class="br0">&#40;</span>GLES20.<span class="me1">GL_FRAGMENT_SHADER</span>, pointFragmentShader<span class="br0">&#41;</span><span class="sy0">;</span>
        mPointProgramHandle <span class="sy0">=</span> createAndLinkProgram<span class="br0">&#40;</span>pointVertexShaderHandle, pointFragmentShaderHandle, 
        		<span class="kw1">new</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a><span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="br0">&#123;</span><span class="st0">&quot;a_Position&quot;</span><span class="br0">&#125;</span><span class="br0">&#41;</span><span class="sy0">;</span>                 
	<span class="br0">&#125;</span>	
&nbsp;
	@Override
	<span class="kw1">public</span> <span class="kw4">void</span> onSurfaceChanged<span class="br0">&#40;</span>GL10 glUnused, <span class="kw4">int</span> width, <span class="kw4">int</span> height<span class="br0">&#41;</span> 
	<span class="br0">&#123;</span>
		<span class="co1">// Set the OpenGL viewport to the same size as the surface.</span>
		GLES20.<span class="me1">glViewport</span><span class="br0">&#40;</span><span class="nu0">0</span>, <span class="nu0">0</span>, width, height<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Create a new perspective projection matrix. The height will stay the same</span>
		<span class="co1">// while the width will vary as per aspect ratio.</span>
		<span class="kw1">final</span> <span class="kw4">float</span> ratio <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw4">float</span><span class="br0">&#41;</span> width <span class="sy0">/</span> height<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> left <span class="sy0">=</span> <span class="sy0">-</span>ratio<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> right <span class="sy0">=</span> ratio<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> bottom <span class="sy0">=</span> <span class="sy0">-</span>1.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> top <span class="sy0">=</span> 1.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> near <span class="sy0">=</span> 1.0f<span class="sy0">;</span>
		<span class="kw1">final</span> <span class="kw4">float</span> far <span class="sy0">=</span> 10.0f<span class="sy0">;</span>
&nbsp;
		Matrix.<span class="me1">frustumM</span><span class="br0">&#40;</span>mProjectionMatrix, <span class="nu0">0</span>, left, right, bottom, top, near, far<span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>	
&nbsp;
	@Override
	<span class="kw1">public</span> <span class="kw4">void</span> onDrawFrame<span class="br0">&#40;</span>GL10 glUnused<span class="br0">&#41;</span> 
	<span class="br0">&#123;</span>
	GLES20.<span class="me1">glClear</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_COLOR_BUFFER_BIT</span> <span class="sy0">|</span> GLES20.<span class="me1">GL_DEPTH_BUFFER_BIT</span><span class="br0">&#41;</span><span class="sy0">;</span>			        
&nbsp;
        <span class="co1">// Do a complete rotation every 10 seconds.</span>
        <span class="kw4">long</span> time <span class="sy0">=</span> SystemClock.<span class="me1">uptimeMillis</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">%</span> 10000L<span class="sy0">;</span>        
        <span class="kw4">float</span> angleInDegrees <span class="sy0">=</span> <span class="br0">&#40;</span>360.0f <span class="sy0">/</span> 10000.0f<span class="br0">&#41;</span> <span class="sy0">*</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> time<span class="br0">&#41;</span><span class="sy0">;</span>                
&nbsp;
        <span class="co1">// Set our per-vertex lighting program.</span>
        GLES20.<span class="me1">glUseProgram</span><span class="br0">&#40;</span>mPerVertexProgramHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        <span class="co1">// Set program handles for cube drawing.</span>
        mMVPMatrixHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetUniformLocation</span><span class="br0">&#40;</span>mPerVertexProgramHandle, <span class="st0">&quot;u_MVPMatrix&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        mMVMatrixHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetUniformLocation</span><span class="br0">&#40;</span>mPerVertexProgramHandle, <span class="st0">&quot;u_MVMatrix&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> 
        mLightPosHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetUniformLocation</span><span class="br0">&#40;</span>mPerVertexProgramHandle, <span class="st0">&quot;u_LightPos&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        mPositionHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetAttribLocation</span><span class="br0">&#40;</span>mPerVertexProgramHandle, <span class="st0">&quot;a_Position&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        mColorHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetAttribLocation</span><span class="br0">&#40;</span>mPerVertexProgramHandle, <span class="st0">&quot;a_Color&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        mNormalHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetAttribLocation</span><span class="br0">&#40;</span>mPerVertexProgramHandle, <span class="st0">&quot;a_Normal&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span> 
&nbsp;
        <span class="co1">// Calculate position of the light. Rotate and then push into the distance.</span>
        Matrix.<span class="me1">setIdentityM</span><span class="br0">&#40;</span>mLightModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">translateM</span><span class="br0">&#40;</span>mLightModelMatrix, <span class="nu0">0</span>, 0.0f, 0.0f, <span class="sy0">-</span>5.0f<span class="br0">&#41;</span><span class="sy0">;</span>      
        Matrix.<span class="me1">rotateM</span><span class="br0">&#40;</span>mLightModelMatrix, <span class="nu0">0</span>, angleInDegrees, 0.0f, 1.0f, 0.0f<span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">translateM</span><span class="br0">&#40;</span>mLightModelMatrix, <span class="nu0">0</span>, 0.0f, 0.0f, 2.0f<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        Matrix.<span class="me1">multiplyMV</span><span class="br0">&#40;</span>mLightPosInWorldSpace, <span class="nu0">0</span>, mLightModelMatrix, <span class="nu0">0</span>, mLightPosInModelSpace, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">multiplyMV</span><span class="br0">&#40;</span>mLightPosInEyeSpace, <span class="nu0">0</span>, mViewMatrix, <span class="nu0">0</span>, mLightPosInWorldSpace, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>                        
&nbsp;
        <span class="co1">// Draw some cubes.        </span>
        Matrix.<span class="me1">setIdentityM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">translateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, 4.0f, 0.0f, <span class="sy0">-</span>7.0f<span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">rotateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, angleInDegrees, 1.0f, 0.0f, 0.0f<span class="br0">&#41;</span><span class="sy0">;</span>        
        drawCube<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        Matrix.<span class="me1">setIdentityM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">translateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, <span class="sy0">-</span>4.0f, 0.0f, <span class="sy0">-</span>7.0f<span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">rotateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, angleInDegrees, 0.0f, 1.0f, 0.0f<span class="br0">&#41;</span><span class="sy0">;</span>        
        drawCube<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        Matrix.<span class="me1">setIdentityM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">translateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, 0.0f, 4.0f, <span class="sy0">-</span>7.0f<span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">rotateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, angleInDegrees, 0.0f, 0.0f, 1.0f<span class="br0">&#41;</span><span class="sy0">;</span>        
        drawCube<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        Matrix.<span class="me1">setIdentityM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">translateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, 0.0f, <span class="sy0">-</span>4.0f, <span class="sy0">-</span>7.0f<span class="br0">&#41;</span><span class="sy0">;</span>
        drawCube<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        Matrix.<span class="me1">setIdentityM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">translateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, 0.0f, 0.0f, <span class="sy0">-</span>5.0f<span class="br0">&#41;</span><span class="sy0">;</span>
        Matrix.<span class="me1">rotateM</span><span class="br0">&#40;</span>mModelMatrix, <span class="nu0">0</span>, angleInDegrees, 1.0f, 1.0f, 0.0f<span class="br0">&#41;</span><span class="sy0">;</span>        
        drawCube<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>      
&nbsp;
        <span class="co1">// Draw a point to indicate the light.</span>
        GLES20.<span class="me1">glUseProgram</span><span class="br0">&#40;</span>mPointProgramHandle<span class="br0">&#41;</span><span class="sy0">;</span>        
        drawLight<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>				
&nbsp;
	<span class="co3">/**
	 * Draws a cube.
	 */</span>			
	<span class="kw1">private</span> <span class="kw4">void</span> drawCube<span class="br0">&#40;</span><span class="br0">&#41;</span>
	<span class="br0">&#123;</span>		
		<span class="co1">// Pass in the position information</span>
		mCubePositions.<span class="me1">position</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>		
                GLES20.<span class="me1">glVertexAttribPointer</span><span class="br0">&#40;</span>mPositionHandle, mPositionDataSize, GLES20.<span class="me1">GL_FLOAT</span>, <span class="kw2">false</span>,
          		<span class="nu0">0</span>, mCubePositions<span class="br0">&#41;</span><span class="sy0">;</span>        
&nbsp;
                GLES20.<span class="me1">glEnableVertexAttribArray</span><span class="br0">&#40;</span>mPositionHandle<span class="br0">&#41;</span><span class="sy0">;</span>        
&nbsp;
                <span class="co1">// Pass in the color information</span>
                mCubeColors.<span class="me1">position</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
                GLES20.<span class="me1">glVertexAttribPointer</span><span class="br0">&#40;</span>mColorHandle, mColorDataSize, GLES20.<span class="me1">GL_FLOAT</span>, <span class="kw2">false</span>,
         		<span class="nu0">0</span>, mCubeColors<span class="br0">&#41;</span><span class="sy0">;</span>        
&nbsp;
                GLES20.<span class="me1">glEnableVertexAttribArray</span><span class="br0">&#40;</span>mColorHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
                <span class="co1">// Pass in the normal information</span>
                mCubeNormals.<span class="me1">position</span><span class="br0">&#40;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
                GLES20.<span class="me1">glVertexAttribPointer</span><span class="br0">&#40;</span>mNormalHandle, mNormalDataSize, GLES20.<span class="me1">GL_FLOAT</span>, <span class="kw2">false</span>, 
        		<span class="nu0">0</span>, mCubeNormals<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
                GLES20.<span class="me1">glEnableVertexAttribArray</span><span class="br0">&#40;</span>mNormalHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	        <span class="co1">// This multiplies the view matrix by the model matrix, and stores the result in the MVP matrix</span>
                <span class="co1">// (which currently contains model * view).</span>
                Matrix.<span class="me1">multiplyMM</span><span class="br0">&#40;</span>mMVPMatrix, <span class="nu0">0</span>, mViewMatrix, <span class="nu0">0</span>, mModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>   
&nbsp;
                <span class="co1">// Pass in the modelview matrix.</span>
                GLES20.<span class="me1">glUniformMatrix4fv</span><span class="br0">&#40;</span>mMVMatrixHandle, <span class="nu0">1</span>, <span class="kw2">false</span>, mMVPMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>                
&nbsp;
                <span class="co1">// This multiplies the modelview matrix by the projection matrix, and stores the result in the MVP matrix</span>
                <span class="co1">// (which now contains model * view * projection).</span>
                Matrix.<span class="me1">multiplyMM</span><span class="br0">&#40;</span>mMVPMatrix, <span class="nu0">0</span>, mProjectionMatrix, <span class="nu0">0</span>, mMVPMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
                <span class="co1">// Pass in the combined matrix.</span>
                GLES20.<span class="me1">glUniformMatrix4fv</span><span class="br0">&#40;</span>mMVPMatrixHandle, <span class="nu0">1</span>, <span class="kw2">false</span>, mMVPMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
                <span class="co1">// Pass in the light position in eye space.        </span>
                GLES20.<span class="me1">glUniform3f</span><span class="br0">&#40;</span>mLightPosHandle, mLightPosInEyeSpace<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>, mLightPosInEyeSpace<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span>, mLightPosInEyeSpace<span class="br0">&#91;</span><span class="nu0">2</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
                <span class="co1">// Draw the cube.</span>
                GLES20.<span class="me1">glDrawArrays</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_TRIANGLES</span>, <span class="nu0">0</span>, <span class="nu0">36</span><span class="br0">&#41;</span><span class="sy0">;</span>                               
	<span class="br0">&#125;</span>	
&nbsp;
	<span class="co3">/**
	 * Draws a point representing the position of the light.
	 */</span>
	<span class="kw1">private</span> <span class="kw4">void</span> drawLight<span class="br0">&#40;</span><span class="br0">&#41;</span>
	<span class="br0">&#123;</span>
		<span class="kw1">final</span> <span class="kw4">int</span> pointMVPMatrixHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetUniformLocation</span><span class="br0">&#40;</span>mPointProgramHandle, <span class="st0">&quot;u_MVPMatrix&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
                <span class="kw1">final</span> <span class="kw4">int</span> pointPositionHandle <span class="sy0">=</span> GLES20.<span class="me1">glGetAttribLocation</span><span class="br0">&#40;</span>mPointProgramHandle, <span class="st0">&quot;a_Position&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Pass in the position.</span>
		GLES20.<span class="me1">glVertexAttrib3f</span><span class="br0">&#40;</span>pointPositionHandle, mLightPosInModelSpace<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>, mLightPosInModelSpace<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span>, mLightPosInModelSpace<span class="br0">&#91;</span><span class="nu0">2</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Since we are not using a buffer object, disable vertex arrays for this attribute.</span>
                GLES20.<span class="me1">glDisableVertexAttribArray</span><span class="br0">&#40;</span>pointPositionHandle<span class="br0">&#41;</span><span class="sy0">;</span>  
&nbsp;
		<span class="co1">// Pass in the transformation matrix.</span>
		Matrix.<span class="me1">multiplyMM</span><span class="br0">&#40;</span>mMVPMatrix, <span class="nu0">0</span>, mViewMatrix, <span class="nu0">0</span>, mLightModelMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
		Matrix.<span class="me1">multiplyMM</span><span class="br0">&#40;</span>mMVPMatrix, <span class="nu0">0</span>, mProjectionMatrix, <span class="nu0">0</span>, mMVPMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
		GLES20.<span class="me1">glUniformMatrix4fv</span><span class="br0">&#40;</span>pointMVPMatrixHandle, <span class="nu0">1</span>, <span class="kw2">false</span>, mMVPMatrix, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="co1">// Draw the point.</span>
		GLES20.<span class="me1">glDrawArrays</span><span class="br0">&#40;</span>GLES20.<span class="me1">GL_POINTS</span>, <span class="nu0">0</span>, <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span>
	<span class="br0">&#125;</span>
&nbsp;
	<span class="co3">/** 
	 * Helper function to compile a shader.
	 * 
	 * @param shaderType The shader type.
	 * @param shaderSource The shader source code.
	 * @return An OpenGL handle to the shader.
	 */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> compileShader<span class="br0">&#40;</span><span class="kw1">final</span> <span class="kw4">int</span> shaderType, <span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a> shaderSource<span class="br0">&#41;</span> 
	<span class="br0">&#123;</span>
		<span class="kw4">int</span> shaderHandle <span class="sy0">=</span> GLES20.<span class="me1">glCreateShader</span><span class="br0">&#40;</span>shaderType<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="kw1">if</span> <span class="br0">&#40;</span>shaderHandle <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span> 
		<span class="br0">&#123;</span>
			<span class="co1">// Pass in the shader source.</span>
			GLES20.<span class="me1">glShaderSource</span><span class="br0">&#40;</span>shaderHandle, shaderSource<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
			<span class="co1">// Compile the shader.</span>
			GLES20.<span class="me1">glCompileShader</span><span class="br0">&#40;</span>shaderHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
			<span class="co1">// Get the compilation status.</span>
			<span class="kw1">final</span> <span class="kw4">int</span><span class="br0">&#91;</span><span class="br0">&#93;</span> compileStatus <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">int</span><span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy0">;</span>
			GLES20.<span class="me1">glGetShaderiv</span><span class="br0">&#40;</span>shaderHandle, GLES20.<span class="me1">GL_COMPILE_STATUS</span>, compileStatus, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
			<span class="co1">// If the compilation failed, delete the shader.</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>compileStatus<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> 
			<span class="br0">&#123;</span>
				Log.<span class="me1">e</span><span class="br0">&#40;</span>TAG, <span class="st0">&quot;Error compiling shader: &quot;</span> <span class="sy0">+</span> GLES20.<span class="me1">glGetShaderInfoLog</span><span class="br0">&#40;</span>shaderHandle<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
				GLES20.<span class="me1">glDeleteShader</span><span class="br0">&#40;</span>shaderHandle<span class="br0">&#41;</span><span class="sy0">;</span>
				shaderHandle <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
&nbsp;
		<span class="kw1">if</span> <span class="br0">&#40;</span>shaderHandle <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
		<span class="br0">&#123;</span>			
			<span class="kw1">throw</span> <span class="kw1">new</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+runtimeexception"><span class="kw3">RuntimeException</span></a><span class="br0">&#40;</span><span class="st0">&quot;Error creating shader.&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="br0">&#125;</span>
&nbsp;
		<span class="kw1">return</span> shaderHandle<span class="sy0">;</span>
	<span class="br0">&#125;</span>	
&nbsp;
	<span class="co3">/**
	 * Helper function to compile and link a program.
	 * 
	 * @param vertexShaderHandle An OpenGL handle to an already-compiled vertex shader.
	 * @param fragmentShaderHandle An OpenGL handle to an already-compiled fragment shader.
	 * @param attributes Attributes that need to be bound to the program.
	 * @return An OpenGL handle to the program.
	 */</span>
	<span class="kw1">private</span> <span class="kw4">int</span> createAndLinkProgram<span class="br0">&#40;</span><span class="kw1">final</span> <span class="kw4">int</span> vertexShaderHandle, <span class="kw1">final</span> <span class="kw4">int</span> fragmentShaderHandle, <span class="kw1">final</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+string"><span class="kw3">String</span></a><span class="br0">&#91;</span><span class="br0">&#93;</span> attributes<span class="br0">&#41;</span> 
	<span class="br0">&#123;</span>
		<span class="kw4">int</span> programHandle <span class="sy0">=</span> GLES20.<span class="me1">glCreateProgram</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
		<span class="kw1">if</span> <span class="br0">&#40;</span>programHandle <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">&#41;</span> 
		<span class="br0">&#123;</span>
			<span class="co1">// Bind the vertex shader to the program.</span>
			GLES20.<span class="me1">glAttachShader</span><span class="br0">&#40;</span>programHandle, vertexShaderHandle<span class="br0">&#41;</span><span class="sy0">;</span>			
&nbsp;
			<span class="co1">// Bind the fragment shader to the program.</span>
			GLES20.<span class="me1">glAttachShader</span><span class="br0">&#40;</span>programHandle, fragmentShaderHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
			<span class="co1">// Bind attributes</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>attributes <span class="sy0">!=</span> <span class="kw2">null</span><span class="br0">&#41;</span>
			<span class="br0">&#123;</span>
				<span class="kw1">final</span> <span class="kw4">int</span> size <span class="sy0">=</span> attributes.<span class="me1">length</span><span class="sy0">;</span>
				<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> size<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">&#41;</span>
				<span class="br0">&#123;</span>
					GLES20.<span class="me1">glBindAttribLocation</span><span class="br0">&#40;</span>programHandle, i, attributes<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy0">;</span>
				<span class="br0">&#125;</span>						
			<span class="br0">&#125;</span>
&nbsp;
			<span class="co1">// Link the two shaders together into a program.</span>
			GLES20.<span class="me1">glLinkProgram</span><span class="br0">&#40;</span>programHandle<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
			<span class="co1">// Get the link status.</span>
			<span class="kw1">final</span> <span class="kw4">int</span><span class="br0">&#91;</span><span class="br0">&#93;</span> linkStatus <span class="sy0">=</span> <span class="kw1">new</span> <span class="kw4">int</span><span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy0">;</span>
			GLES20.<span class="me1">glGetProgramiv</span><span class="br0">&#40;</span>programHandle, GLES20.<span class="me1">GL_LINK_STATUS</span>, linkStatus, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
			<span class="co1">// If the link failed, delete the program.</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>linkStatus<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> 
			<span class="br0">&#123;</span>				
				Log.<span class="me1">e</span><span class="br0">&#40;</span>TAG, <span class="st0">&quot;Error compiling program: &quot;</span> <span class="sy0">+</span> GLES20.<span class="me1">glGetProgramInfoLog</span><span class="br0">&#40;</span>programHandle<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
				GLES20.<span class="me1">glDeleteProgram</span><span class="br0">&#40;</span>programHandle<span class="br0">&#41;</span><span class="sy0">;</span>
				programHandle <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
&nbsp;
		<span class="kw1">if</span> <span class="br0">&#40;</span>programHandle <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span>
		<span class="br0">&#123;</span>
			<span class="kw1">throw</span> <span class="kw1">new</span> <a href="http://www.google.com/search?hl=en&amp;q=allinurl%3Adocs.oracle.com+javase+docs+api+runtimeexception"><span class="kw3">RuntimeException</span></a><span class="br0">&#40;</span><span class="st0">&quot;Error creating program.&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
		<span class="br0">&#125;</span>
&nbsp;
		<span class="kw1">return</span> programHandle<span class="sy0">;</span>
	<span class="br0">&#125;</span>
<span class="br0">&#125;</span>