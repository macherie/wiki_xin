<pre class="code">                                                                                                                     席芳清  2014-03-21</pre>

<p>
此处简单地描述一下Camera CCI I2C的注册和调用。
</p>
<pre class="code">主要的驱动文件： msm_cci.c ， msm_camera_cci_i2c.c</pre>
<pre class="code">用source insight搜索：
---- msm_sensor_cci_i2c_util Matches (5 in 5 files) ----
Msm_actuator.c (kernel\drivers\media\platform\msm\camera_v2\sensor\actuator):	.i2c_util = msm_sensor_cci_i2c_util,
Msm_camera_cci_i2c.c (kernel\drivers\media\platform\msm\camera_v2\sensor\io):int32_t msm_sensor_cci_i2c_util(struct msm_camera_i2c_client *client,
Msm_camera_i2c.h (kernel\drivers\media\platform\msm\camera_v2\sensor\io):int32_t msm_sensor_cci_i2c_util(struct msm_camera_i2c_client *client,
Msm_eeprom.c (kernel\drivers\media\platform\msm\camera_v2\sensor\eeprom):	.i2c_util = msm_sensor_cci_i2c_util,
Msm_sensor.c (kernel\drivers\media\platform\msm\camera_v2\sensor):	.i2c_util = msm_sensor_cci_i2c_util,</pre>
<pre class="code">msm_camera_cci_i2c.c中CCI I2C  接口：
int32_t msm_sensor_cci_i2c_util(struct msm_camera_i2c_client *client, uint16_t cci_cmd)
{
      int32_t rc = 0;
      struct msm_camera_cci_ctrl cci_ctrl;
      CDBG(&quot;%s line %d\n&quot;, __func__, __LINE__);
      cci_ctrl.cmd = cci_cmd;
      cci_ctrl.cci_info = client-&gt;cci_client;
      rc = v4l2_subdev_call(client-&gt;cci_client-&gt;cci_subdev,
              core, ioctl, VIDIOC_MSM_CCI_CFG, &amp;cci_ctrl);
      if (rc &lt; 0)  {
              pr_err(&quot;%s line %d rc = %d\n&quot;, __func__, __LINE__, rc);
              return rc;
      }
      return cci_ctrl.status;
}</pre>
<pre class="code">msm_cci.c probe中调用该函数，获取I2C_SDA &amp;&amp; I2C_CLK
static int32_t msm_cci_init_gpio_params(struct cci_device *cci_dev)
{
      for (i = 0; i &lt; tbl_size; i++) {
              gpio_tbl[i].gpio = of_get_gpio(of_node, i);
              CDBG(&quot;%s gpio_tbl[%d].gpio = %d\n&quot;, __func__, i,
              gpio_tbl[i].gpio);
      }
}
改文件还提供g_cci_subdev，供其他模块调用。
struct v4l2_subdev *msm_cci_get_subdev(void)
{
return g_cci_subdev;
}</pre>
<pre class="code"> msm8226-camera.dtsi中I2C DATA 和CLK对应的GPIO。
 114         cci: qcom,cci@fda0c000 {
 115                 cell-index = &lt;0&gt;;
 116                 compatible = &quot;qcom,cci&quot;;
 117                 reg = &lt;0xfda0c000 0x1000&gt;;
 118                 #address-cells = &lt;1&gt;;
 119                 #size-cells = &lt;0&gt;;
 120                 reg-names = &quot;cci&quot;;
 121                 interrupts = &lt;0 50 0&gt;;
 122                 interrupt-names = &quot;cci&quot;;
 123                 gpios = &lt;&amp;msmgpio 29 0&gt;,
 124                         &lt;&amp;msmgpio 30 0&gt;;
 125                 qcom,gpio-tbl-num = &lt;0 1&gt;;
 126                 qcom,gpio-tbl-flags = &lt;1 1&gt;;
 127                 qcom,gpio-tbl-label = &quot;CCI_I2C_DATA0&quot;,
 128                                       &quot;CCI_I2C_CLK0&quot;;
 129                 master0: qcom,cci-master0 {
 130                         status = &quot;disabled&quot;;
 131                 };
 132                 master1: qcom,cci-master1 {
 133                         status = &quot;disabled&quot;;
 134                 };
 135         };</pre>

<p>
msm_sensor.c中：
</p>
<pre class="code">int32_t msm_sensor_platform_probe(struct platform_device *pdev, void *data)  --&gt;  cci_client-&gt;cci_subdev = msm_cci_get_subdev();
就可以调用到msm_cci.c中的数据。</pre>
