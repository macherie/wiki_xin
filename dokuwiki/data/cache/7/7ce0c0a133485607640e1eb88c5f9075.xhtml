
<p>
1. General description
Generally, Qualcomm will use the PMIC to generate PWM signals. Actually, some GPIOs of MSM8926 can be used to output PWM signals too. These gpios are 12, 16, 17, 33, 34, 49, 50, and 51 in MSM8926. This document will guide you to enable the PWM function of these pins.
</p>

<p>
To enable the PWM function, you should do following:
</p>
<pre class="code">  1. Set the GPIO to PWM function.
  2. Combine a clock to this PIN to be PWM base frequency.
  3. Adjust the duty value of the PWM.</pre>

<p>
2. Detail steps
2.1 Set the GPIO to PWM function:
You can use following function to set the pin to output PWM.
</p>
<pre class="code">  gpio_tlmm_config(GPIO_CFG(
      PWM_GPIO, 3,
      GPIO_CFG_OUTPUT,
      GPIO_CFG_PULL_UP,
      GPIO_CFG_4MA),
      GPIO_CFG_ENABLE);</pre>

<p>
Please notice, you should use 3 to enable the PWM function of the GPIO.
Please notice, the PWM_GPIO should be one of 12, 16, 17, 33, 34, 49, 50, and 51.
We tested 34 on some platform. So we prefer to use pin 34.
</p>

<p>
2.2 Combine the clock to the GPIO pin:
You should do following 3 things to combine a clock:
</p>
<pre class="code">  1. define a new camss clock by CLK_LOOKUP
  2. open the camss clock by clk_get
  3. enable the clock by clk_set_rate and clk_prepare_enable</pre>

<p>
2.2.1 define a new clock
You should change following code in kernel/arch/arm/mach-msm/clock-8226.c to use camss clock
</p>
<pre class="code">  CLK_LOOKUP(&quot;cam_gp1_clk&quot;, camss_gp1_clk.c, &quot;mdss_dsi_panel&quot;),</pre>

<p>
Please notice, there is old code with the empty third parameter. Please change.
</p>

<p>
2.2.2 open the new clock
Sample code is like following:
</p>
<pre class="code">  struct device pwm_dev = {.init_name = &quot;mdss_dsi_panel&quot;,};
  static struct clk *pwm_gp1_clk = NULL;
  pwm_gp1_clk = clk_get(&amp;pwm_dev, &quot;cam_gp1_clk&quot;);
  if (IS_ERR(pwm_gp1_clk))
  {
      printk(&quot;%s: Get cam_gp1_clk error!!!\n&quot;, __func__);
      pwm_gp1_clk = NULL;
      return;
  }</pre>

<p>
Please notice following things:
</p>
<pre class="code">  The pwm_dev.init_name should match the third parameter of CLK_LOOKUP.
  The clk_get&#039;s second parameter should match the first parameter of CLK_LOOKUP.</pre>

<p>
2.2.3 enable the clock
Sample code is like following:
</p>
<pre class="code">  clk_set_rate(pwm_gp1_clk, 24000);
  ret = clk_prepare_enable(pwm_gp1_clk);
  if (ret)
  {
      printk(&quot;%s: clk_prepare error!!!\n&quot;, __func__);
      return;
  }</pre>

<p>
Please notice, if you do not change the code, you can use following frequency. For other values, please raise case to check.
For pin 12, 16, 17, 49, 50, 51, you can use 24000 and 19200000
For pin 33, 34, you can use 10000, 24000, 6000000, 12000000, 13000000, and 24000000.
</p>

<p>
2.3 Adjsut the duty value
Sample code is like following:
</p>
<pre class="code">  unsigned int * mmss_gp1_d_address = NULL;
  unsigned int * mmss_gp1_cmd_RCGR_address = NULL;
  mmss_gp1_d_address = (unsigned int *)(((unsigned char *)virt_bases[MMSS_BASE]) + MMSS_GP1_D);
  mmss_gp1_cmd_RCGR_address = (unsigned int *)(((unsigned char *)virt_bases[MMSS_BASE]) + MMSS_GP1_CMD_RCGR);</pre>
<pre class="code">  mmss_gp1_d_address[0] = (~( N * level / 100)) &amp; 0x0ff;
  mb();
  mmss_gp1_cmd_RCGR_address[0] = 0x3;
  mb();</pre>

<p>
Please notice you should always write 3 to RCGR to active the level setting.
Please notice the level in above code is 0 - 100.
Please notice N is the last parameter of the F_MMSS, that is, 50 for 24kHz:
</p>

<p>
3. Sample code:
static void set_pwm_gpio(int level)
{
</p>
<pre class="code">  pr_err(&quot;%s: level=%d\n&quot;, __func__, level);</pre>
<pre class="code">  if (NULL == pwm_gp1_clk)
  {
      gpio_tlmm_config(GPIO_CFG(
          BL_GPIO, 3,
          GPIO_CFG_OUTPUT,
          GPIO_CFG_PULL_UP,
          GPIO_CFG_4MA),
          GPIO_CFG_ENABLE);
      msleep(10);
      pwm_gp1_clk = clk_get(&amp;pwm_dev, &quot;cam_gp1_clk&quot;);
      if (IS_ERR(pwm_gp1_clk))
      {
          printk(&quot;%s: Get cam_gp1_clk error!!!\n&quot;, __func__);
          pwm_gp1_clk = NULL;
          return;
      }
             
      clk_set_rate(pwm_gp1_clk, 24000);
      clk_prepare_enable(pwm_gp1_clk);
  }
             
  mmss_gp1_d_address[0] = level;
  mb();
  mmss_gp1_cmd_RCGR_address[0] = 0x3;
  mb();
  return;</pre>

<p>
}
</p>

<p>
4. Debug
You can use following method to test if you cannot get the PWM signals from the pin.
4.1 JTAG
If you have JTAG, you can use following cmm to check whether the clock is correct or not.
core\systemdrivers\clock\scripts\msm8926\testclock.cmm
</p>

<p>
4.2 printk
If you do not have JTAG, please dump below register, check if it is same as your setting, and raise case.
unsigned int * gcc_gp1_cbcr = (unsigned int * )<sup><a href="#fn__1" id="fnt__1" class="fn_top">1)</a></sup>);
</p>

<p>
4.3 debugfs
You can also mount the debugfs, and check the signal with oscilloscope. The steps are following:
adb root
adb shell
mount -t debugfs none /sys/kernel/debug
</p>

<p>
cd /sys/kernel/debug/clk/[clock name]
cat enable
# should return 1
cat rate
# should return the clock frequency
</p>
<div class="footnotes">
<div class="fn"><sup><a href="#fnt__1" id="fn__1" class="fn_bot">1)</a></sup> 
(unsigned char *)gcc_base) + 0x1900);
printk(“GCC_GP1_CBCR[0x%08x] value is 0x%08x\n.”, (unsigned int)&amp;(gcc_gp1_cbcr[0]), gcc_gp1_cbcr[0]);
printk(“GCC_GP1_CMD_RCGR value is 0x%08x\n.”, gcc_gp1_cbcr[1]);
printk(“GCC_GP1_CFG_RCGR value is 0x%08x\n.”, gcc_gp1_cbcr[2]);
printk(“GCC_GP1_M value is 0x%08x\n.”, gcc_gp1_cbcr[3]);
printk(“GCC_GP1_N value is 0x%08x\n.”, gcc_gp1_cbcr[4]);
printk(“GCC_GP1_D value is 0x%08x\n.”, gcc_gp1_cbcr[5]);
printk(“TLMM_GPIO_CFG_34 value is 0x%08x\n.”, *((unsigned int *)ioremap(0xFD511220, 4</div>
</div>
