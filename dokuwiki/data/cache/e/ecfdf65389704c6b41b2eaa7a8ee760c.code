uniform mat4 u_MVPMatrix<span class="sy0">;</span>		<span class="co1">// A constant representing the combined model/view/projection matrix.      		       </span>
uniform mat4 u_MVMatrix<span class="sy0">;</span>		<span class="co1">// A constant representing the combined model/view matrix.       		</span>
&nbsp;
attribute vec4 a_Position<span class="sy0">;</span>		<span class="co1">// Per-vertex position information we will pass in.   				</span>
attribute vec4 a_Color<span class="sy0">;</span>			<span class="co1">// Per-vertex color information we will pass in. 				</span>
attribute vec3 a_Normal<span class="sy0">;</span>		<span class="co1">// Per-vertex normal information we will pass in.      </span>
attribute vec2 a_TexCoordinate<span class="sy0">;</span> <span class="co1">// Per-vertex texture coordinate information we will pass in. 		</span>
&nbsp;
varying vec3 v_Position<span class="sy0">;</span>		<span class="co1">// This will be passed into the fragment shader.       		</span>
varying vec4 v_Color<span class="sy0">;</span>			<span class="co1">// This will be passed into the fragment shader.          		</span>
varying vec3 v_Normal<span class="sy0">;</span>			<span class="co1">// This will be passed into the fragment shader.  </span>
varying vec2 v_TexCoordinate<span class="sy0">;</span>   <span class="co1">// This will be passed into the fragment shader.    		</span>
&nbsp;
<span class="co1">// The entry point for our vertex shader.  </span>
<span class="kw4">void</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>                                                 	
<span class="br0">&#123;</span>                                                         
	<span class="co1">// Transform the vertex into eye space. 	</span>
	v_Position <span class="sy0">=</span> vec3<span class="br0">&#40;</span>u_MVMatrix <span class="sy0">*</span> a_Position<span class="br0">&#41;</span><span class="sy0">;</span>            
&nbsp;
	<span class="co1">// Pass through the color.</span>
	v_Color <span class="sy0">=</span> a_Color<span class="sy0">;</span>
&nbsp;
	<span class="co1">// Pass through the texture coordinate.</span>
	v_TexCoordinate <span class="sy0">=</span> a_TexCoordinate<span class="sy0">;</span>                                      
&nbsp;
	<span class="co1">// Transform the normal's orientation into eye space.</span>
    v_Normal <span class="sy0">=</span> vec3<span class="br0">&#40;</span>u_MVMatrix <span class="sy0">*</span> vec4<span class="br0">&#40;</span>a_Normal, <span class="nu0">0.0</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
	<span class="co1">// gl_Position is a special variable used to store the final position.</span>
	<span class="co1">// Multiply the vertex by the matrix to get the final point in normalized screen coordinates.</span>
	gl_Position <span class="sy0">=</span> u_MVPMatrix <span class="sy0">*</span> a_Position<span class="sy0">;</span>                       		  
<span class="br0">&#125;</span>                                                          
&nbsp;
<span class="sy0">&lt;</span>code java<span class="sy0">&gt;</span>
&nbsp;
（<span class="nu0">2</span>）per_pixel_fragment_shader.<span class="me1">glsl</span>
<span class="sy0">&lt;</span>code java<span class="sy0">&gt;</span>
precision mediump <span class="kw4">float</span><span class="sy0">;</span>       	<span class="co1">// Set the default precision to medium. We don't need as high of a </span>
								<span class="co1">// precision in the fragment shader.</span>
uniform vec3 u_LightPos<span class="sy0">;</span>       	<span class="co1">// The position of the light in eye space.</span>
uniform sampler2D u_Texture<span class="sy0">;</span>    <span class="co1">// The input texture.</span>
&nbsp;
varying vec3 v_Position<span class="sy0">;</span>		<span class="co1">// Interpolated position for this fragment.</span>
varying vec4 v_Color<span class="sy0">;</span>          	<span class="co1">// This is the color from the vertex shader interpolated across the </span>
  								<span class="co1">// triangle per fragment.</span>
varying vec3 v_Normal<span class="sy0">;</span>         	<span class="co1">// Interpolated normal for this fragment.</span>
varying vec2 v_TexCoordinate<span class="sy0">;</span>   <span class="co1">// Interpolated texture coordinate per fragment.</span>
&nbsp;
<span class="co1">// The entry point for our fragment shader.</span>
<span class="kw4">void</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>                    		
<span class="br0">&#123;</span>                              
    <span class="co1">// Will be used for attenuation.</span>
    <span class="kw4">float</span> distance <span class="sy0">=</span> length<span class="br0">&#40;</span>u_LightPos <span class="sy0">-</span> v_Position<span class="br0">&#41;</span><span class="sy0">;</span>                  
&nbsp;
    <span class="co1">// Get a lighting direction vector from the light to the vertex.</span>
    vec3 lightVector <span class="sy0">=</span> normalize<span class="br0">&#40;</span>u_LightPos <span class="sy0">-</span> v_Position<span class="br0">&#41;</span><span class="sy0">;</span>              	
&nbsp;
    <span class="co1">// Calculate the dot product of the light vector and vertex normal. If the normal and light vector are</span>
    <span class="co1">// pointing in the same direction then it will get max illumination.</span>
    <span class="kw4">float</span> diffuse <span class="sy0">=</span> max<span class="br0">&#40;</span>dot<span class="br0">&#40;</span>v_Normal, lightVector<span class="br0">&#41;</span>, <span class="nu0">0.0</span><span class="br0">&#41;</span><span class="sy0">;</span>               	  		  													  
&nbsp;
    <span class="co1">// Add attenuation. </span>
    diffuse <span class="sy0">=</span> diffuse <span class="sy0">*</span> <span class="br0">&#40;</span><span class="nu0">1.0</span> <span class="sy0">/</span> <span class="br0">&#40;</span><span class="nu0">1.0</span> <span class="sy0">+</span> <span class="br0">&#40;</span><span class="nu0">0.10</span> <span class="sy0">*</span> distance<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Add ambient lighting</span>
    diffuse <span class="sy0">=</span> diffuse <span class="sy0">+</span> <span class="nu0">0.3</span><span class="sy0">;</span>  
    <span class="co1">// Multiply the color by the diffuse illumination level and texture value to get final output color.</span>
    gl_FragColor <span class="sy0">=</span> <span class="br0">&#40;</span>v_Color <span class="sy0">*</span> diffuse <span class="sy0">*</span> texture2D<span class="br0">&#40;</span>u_Texture, v_TexCoordinate<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>                                  		
<span class="br0">&#125;</span>                                                                     	