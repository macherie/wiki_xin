
<h2 class="sectionedit1" id="音频相关零碎知识点">音频相关零碎知识点</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <strong>硬件拓扑图</strong></div>
</li>
</ul>

<p>
<a href="/dokuwiki/lib/exe/detail.php/android;driver;hw_blocks.png?id=android%3Adriver%3Aaudio" class="media" title="android:driver:hw_blocks.png"><img src="/dokuwiki/lib/exe/fetch.php/android;driver;hw_blocks.png" class="media" alt="" /></a>
</p>
<ul>
<li class="level1"><div class="li"> <strong>硬件接口数据流向图</strong></div>
</li>
</ul>

<p>
<a href="/dokuwiki/lib/exe/detail.php/android;driver;hw_blocks_diagram.png?id=android%3Adriver%3Aaudio" class="media" title="android:driver:hw_blocks_diagram.png"><img src="/dokuwiki/lib/exe/fetch.php/android;driver;hw_blocks_diagram.png" class="media" alt="" /></a>
</p>
<ul>
<li class="level1"><div class="li"> <strong>软件接口数据流向图</strong></div>
</li>
</ul>

<p>
<a href="/dokuwiki/lib/exe/detail.php/android;driver;sw_blocks.png?id=android%3Adriver%3Aaudio" class="media" title="android:driver:sw_blocks.png"><img src="/dokuwiki/lib/exe/fetch.php/android;driver;sw_blocks.png" class="media" alt="" /></a>
</p>
<ul>
<li class="level1"><div class="li"> <strong>播放音频（Audio Playback）大致步骤</strong></div>
</li>
</ul>
<pre class="code">1、Framework 调用 OpenMAX IL 把比特流（未解码的二进制）传给 aDSP。
2、aDSP把接收到的比特流（未解码的二进制）解码成PCM然后回传给OpenMAX IL（Framework）。
3、Framework通过AudioFlinger把PCM传递到audio的HAL层，audio HAL再把PCM传递到kernel。
4、PCM的kernel driver再把PCM回传给aDSP。
5、aDSP最后把PCM传递给D/A codec转换成模拟信号输出到speaker。</pre>
<ul>
<li class="level1"><div class="li"> <strong>接听电话（Voice Call RX Path）大致步骤</strong></div>
</li>
</ul>
<pre class="code">1、启动声卡设备
2、协议栈那边通过MVS（multimode voice services）接口mvs_acquire/mvs_enable启动vocoder service （vocoder和codec概念类似，可以翻译成声码器，用来编解码voice，codec主要用来编解码“音乐”）。
3、Vocoder从mDSP那里接受到vocoder封包转发给aDSP去解码。
4、aDSP解码vocoder的封包到PCM，然后再把PCM路由到AFE（Audio Front End）。
5、AFE（Audio Front End）把PCM传递给D/A codec转换成模拟信号输出到speaker。</pre>
<ul>
<li class="level1"><div class="li"> <strong>接听电话（Voice Call RX Path）大致步骤</strong></div>
</li>
</ul>
<pre class="code">&lt;del&gt;这个我也不知道，谁知道的填下先。&lt;/del&gt;</pre>
<ul>
<li class="level1"><div class="li"> <strong>音频解码</strong></div>
</li>
</ul>
<pre class="code">多个audio playback同时解码时不考虑他们的格式、比特流、采样率只有一个能使用硬件加速，其他的全部采用软解
采样频率：将模拟声音波形进行数字化时每秒钟抽取的声波幅度样本的次数，一般正常人的听觉范围20Hz-20KHz。根据奈奎斯特理论保证人耳听到的保值采样率应该是40KHz。高通的8x25系列所支持的最高采样率是48KHz。</pre>
<div class="table sectionedit2"><table class="inline">
	<tr class="row0">
		<td class="col0"> PCM playback </td><td class="col1"> 采样率:48 KHz </td>
	</tr>
	<tr class="row1">
		<td class="col0"> AAC decode </td><td class="col1"> 硬件加速 比特率:384 kbps采样率:48 KHz </td>
	</tr>
	<tr class="row2">
		<td class="col0"> AAC+decode </td><td class="col1"> 硬件加速 比特率:384 kbps采样率:48 KHz </td>
	</tr>
	<tr class="row3">
		<td class="col0"> eAAC+decode </td><td class="col1"> 硬件加速 比特率:384 kbps采样率:48 KHz </td>
	</tr>
	<tr class="row4">
		<td class="col0"> AMR-NB decode </td><td class="col1"> 软件 </td>
	</tr>
	<tr class="row5">
		<td class="col0"> AMR-WB decode </td><td class="col1"> 软件 </td>
	</tr>
	<tr class="row6">
		<td class="col0"> EVRC decode </td><td class="col1"> 硬件加速 </td>
	</tr>
	<tr class="row7">
		<td class="col0"> MP3 decode </td><td class="col1"> 硬件加速 比特率:320 kbps采样率:48 KHz </td>
	</tr>
	<tr class="row8">
		<td class="col0"> WMA playback (end-to-end) </td><td class="col1"> WMA7 WMA8 WMA9能达到384 kbps </td>
	</tr>
</table></div>
<!-- EDIT2 TABLE [1912-2357] --><ul>
<li class="level1"><div class="li"> <strong>音频编码</strong></div>
</li>
</ul>
<div class="table sectionedit3"><table class="inline">
	<tr class="row0">
		<td class="col0"> PCM record </td><td class="col1"> 硬件加速 OpenMAX </td>
	</tr>
	<tr class="row1">
		<td class="col0"> AAC encode </td><td class="col1"> 软件48KHZ </td>
	</tr>
	<tr class="row2">
		<td class="col0"> AMR-NB encode (normal recording) </td><td class="col1"> 硬件编码 </td>
	</tr>
	<tr class="row3">
		<td class="col0"> EVRC encode </td><td class="col1"> 硬件加速 最大12.2 Kbps </td>
	</tr>
	<tr class="row4">
		<td class="col0"> QCELP encode </td><td class="col1"> 硬件加速 </td>
	</tr>
	<tr class="row5">
		<td class="col0"> Voice call recording </td><td class="col1"> 硬件加速(QCELP/EVRC/AMR-NB) </td>
	</tr>
	<tr class="row6">
		<td class="col0"> Codec interface-audio encode </td><td class="col1"> QCELP/EVRC/AMR-NB </td>
	</tr>
</table></div>
<!-- EDIT3 TABLE [2381-2690] --><ul>
<li class="level1"><div class="li"> <strong>Audio的hal的调用（即aDSP操作）流程如下</strong></div>
</li>
</ul>

<p>
<a href="/dokuwiki/lib/exe/detail.php/android;driver;audiohardware_flow.png?id=android%3Adriver%3Aaudio" class="media" title="android:driver:audiohardware_flow.png"><img src="/dokuwiki/lib/exe/fetch.php/android;driver;audiohardware_flow.png" class="media" alt="" /></a>
</p>
<ul>
<li class="level1"><div class="li"> <strong>Modem的mDSP操作流程如下</strong></div>
</li>
</ul>

<p>
<a href="/dokuwiki/lib/exe/detail.php/android;driver;mdsp_flow.png?id=android%3Adriver%3Aaudio" class="media" title="android:driver:mdsp_flow.png"><img src="/dokuwiki/lib/exe/fetch.php/android;driver;mdsp_flow.png" class="media" alt="" /></a>
</p>
<ul>
<li class="level1"><div class="li"> <strong>耳机检测</strong></div>
</li>
</ul>
<pre class="code">在hs_gpio_cfg_s.c文件中的下面数组中增加一条</pre>
<pre class="code c">hs_gpio_info_type hsi_gpio_info<span class="br0">&#91;</span>HS_GPIO_LAST<span class="br0">&#93;</span> <span class="sy0">=</span>
<span class="br0">&#123;</span>
  <span class="br0">&#123;</span><span class="nu0">41</span><span class="sy0">,</span>GPIO_IN_41_HSD_SKUD<span class="sy0">,</span> <span class="nu0">1</span><span class="sy0">,</span><span class="nu0">150</span><span class="sy0">,</span> TRUE <span class="br0">&#125;</span><span class="sy0">,</span> 
  <span class="br0">&#123;</span><span class="nu0">41</span><span class="sy0">,</span>GPIO_IN_41_HSD_SKUD<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span><span class="nu0">150</span><span class="sy0">,</span> TRUE <span class="br0">&#125;</span><span class="sy0">,</span> 
  <span class="br0">&#123;</span>HS_PM_GPIO_9<span class="sy0">,</span>GPIO_GENERIC_DEFAULT<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span><span class="nu0">150</span><span class="sy0">,</span> TRUE <span class="br0">&#125;</span><span class="sy0">,</span> 
  ……
<span class="br0">&#125;</span>
&nbsp;
<span class="coMULTI">/*上面结构数组的结构成员含义*/</span>
<span class="kw4">typedef</span> <span class="kw4">struct</span>
<span class="br0">&#123;</span>
  gpio_num<span class="sy0">;</span> <span class="co1">//用来做耳机检测的中断pin脚</span>
  gpio_config<span class="sy0">;</span>
  gpio_active_level<span class="sy0">;</span><span class="co1">//插入后中断pin脚应该呈现的状态</span>
  gpio_debounce_interval<span class="sy0">;</span>
  gpio_uses_irq<span class="sy0">;</span><span class="co1">//是否配置成中断。</span>
<span class="br0">&#125;</span> hs_gpio_info_type<span class="sy0">;</span></pre>
<pre class="code">如果是使用PMIC的gpio做耳机的中断检测pin，使用方法一样，我已经把使用pmic的gpio做耳机中断检测功能整合到一起了，使用的时候只用把 gpio_config成员变量配置成GPIO_GENERIC_DEFAULT，其他成员变量功能一致。
配置耳机中断还需注意两个地方，在board_gpio_setting_skud()函数中是否把中断pin配置成了输入(BSP_GPIO_INPUT)且要配置成TLMM_OWNER_MASTER。</pre>

</div>
