a:442:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:0;}i:2;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:"NFC(近场通信)";}i:2;i:1;}i:3;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18;}i:4;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18;}i:5;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:374:"NFC是一套短距离的无线通信，通常距离是4厘米或更短。NFC工作频率是13.56M Hz,传输速率是106kbit/s 到848kbit/s. NFC总是在一个发起者和一个被动目标之间发生。发起者发出近场无线电波，这个近场可以给被动目标供电。这些被动的目标包括不需要电源的标签，卡，也可以是有电源的设备。";}i:2;i:20;}i:6;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:394;}i:7;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:394;}i:8;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:216:"与其他无线通信技术比较， 例如蓝牙和WiFi， NFC提供更低带宽和距离，并且低成本，不需要供电，不需要实现匹配，整个通信过程仅仅是短短的靠近一秒就能完成。";}i:2;i:396;}i:9;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:612;}i:10;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:612;}i:11;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:197:"一个带有NFC支持的android设备通常是一个发起者。也可以作为NFC的读写设备。他将检测NFC tags并且打开一个Activity来处理. Android 2.3.3还有支持有限的P2P。";}i:2;i:614;}i:12;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:811;}i:13;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:811;}i:14;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:262:"Tags分很多种，其中简单的只提供读写段，有的只能读。复杂的tags可以支持一些运算，加密来控制对tags里数据段的读写。甚至一些tags上有简单的操作系统，允许一些复杂的交互和可以执行一些代码。";}i:2;i:813;}i:15;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1075;}i:16;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1075;}i:17;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:"API概览";}i:2;i:1077;}i:18;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1086;}i:19;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1086;}i:20;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:135:"Android.nfc  package包含顶层类用来与本地NFC适配器交互. 这些类可以表示被检测到的tags和用NDEF数据格式。";}i:2;i:1088;}i:21;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1223;}i:22;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1223;}i:23;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:"Class";}i:2;i:1225;}i:24;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1230;}i:25;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1230;}i:26;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:"Description";}i:2;i:1234;}i:27;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1245;}i:28;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1245;}i:29;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:"NfcManager";}i:2;i:1247;}i:30;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1257;}i:31;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1257;}i:32;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:244:"一个NFC adapter的管理器，可以列出所有此android设备支持的NFC adapter.只不过大部分android 设备只有一个NFC adapter，所以你大部分情况下可以直接用静态方法 getDefaultAdapter(context)来取适配器。";}i:2;i:1261;}i:33;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1505;}i:34;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1505;}i:35;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:"NfcAdapter";}i:2;i:1507;}i:36;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1517;}i:37;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1517;}i:38;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:255:"表示本设备的NFC adapter,可以定义Intent来请求将系统检测到tags的提醒发送到你的Activity.并提供方法去注册前台tag提醒发布和前台NDEF推送。 前台NDEF推送是当前android版本唯一支持的p2p NFC通信方式。";}i:2;i:1521;}i:39;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1776;}i:40;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1776;}i:41;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:"NdefMessage and NdefRecord";}i:2;i:1778;}i:42;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1804;}i:43;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1804;}i:44;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:457:"NDEF是NFC论坛定义的数据结构，用来有效的存数据到NFC tags.比如文本，URL，和其他MIME类型。一个NdefMessage扮演一个容器，这个容器存哪些发送和读到的数据。一个NdefMessage对象包含0或多个NdefRecord,每个NDEF record有一个类型，比如文本，URL，智慧型海报/广告，或其他MIME数据。在NDEFMessage里的第一个NfcRecord的类型用来发送tag到一个android设备上的activity.";}i:2;i:1808;}i:45;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2265;}i:46;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2265;}i:47;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"Tag";}i:2;i:2267;}i:48;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2270;}i:49;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2270;}i:50;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:107:"标示一个被动的NFC目标，比如tag，card，钥匙挂扣，甚至是一个电话模拟的的NFC卡.";}i:2;i:2274;}i:51;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2381;}i:52;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2381;}i:53;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:334:"当一个tag被检测到，一个tag对象将被创建并且封装到一个Intent里，然后NFC 发布系统将这个Intent用startActivity发送到注册了接受这种Intent的activity里。你可以用getTechList()方法来得到这个tag支持的技术细节和创建一个android.nfc.tech提供的相应的TagTechnology对象。";}i:2;i:2383;}i:54;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2717;}i:55;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2717;}i:56;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:148:"android.nfc.tech package 包含那些对tag查询属性和进行I/O操作的类。这些类分别标示一个tag支持的不同的NFC技术标准。";}i:2;i:2719;}i:57;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2867;}i:58;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2867;}i:59;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:"Class";}i:2;i:2869;}i:60;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2874;}i:61;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2874;}i:62;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:"Description";}i:2;i:2878;}i:63;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2889;}i:64;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2889;}i:65;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:"TagTechnology";}i:2;i:2891;}i:66;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2904;}i:67;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2904;}i:68;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:62:"这个接口是下面所有tag technology类必须实现的。";}i:2;i:2908;}i:69;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2970;}i:70;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2970;}i:71;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"NfcA";}i:2;i:2972;}i:72;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2976;}i:73;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2976;}i:74;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:107:"支持ISO 14443-3A 标准的操作。Provides access to NFC-A (ISO 14443-3A) properties and I/O operations.";}i:2;i:2980;}i:75;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3087;}i:76;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3087;}i:77;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:75:"NfcB Provides access to NFC-B (ISO 14443-3B) properties and I/O operations.";}i:2;i:3089;}i:78;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3164;}i:79;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3164;}i:80;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:73:"NfcF Provides access to NFC-F (JIS 6319-4) properties and I/O operations.";}i:2;i:3166;}i:81;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3239;}i:82;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3239;}i:83;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:72:"NfcV Provides access to NFC-V (ISO 15693) properties and I/O operations.";}i:2;i:3241;}i:84;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3313;}i:85;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3313;}i:86;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:78:"IsoDep Provides access to ISO-DEP (ISO 14443-4) properties and I/O operations.";}i:2;i:3315;}i:87;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3393;}i:88;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3393;}i:89;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:81:"Ndef 提供对那些被格式化为NDEF的tag的数据的访问和其他操作。";}i:2;i:3395;}i:90;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3476;}i:91;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3476;}i:92;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:89:"Provides access to NDEF data and operations on NFC tags that have been formatted as NDEF.";}i:2;i:3478;}i:93;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3567;}i:94;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3567;}i:95;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:14:"NdefFormatable";}i:2;i:3569;}i:96;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3583;}i:97;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3583;}i:98;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:76:"对那些可以被格式化成NDEF格式的tag提供一个格式化的操作";}i:2;i:3587;}i:99;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3663;}i:100;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3663;}i:101;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:"MifareClassic";}i:2;i:3665;}i:102;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3678;}i:103;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3678;}i:104;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:87:"如果android设备支持MIFARE，提供对MIFARE Classic目标的属性和I/O操作。";}i:2;i:3682;}i:105;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3769;}i:106;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3769;}i:107;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"MifareUltralight";}i:2;i:3771;}i:108;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3787;}i:109;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3787;}i:110;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:90:"如果android设备支持MIFARE，提供对MIFARE Ultralight目标的属性和I/O操作。";}i:2;i:3791;}i:111;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3881;}i:112;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3881;}i:113;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:35:"声明Android Manifest.xml的元素";}i:2;i:3883;}i:114;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3918;}i:115;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3918;}i:116;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:133:"在你能访问一个设备的NFC硬件和正确的处理NFC的Intent之前，需要在AndroidManifest.xml中先声明下面的项：";}i:2;i:3920;}i:117;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4053;}i:118;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4053;}i:119;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:"1.     NFC使用 <uses-permission> 元素来访问NFC硬件:";}i:2;i:4055;}i:120;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4115;}i:121;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4115;}i:122;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:30:"<uses-permission android:name=";}i:2;i:4117;}i:123;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:4147;}i:124;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"android.permission.NFC";}i:2;i:4148;}i:125;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:4170;}i:126;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" />";}i:2;i:4171;}i:127;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4174;}i:128;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4174;}i:129;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:91:"2.     最小SDK版本需要设置正确，API level 9只包含有限的tag支持,包括：";}i:2;i:4176;}i:130;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4267;}i:131;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:154:"  .通过ACTION_TAG_DISCOVERED来发布Tag信息
  .只有通过EXTRA_NDEF_MESSAGES扩展来访问NDEF消息
  .其他的tag属性和I/O操作都不支持";}i:2;i:4267;}i:132;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4267;}i:133;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:78:"所以你可能想要用API level 10来实现对tag的广泛的读写支持。";}i:2;i:4429;}i:134;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4507;}i:135;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4507;}i:136;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:32:"<uses-sdk android:minSdkVersion=";}i:2;i:4509;}i:137;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:4541;}i:138;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"10";}i:2;i:4542;}i:139;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:4544;}i:140;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"/>";}i:2;i:4545;}i:141;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4547;}i:142;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4547;}i:143;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:93:"3.     uses-feature 元素定义：你的程序可以再android市场里显示有NFC硬件。";}i:2;i:4549;}i:144;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4642;}i:145;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4642;}i:146;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:27:"<uses-feature android:name=";}i:2;i:4644;}i:147;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:4671;}i:148;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:"android.hardware.nfc";}i:2;i:4672;}i:149;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:4692;}i:150;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:" android:required=";}i:2;i:4693;}i:151;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:4711;}i:152;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"true";}i:2;i:4712;}i:153;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:4716;}i:154;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" />";}i:2;i:4717;}i:155;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4720;}i:156;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4720;}i:157;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:118:"4.      NFC intent filter告诉android系统你的activity能处理NFC数据，可以定义1个或多个intent filter:";}i:2;i:4722;}i:158;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4840;}i:159;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4840;}i:160;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"<intent-filter>";}i:2;i:4842;}i:161;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4857;}i:162;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:97:"<action android:name="android.nfc.action.NDEF_DISCOVERED"/>
<data android:mimeType="mime/type" />";}i:2;i:4857;}i:163;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4857;}i:164;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"</intent-filter>";}i:2;i:4960;}i:165;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4976;}i:166;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4976;}i:167;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"<intent-filter>";}i:2;i:4978;}i:168;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4993;}i:169;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:181:"<action android:name="android.nfc.action.TECH_DISCOVERED"/>
<meta-data android:name="android.nfc.action.TECH_DISCOVERED"
              android:resource="@xml/nfc_tech_filter.xml" />";}i:2;i:4993;}i:170;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4993;}i:171;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"</intent-filter>";}i:2;i:5182;}i:172;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5198;}i:173;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5198;}i:174;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"<intent-filter>";}i:2;i:5200;}i:175;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5215;}i:176;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:58:"<action android:name="android.nfc.action.TAG_DISCOVERED"/>";}i:2;i:5215;}i:177;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5215;}i:178;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"</intent-filter>";}i:2;i:5277;}i:179;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5293;}i:180;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5293;}i:181;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:85:"上边3个intent filters 有优先级，更多信息可以看下面的Tag发布系统";}i:2;i:5295;}i:182;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5380;}i:183;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5380;}i:184;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:75:"也可以看NFCDemo例子的 AndroidManifest.xml来有个更深的理解。";}i:2;i:5382;}i:185;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5457;}i:186;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5457;}i:187;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"Tag发布系统";}i:2;i:5459;}i:188;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5474;}i:189;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5474;}i:190;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:611:"当android设备扫描到一个NFC tag，通用的行为是自动找最合适的Activity会处理这个tag Intent而不需要用户来选择哪个Activity来处理。因为设备扫描NFC tags是在很短的范围和时间，如果让用户选择的话，那就有可能需要移动设备，这样将会打断这个扫描过程。你应该开发你只处理需要处理的tags的Activity，以防止让用户选择使用哪个Activity来处理的情况。Android提供两个系统来帮助你正确的识别一个NFC tag是否是你的Activity想要处理的：Intent发布系统和前台Activity发布系统。";}i:2;i:5476;}i:191;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6087;}i:192;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6087;}i:193;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:315:"Intent发布系统检查所有Activities的intent filters，找出那些定义了可以处理此tag的Activity，如果有多个Activity都配置了处理同一个tag Intent，那么将使用Activity选择器来让用户选择使用哪个Activity。用户选择之后，将使用选择的Activity来处理此Intent.";}i:2;i:6089;}i:194;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6404;}i:195;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6404;}i:196;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:356:"前台发布系统允许一个Activity覆盖掉Intent发布系统而首先处理此tag Intent，这要求你将要处理Tag Intent的Activity运行在前台，这样当一个NFC tag被扫描到，系统先检测前台的Activity是否支持处理此Intent，如果支持，即将此Intent传给此Activity，如果不支持，则转到Intent发布系统。";}i:2;i:6406;}i:197;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6762;}i:198;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6762;}i:199;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:"使用Intent发布系统";}i:2;i:6764;}i:200;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6788;}i:201;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6788;}i:202;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:166:"Intent发布系统指定了3个intent有不同的优先级。通常当一个tag被检测到之后，Intent就被启动（start）了，这个启动遵循以下行为:";}i:2;i:6790;}i:203;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6956;}i:204;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6956;}i:205;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:529:"·         android.nfc.action.NDEF_DISCOVERED: 这个intent是在一个包含NDEF负载的tag被检测到时启动，这是最高优先级的intent, android系统不会让你指定一个Intent能处理所有的NFC数据类型，你必须在AndroidManifest.xml中指定与NFC tag对应的<data>元素，这样当扫描到的tag传过来的数据类型与你定义的相匹配时，你的Activity就会被调用。例如想处理一个包含plain text 的 NDEF_DISCOVERED intent ，你要按照如下定义AndroidManifest.xml file:";}i:2;i:6958;}i:206;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7487;}i:207;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7487;}i:208;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"<intent-filter>";}i:2;i:7489;}i:209;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7504;}i:210;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:102:"  <action android:name="android.nfc.action.NDEF_DISCOVERED"/>
  <data android:mimeType="text/plain" />";}i:2;i:7504;}i:211;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7504;}i:212;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"</intent-filter>";}i:2;i:7612;}i:213;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7628;}i:214;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7628;}i:215;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:211:"如果NDEF_DISCOVERED intent 已经被启动，TECH_DISCOVERED 和 TAG_DISCOVERED intents 将不会被启动。假如一个未知的tag或者不包含NDEF负载的tag被检测到，此Intent就不会被启动。";}i:2;i:7630;}i:216;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7841;}i:217;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7841;}i:218;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:384:"·         android.nfc.action.TECH_DISCOVERED: 如果 NDEF_DISCOVERED intent没启动或者没有一个Activity的filter检测NDEF_DISCOVERED ，并且此tag是已知的，那么此TECH_DISCOVERED Intent将会启动. TECH_DISCOVERED intent要求你在一个资源文件里(xml)里指定你要支持technologies列表。更多细节请看下面的Specifying tag technologies to handle.";}i:2;i:7843;}i:219;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8227;}i:220;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8227;}i:221;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:183:"·         android.nfc.action.TAG_DISCOVERED: 如果没有一个activity处理_DISCOVERED and TECH_DISCOVERED intents或者tag被检测为未知的，那么此Intent将会被启动。";}i:2;i:8229;}i:222;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8412;}i:223;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8412;}i:224;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:64:"Specifying tag technologies to handle指定处理的technologies";}i:2;i:8414;}i:225;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8478;}i:226;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8478;}i:227;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:453:"假如你的Activity在AndroidManifest.xml文件里声明了处理android.nfc.action.TECH_DISCOVERED intent ，你必须创建一个Xml格式的资源文件，并加上你的activity支持的technologies到tech-list集合里。这样你的activity将被认作能处理这些tech-list的处理者，如果tag使用的technology属于你的定义的list里，你的Activity将接收此Intent。你可以用getTechList()来获得tag支持的technologies。";}i:2;i:8480;}i:228;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8933;}i:229;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8933;}i:230;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:191:"例如：如果一个tag被检测到支持MifareClassic, NdefFormatable, 和 NfcA，你的tech-list集合必须指定了其中的一项或者多项来保证你的Activity能处理此Intent。";}i:2;i:8935;}i:231;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9126;}i:232;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9126;}i:233;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:186:"下面是一个资源文件例子，定义了所有的technologies. 你可以根据需要删掉不需要的项，将此文件以任意名字+.xml保存到<project-root>/res/xml文件夹.";}i:2;i:9128;}i:234;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9314;}i:235;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9314;}i:236;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:"<resources xmlns:xliff=";}i:2;i:9316;}i:237;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:9339;}i:238;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:"urn:oasis:names:tc:xliff:document:1.2";}i:2;i:9340;}i:239;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:9377;}i:240;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:">";}i:2;i:9378;}i:241;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9379;}i:242;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:438:"  <tech-list>
      <tech>android.nfc.tech.IsoDep</tech>
      <tech>android.nfc.tech.NfcA</tech>        
      <tech>android.nfc.tech.NfcB</tech>
      <tech>android.nfc.tech.NfcF</tech>
      <tech>android.nfc.tech.NfcV</tech>
      <tech>android.nfc.tech.Ndef</tech>
      <tech>android.nfc.tech.NdefFormatable</tech>
      <tech>android.nfc.tech.MifareClassic</tech>
      <tech>android.nfc.tech.MifareUltralight</tech>
  </tech-list>";}i:2;i:9379;}i:243;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9379;}i:244;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"</resources>";}i:2;i:9841;}i:245;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9853;}i:246;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9853;}i:247;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:332:"你也可以指定多个tech-list集合，每个集合都认做独立的。如果任何单个tech-list集合是getTechList()返回的technologies集合的子集，那么你的Activity将被认为匹配了。这个还提供’与’和’或’操作。下面的例子表示支持 NfcA和NDef的卡，或者支持NfcB和NDef的卡：";}i:2;i:9855;}i:248;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10187;}i:249;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10187;}i:250;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:"<resources xmlns:xliff=";}i:2;i:10189;}i:251;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:10212;}i:252;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:"urn:oasis:names:tc:xliff:document:1.2";}i:2;i:10213;}i:253;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:10250;}i:254;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:">";}i:2;i:10251;}i:255;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10252;}i:256;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:118:"  <tech-list>
      <tech>android.nfc.tech.NfcA</tech>        
      <tech>android.nfc.tech.Ndef</tech>
  </tech-list>";}i:2;i:10252;}i:257;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10252;}i:258;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"</resources>";}i:2;i:10380;}i:259;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10392;}i:260;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10392;}i:261;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:"<resources xmlns:xliff=";}i:2;i:10394;}i:262;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:10417;}i:263;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:"urn:oasis:names:tc:xliff:document:1.2";}i:2;i:10418;}i:264;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:10455;}i:265;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:">";}i:2;i:10456;}i:266;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10457;}i:267;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:118:"  <tech-list>
      <tech>android.nfc.tech.NfcB</tech>        
      <tech>android.nfc.tech.Ndef</tech>
  </tech-list>";}i:2;i:10457;}i:268;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10457;}i:269;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"</resources>";}i:2;i:10585;}i:270;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10597;}i:271;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10597;}i:272;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:148:"在 AndroidManifest.xml 文件中, 指定这个tech-list资源文件的方法是在<activity> 元素中创建<meta-data>元素，例如下面例子:";}i:2;i:10599;}i:273;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10747;}i:274;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10747;}i:275;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:"<activity>
";}i:2;i:10749;}i:276;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:10760;}i:277;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"
<intent-filter>";}i:2;i:10763;}i:278;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10779;}i:279;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:61:"  <action android:name="android.nfc.action.TECH_DISCOVERED"/>";}i:2;i:10779;}i:280;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10779;}i:281;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"</intent-filter>";}i:2;i:10844;}i:282;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10860;}i:283;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10860;}i:284;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:"<meta-data android:name=";}i:2;i:10862;}i:285;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:10886;}i:286;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:34:"android.nfc.action.TECH_DISCOVERED";}i:2;i:10887;}i:287;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:10921;}i:288;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10922;}i:289;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:44:"  android:resource="@xml/nfc_tech_filter" />";}i:2;i:10922;}i:290;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10922;}i:291;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:10970;}i:292;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"
</activity>";}i:2;i:10973;}i:293;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10985;}i:294;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10985;}i:295;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:"使用前台发布系统Using the foreground dispatch system";}i:2;i:10987;}i:296;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11047;}i:297;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11047;}i:298;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:134:"前台发布系统允许一个Activity 拦截一个tag Intent 获得最高优先级的处理，这种方式很容易使用和实现：";}i:2;i:11049;}i:299;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11183;}i:300;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11183;}i:301;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:59:"1.     添加下列代码到Activity的onCreate() 方法里";}i:2;i:11185;}i:302;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11244;}i:303;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11244;}i:304;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:115:"a.     创建一个 PendingIntent 对象, 这样Android系统就能在一个tag被检测到时定位到这个对象";}i:2;i:11246;}i:305;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11361;}i:306;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11361;}i:307;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:56:"PendingIntent pendingIntent = PendingIntent.getActivity(";}i:2;i:11363;}i:308;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11419;}i:309;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:86:"  this, 0, new Intent(this, getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0);";}i:2;i:11419;}i:310;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11419;}i:311;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:442:"b.    在Intent filters里声明你想要处理的Intent，一个tag被检测到时先检查前台发布系统，如果前台Activity符合Intent filter的要求，那么前台的Activity的将处理此Intent。如果不符合，前台发布系统将Intent转到Intent发布系统。如果指定了null的Intent filters，当任意tag被检测到时，你将收到TAG_DISCOVERED intent。因此请注意你应该只处理你想要的Intent。";}i:2;i:11510;}i:312;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11953;}i:313;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:441:"  IntentFilter ndef = new IntentFilter(NfcAdapter.ACTION_NDEF_DISCOVERED);
      try {
          ndef.addDataType("*/*");    /* Handles all MIME based dispatches.
                                         You should specify only the ones that you need. */
      }
      catch (MalformedMimeTypeException e) {
          throw new RuntimeException("fail", e);
      }
      intentFiltersArray = new IntentFilter[] {
              ndef,
      };";}i:2;i:11953;}i:314;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11953;}i:315;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:152:"c.     设置一个你程序要处理的Tag technologies的列表，调用Object.class.getName() 方法来获得你想要支持处理的technology类。";}i:2;i:12419;}i:316;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12571;}i:317;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:74:"techListsArray = new String[][] { new String[] { NfcF.class.getName() } };";}i:2;i:12573;}i:318;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12573;}i:319;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:354:"2.     覆盖下面的方法来打开或关闭前台发布系统。比如onPause()和onResume（）方法。必须在主线程里调用enableForegroundDispatch(Activity, PendingIntent, IntentFilter[], String[][]) 而且Activity在前台（可以在onResume()里调用来保证这点）。你也要覆盖onNewIntent回调来处理得到的NFC tag数据。";}i:2;i:12654;}i:320;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13008;}i:321;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13008;}i:322;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:"public void onPause() {";}i:2;i:13010;}i:323;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13033;}i:324;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:62:"  super.onPause();
  mAdapter.disableForegroundDispatch(this);";}i:2;i:13033;}i:325;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13033;}i:326;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"}  ";}i:2;i:13101;}i:327;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13104;}i:328;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13104;}i:329;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:"public void onResume() {";}i:2;i:13106;}i:330;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13130;}i:331;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:113:"  super.onResume();
  mAdapter.enableForegroundDispatch(this, pendingIntent, intentFiltersArray, techListsArray);";}i:2;i:13130;}i:332;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13130;}i:333;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"}";}i:2;i:13249;}i:334;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13250;}i:335;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13250;}i:336;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:40:"public void onNewIntent(Intent intent) {";}i:2;i:13252;}i:337;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13292;}i:338;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:106:"  Tag tagFromIntent = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);
  //do something with tagFromIntent";}i:2;i:13292;}i:339;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13292;}i:340;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"}";}i:2;i:13404;}i:341;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13405;}i:342;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13405;}i:343;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:39:"See the ForegroundDispatch sample from ";}i:2;i:13407;}i:344;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"API";}i:2;i:13446;}i:345;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:" Demos for the complete sample.";}i:2;i:13449;}i:346;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13480;}i:347;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13480;}i:348;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:25:"使用NFC tag上的数据";}i:2;i:13482;}i:349;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13507;}i:350;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13507;}i:351;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:757:"NFC tag上的数据是以字节存放，所以你可以将其转换成其他你想要的格式。当往tag写东西时，你必须以字节格式来写。Android提供API来帮助写符合NDEF标准的信息。使用此标准能保证你的数据在往tag写时能被所有Android NFC设备支持。然而，很多tag使用他们自己的标准来存储数据，这些标准也被Android支持。但你必须自己实现协议栈来读写这些tag。你可以在android.nfc.tech里找到所有支持的technologies，并且可以在TagTechnology接口里对technology有个了解。这一段是简单介绍在android系统里怎样使用NDEF 消息。这不意味着是一个完整的NDEF功能的介绍。但标出了主要需要注意和使用的东西。";}i:2;i:13509;}i:352;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14266;}i:353;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14266;}i:354;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:638:"为了方便使用NDEF消息，android提供NdefRecord 和 NdefMessage来包装原始字节数据为NDEF消息。一个NdefMessage是保存0个或多个NdefRecords的容器。每个NdefRecord有自己的唯一类型名字格式，记录类型和ID来与其他记录区分开。你可以存储不同类型的记录，不同的长度到同一个 NdefMessage。NFC tag容量的限制决定你的NdefMessage的大小。
那些支持Ndef和NdefFormatable技术的tag可以返回和接受NdefMessage对象为参数来进行读写操作。你需要创建你自己的逻辑来为其他在android.nfc.tech的tag技术实现读写字节的操作。";}i:2;i:14268;}i:355;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14906;}i:356;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14906;}i:357;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"你可以从NFC Forum(";}i:2;i:14908;}i:358;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:31:"http://www.nfc-forum.org/specs/";i:1;N;}i:2;i:14930;}i:359;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:145:")下载NDEF消息标准的技术文档，比如纯文本和智慧型海报. NFCDemo例子里声明了纯文本和智慧型海报的NDef 消息。";}i:2;i:14961;}i:360;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15106;}i:361;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15106;}i:362;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"读一个NFC tag";}i:2;i:15108;}i:363;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15124;}i:364;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15124;}i:365;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:241:"当一个NFC tag靠近一个NFC设备，一个相应的Intent将在设备上被创建。然后通知合适的程序来处理此Intent。
下面的方法处理TAG_DISCOVERED intent并且使用迭代器来获得包含在NDEF tag负载的数据";}i:2;i:15126;}i:366;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15367;}i:367;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15367;}i:368;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:46:"NdefMessage[] getNdefMessages(Intent intent) {";}i:2;i:15369;}i:369;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15415;}i:370;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:834:"  // Parse the intent
  NdefMessage[] msgs = null;
  String action = intent.getAction();
  if (NfcAdapter.ACTION_TAG_DISCOVERED.equals(action)) {
      Parcelable[] rawMsgs = intent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES);
      if (rawMsgs != null) {
          msgs = new NdefMessage[rawMsgs.length];
          for (int i = 0; i < rawMsgs.length; i++) {
              msgs[i] = (NdefMessage) rawMsgs[i];
          }
      }
      else {
      // Unknown tag type
          byte[] empty = new byte[] {};
          NdefRecord record = new NdefRecord(NdefRecord.TNF_UNKNOWN, empty, empty, empty);
          NdefMessage msg = new NdefMessage(new NdefRecord[] {record});
          msgs = new NdefMessage[] {msg};
      }
  }        
  else {
      Log.e(TAG, "Unknown intent " + intent);
      finish();
  }
  return msgs;";}i:2;i:15415;}i:371;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15415;}i:372;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"}";}i:2;i:16299;}i:373;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16300;}i:374;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16300;}i:375;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:243:"请记住NFC设备读到的数据是byte类型，所以你可能需要将他转成其他格式来呈现给用户。NFCDemo例子展示了怎样用com.example.android.nfc.record中的类来解析NDEF消息，比如纯文本和智慧型海报。";}i:2;i:16302;}i:376;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16545;}i:377;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16545;}i:378;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:"写NFC tag";}i:2;i:16547;}i:379;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16557;}i:380;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16557;}i:381;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:162:"往NFC tag写东西涉及到构造一个NDEF 消息和使用与tag匹配的Tag技术。下面的代码展示怎样写一个简单的文本到NdefFormatable tag：";}i:2;i:16559;}i:382;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16721;}i:383;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16721;}i:384;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:138:"NdefFormatable tag = NdefFormatable.get(t);
Locale locale = Locale.US;
final byte[] langBytes = locale.getLanguage().getBytes(Charsets.US_";}i:2;i:16723;}i:385;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:5:"ASCII";}i:2;i:16861;}i:386;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:");
String text = ";}i:2;i:16866;}i:387;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:16883;}i:388;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"Tag, you're it!";}i:2;i:16884;}i:389;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:16899;}i:390;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:324:";
final byte[] textBytes = text.getBytes(Charsets.UTF_8);
final int utfBit = 0;
final char status = (char) (utfBit + langBytes.length);
final byte[] data = Bytes.concat(new byte[] {(byte) status}, langBytes, textBytes);
NdefRecord record = NdefRecord(NdefRecord.TNF_WELL_KNOWN, NdefRecord.RTD_TEXT, new byte[0], data);
try {";}i:2;i:16900;}i:391;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17224;}i:392;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:122:"  NdefRecord[] records = {text};
  NdefMessage message = new NdefMessage(records);
  tag.connect();
  tag.format(message);";}i:2;i:17224;}i:393;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17224;}i:394;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"}
catch (Exception e){";}i:2;i:17356;}i:395;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17378;}i:396;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:21:"  //do error handling";}i:2;i:17378;}i:397;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17378;}i:398;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"}";}i:2;i:17403;}i:399;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17404;}i:400;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17404;}i:401;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:"点对点的数据交换";}i:2;i:17406;}i:402;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17430;}i:403;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17430;}i:404;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:167:"前台推送技术支持简单点对点的数据交换，你可以用enableForegroundNdefPush(Activity, NdefMessage) 方法来打开此功能. 为了用这个功能：";}i:2;i:17432;}i:405;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17599;}i:406;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17599;}i:407;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:"·         推送数据的Activity必须是前台Activity。";}i:2;i:17601;}i:408;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17661;}i:409;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17661;}i:410;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:76:"·         你必须将你要发送的数据封装到NdefMessage对象里。";}i:2;i:17663;}i:411;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17739;}i:412;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17739;}i:413;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:123:"·         接收推送数据的设备必须支持com.android.npp  NDEF推送协议，这个对于Android设备是可选的";}i:2;i:17741;}i:414;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17864;}i:415;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17864;}i:416;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:262:"假如你的Activity打开了前台推送功能并且位于前台，这时标准的Intent发布系统是禁止的。然而，如果你的Activity允许前台发布系统，那么此时检测tag的功能仍然是可用的，不过只适用于前台发布系统。";}i:2;i:17866;}i:417;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18128;}i:418;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18128;}i:419;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"要打开前台推送:";}i:2;i:18130;}i:420;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18152;}i:421;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18152;}i:422;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:86:"1.     创建一个你要推送给其他NFC设备的包含NdefRecords的NdefMessage。";}i:2;i:18154;}i:423;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18240;}i:424;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18240;}i:425;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:272:"2.     在你的Activity里实现onResume() 和 onPause() 的回调来正确处理前台推送的生命周期。你必须在你的Activity位于前台并在主线程里调用enableForegroundNdefPush(Activity, NdefMessage) （可以在onResume()里调用来保证这点）.";}i:2;i:18242;}i:426;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18514;}i:427;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18514;}i:428;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:"public void onResume() {";}i:2;i:18516;}i:429;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18540;}i:430;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:105:"  super.onResume();
  if (mAdapter != null)
      mAdapter.enableForegroundNdefPush(this, myNdefMessage);";}i:2;i:18540;}i:431;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18540;}i:432;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:25:"}
public void onPause() {";}i:2;i:18653;}i:433;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18678;}i:434;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:90:"  super.onPause();
  if (mAdapter != null)
      mAdapter.disableForegroundNdefPush(this);";}i:2;i:18678;}i:435;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18678;}i:436;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"}";}i:2;i:18776;}i:437;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18777;}i:438;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18777;}i:439;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:146:"当Activity位于前台，你可以靠近另外一个NFC设备来推送数据。请参考例子ForegroundNdefPush来了解点对点数据交换。";}i:2;i:18779;}i:440;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18925;}i:441;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:18925;}}