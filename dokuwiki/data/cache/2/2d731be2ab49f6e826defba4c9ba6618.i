a:42:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:0;}i:2;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:1;}i:3;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:"基于C500项目的OTA升级包制作";}i:2;i:3;}i:4;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:40;}i:5;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:42;}i:6;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:42;}i:7;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:44;}i:8;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"客户需求";}i:2;i:46;}i:9;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:58;}i:10;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:95:"：拿到update.zip升级包，可以自己定制，比如修改logo，加入系统应用等。";}i:2;i:60;}i:11;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:155;}i:12;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:155;}i:13;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:157;}i:14;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:"我的思考过程";}i:2;i:159;}i:15;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:177;}i:16;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:227:"：熟悉recovery升级模式的知道，这个update.zip是经过签名的，如果解压原生update.zip，修改完成后，直接打包升级是不能通过验证，所以需要进行签名，度娘会告诉你。命令是:";}i:2;i:179;}i:17;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:412;}i:18;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:99:"java -Xmx2048m -jar signapk.jar -w testkey.x509.pem testkey.pk8 update-origin.zip update-signed.zip";i:1;N;i:2;N;}i:2;i:412;}i:19;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:412;}i:20;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:555:"轻松搞定。但是在升级过程过程中发现，recovery.img是无法升级的，因为它采用了差分升级的方法，升级的过程是在Android系统启动后完成。如果需要升级recovery.img，光靠打包是不行的，所以要找出如何生成这个差分包。我就去build目录下研究整个过程，后来发现这样太麻烦，有那功夫，还不如直接把整个recovery打包过程从Android分离出来，因为在研究脚本的过程中发现，这套流程很独立。于是我摒弃了这套“山寨”做法。";}i:2;i:520;}i:21;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1075;}i:22;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1075;}i:23;a:3:{i:0;s:11:"strong_open";i:1;a:0:{}i:2;i:1077;}i:24;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"真正的工作";}i:2;i:1079;}i:25;a:3:{i:0;s:12:"strong_close";i:1;a:0:{}i:2;i:1094;}i:26;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1096;}i:27;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1096;}i:28;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:225:"我首先想到要从编译过程的输出log中寻找答案，Make otapackage这个命令就是用来制作升级包的，细心的同学会发现在编译的最后会有很多命令输出，其中一行大体是这样的：";}i:2;i:1098;}i:29;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1329;}i:30;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:117:"ota_from_target_files -v -w -x pagesize=4096 -p ./linux-x86/ -d MMC -f 0 -k ./security/testkey target.zip  update.zip";i:1;N;i:2;N;}i:2;i:1329;}i:31;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1329;}i:32;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:509:"OK,其实整个故事就是从这个脚本开始的，这个脚本位于build/tools/releasetools下。参数说明可以查看这个脚本源码，或者直接运行这个脚本，就会有提示。我关注的地方是target.zip，这玩意儿从哪来的？同样我回到编译过程最后的输出log中查找答案，发现这个包就是拷贝自obj/PACKAGING/target_files_intermediates/c500-target_files-版本号-日期.zip，到现在为止其实我的工作就完成了。一切都可以自动化！";}i:2;i:1455;}i:33;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1964;}i:34;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1964;}i:35;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:384:"接下来就是构造环境了，当然是read the fucking codes！，发现ota_from_target_files这个脚本会依赖很多命令，比如imgdiff，mingzip，mkbootfs，mkbootimg，这些命令来自out/host/linux-x86/bin下。还需要security目录下的公钥等等，一切就绪后，就形成了附件offical-update.zip里的环境包，里面的manual.txt就是使用手册。";}i:2;i:1966;}i:36;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2350;}i:37;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2350;}i:38;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:33:":android:other:offical-update.zip";i:1;s:0:"";i:2;N;i:3;N;i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:2352;}i:39;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:0:"";}i:2;i:2390;}i:40;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2390;}i:41;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:2390;}}