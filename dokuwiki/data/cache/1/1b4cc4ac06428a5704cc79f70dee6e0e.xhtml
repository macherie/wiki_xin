
<p>
1.参考网址：
<a href="http://wiki.jikexueyuan.com/project/opengl-es-guide/api.html" class="urlextern" title="http://wiki.jikexueyuan.com/project/opengl-es-guide/api.html"  rel="nofollow">http://wiki.jikexueyuan.com/project/opengl-es-guide/api.html</a>
</p>

<p>
2.简介
Opengl es是适用于嵌入式系统的一个免费的二维和三维图形库，在android中主要在如下包中：
</p>
<ol>
<li class="level1"><div class="li"> android.opengl </div>
</li>
<li class="level1"><div class="li"> javax.microedition.khronos.egl  </div>
</li>
<li class="level1"><div class="li"> javax.microedition.khronos.opengles</div>
</li>
</ol>

<p>
3.Opengl ES <abbr title="Application Programming Interface">API</abbr> 的命名规范
定义的常量都以 GL_开头，如GL_DEPTH_BUFFER_BIT
定义的方法都以gl开头，如glClear()，其中有些指令以3f,4f,3i,3x等结尾，以3f为例，3表示指令所带的参数是3个，f表示所带参数的类型为float
</p>

<p>
4.核心类GLSurfaceView.java,它所起到的作用如下：
</p>
<ol>
<li class="level1"><div class="li"> 起到连接 OpenGL ES 与 Android 的 View 层次结构之间的桥梁作用</div>
</li>
<li class="level1"><div class="li"> 使得 Open GL ES 库适应于 Anndroid 系统的 Activity 生命周期</div>
</li>
<li class="level1"><div class="li"> 使得选择合适的 Frame buffer 像素格式变得容易</div>
</li>
<li class="level1"><div class="li"> 创建和管理单独绘图线程以达到平滑动画效果</div>
</li>
<li class="level1"><div class="li"> 提供了方便使用的调试工具来跟踪 OpenGL ES 函数调用以帮助检查错误</div>
</li>
</ol>

<p>
5.GLSurfaceView类的内部类Renderer，GLSurfaceView.Renderer 定义了一个统一图形绘制的接口，主要提供了如下三个接口
</p>
<ol>
<li class="level1"><div class="li"> onSurfaceCreated：在这个方法中主要用来设置一些绘制时不常变化的参数，比如：背景色，是否打开 z-buffer等</div>
</li>
<li class="level1"><div class="li"> onDrawFrame：定义实际的绘图操作</div>
</li>
<li class="level1"><div class="li"> onSurfaceChanged：如果设备支持屏幕横向和纵向切换，这个方法将发生在横向↔纵向互换时。此时可以重新设置绘制的纵横比率</div>
</li>
</ol>

<p>
    GLSurfaceView 的渲染模式有两种，一种是连续不断的更新屏幕，另一种为 on-demand ，只有在调用 requestRender() 在更新屏幕。 缺省为 RENDERMODE_CONTINUOUSLY 持续刷新屏幕。
</p>

<p>
6.Opengl ES 支持绘制的基本几何图形分为3类，分别是点， 线， 三角形。其他任何复杂的图行都是由这三类组成的。Opengl ES定义了几种模式：
</p>
<pre class="code">GL_POINTS:绘制独立的点
GL_LINE_STRIP:绘制一系列线段，从顶点v0开始，依次连接v1, v2, v3,....,vn构成的线段
GL_LINE_LOOP:绘制一系列线段，构成一个封闭的曲线，从顶点v0开始，依次连接v1, v2, v3,...,vn,vn再连接v1从而构成闭合曲线
GL_LINES：顶点两两连接，为多条线段构成
GL_TRIANGLES：每隔三个顶点构成一个三角形，为多个三角形组成
GL_TRIANGLE_STRIP：每相邻三个顶点组成一个三角形，为一系列相接三角形构成
GL_TRIANGLE_FAN：以一个点为三角形公共顶点，组成一系列相邻的三角形</pre>

<p>
7.坐标变换，Opengl es库完成了将3D模型显示到2D屏幕上，这个过程主要分为三部分
</p>
<ol>
<li class="level1"><div class="li"> 坐标变换，坐标变换通过使用变换矩阵来描述，因此学习 3D 绘图需要了解一些空间几何，矩阵运算的知识。三维坐标通常使用齐次坐标来定义。变换矩阵操作可以分为视角，模型和投影操作，這些操作可以有选择，平移，缩放，正侧投影，透视投影等。</div>
</li>
<li class="level1"><div class="li"> 由于最終的 3D 模型需要在一个矩形窗口中显示，因此在这个窗口之外的部分需要裁剪掉以提高绘图效率，对应3D 图形，裁剪是将处在剪切面之外的部分扔掉。 </div>
</li>
<li class="level1"><div class="li"> 在最终绘制到显示器，需要建立起变换后的坐标和屏幕像素之间的对应关系，这通常称为「视窗」坐标变换</div>
</li>
</ol>

<p>
8.可以将整个过程理解为照相机拍照的过程：
</p>
<ol>
<li class="level1"><div class="li"> 拍照时第一步是架起三角架並把相机的镜头指向需要拍摄的场景，对应到 3D 变换为 viewing transformation （平移或是选择 Camera ）</div>
</li>
<li class="level1"><div class="li">然后摄影师可能需要调整被拍場景中某個物体的角度，位置，比如摄影师給架好三角架后給你拍照时，可以要让你调整站立姿势或是位置。對應到 3D 繪製就是 Modeling transformation （調整所繪模型的位置，角度或是縮放比例）。</div>
</li>
<li class="level1"><div class="li">之后摄影师可以需要調整镜头取景（拉近或是拍攝遠景），相机取景框所能拍攝的場景會隨鏡頭的伸縮而變換，對應到 3D 繪图則為 Projection transformation(裁剪投影場景）。</div>
</li>
<li class="level1"><div class="li">按下快門後，对于數碼相机可以直接在屏幕上显示當前拍攝的照片，一般可以充满整個屏幕（相当于将坐标做規範化處理 NDC），此時你可以使用縮放放大功能显示照片的部分。对应到 3D 绘图相当于 viewport transformation （可以對最終的图像縮放显示等）   </div>
</li>
</ol>

<p>
9.坐标的变换过程涉及到坐标系，整个过程会涉及如下坐标系
</p>
<ul>
<li class="level1 node"><div class="li"> <em>Object Coordinate</em> –&gt;Model matrix –&gt;<em>World Coordinate</em>–&gt;view matrix–&gt;<em>View Coordinate</em>–&gt;projection matrix</div>
<ol>
<li class="level2"><div class="li">→<em>Clip Coordinate</em>–&gt;Perspective division–&gt;<em>Normalized device coordinate</em>–&gt;viewport transform–&gt;<em>Windows Coordinate</em> </div>
</li>
</ol>
</li>
</ul>
<ol>
<li class="level1"><div class="li"> Object Coordinate System: 也称作Local coordinate System，用來定义一個模型本身的坐標系。</div>
</li>
<li class="level1"><div class="li"> World Coordinate System: 3d 虚拟世界中的绝对坐标系，定义好這個坐标系的原点就可以用来描述模型的实现的位置，Camera 的位置，光源的位置。</div>
</li>
<li class="level1"><div class="li"> View Coordinate System: 一般使用用来计算光照效果。</div>
</li>
<li class="level1"><div class="li"> Clip Coordinate System: 对 3D 场景使用投影机换裁剪視角</div>
</li>
<li class="level1"><div class="li"> Normalized device coordinate System (NDC): 规范后坐标系</div>
</li>
<li class="level1"><div class="li"> Windows Coordinate System: 最后屏幕显示的 2D 坐标系統，一般原点定义在屏幕左上角。</div>
</li>
</ol>

<p>
10.FrameBuffer介绍
OpenGL ES 中的 FrameBuffer 指的是存储像素的内存空间。对应一个二维图像，如果屏幕分辨率为1280&times;1024 ，如果屏幕支持 24 位真彩色 (RGB)，
则存储这个屏幕区域的内存至少需要 1024X1280X3 个字节。此外如果需要支持透明度（Alpha），则一个像素需要 4 个字节。
对应 3D 图像来说，上面存储显示颜色的 Buffer 称为 Color Buffer，除 Color Buffer 之外，还需要存储每个像素和 View Point 之间的距离，
OpenGL ES 中使用 Depth Buffer 存储像素与眼睛（eye 或是 view point) 的距离，Depth Buffer 也可称为 z Buffer.
</p>

<p>
在 OpenGL ES 允许配置 Color Buffer 中 R,G,B,A 的颜色位数，Depth Buffer 的位数，以及 Stencil Buffer的位数：
</p>
<ul>
<li class="level1"><div class="li"> GL_RED_BITS,GL_GREEN_BITS,GL_BLUE_BITS, GL_ALPHA_BITS表示每个R，G，B，A在color buffers中所占的位数</div>
</li>
<li class="level1"><div class="li"> GL_DEPTH_BITS 表示每个像素在depth buffer中所占的位数</div>
</li>
<li class="level1"><div class="li"> GL_STENCIL_BITS 表示每个像素在stencil buffer中所占的位数   	</div>
</li>
</ul>

<p>
在最终 OpenGL ES 写入这些 Buffer 时，OpenGL ES 提供一些 Mask 函数可以控制 Color Buffer 中 RGBA 通道，是否允许写入 Depth Buffer 等，
这些 Mask 函数可以打开或是关闭某个通道，只有通道打开后，对应的分量才会写入指定 Buffer,比如你可以关闭红色通道，这样最后写道 Color Buffer 中
就不含有红色。这些函数有 glColorMask, glDepthMask, glStencilMask。
</p>

<p>
11.Depth Buffer
OpenGL ES 中 Depth Buffer 保存了像素与观测点之间的距离信息，在绘制3D图形时，将只绘制可见的面而不去绘制隐藏的面，这个过程叫”Hidden surface removal” ，采用的算法为”The depth buffer algorithm”。
</p>

<p>
一般来说，填充的物体的顺序和其顺序是一致的，而要准确的显示绘制物体在Z轴的前后关系，就需要先绘制距离观测点(ViewPoint)最远的物体，再绘制离观测点较远的物体，最后绘制离观测点最近的物体，因此需要对应所绘制物体进行排序。OpenGL ES 中使用 Depth Buffer 存放需绘制物体的相对距离。 
</p>

<p>
深度测试过程：
</p>
<ol>
<li class="level1"><div class="li"> 将 Depth Buffer 中的值使用最大值清空整个 Depth Buffer，这个最大值缺省为1.0 ，为距离 viewPoint 最远的裁剪的距离。最小值为 0，表示距离 viewPoint 最近的裁剪面的距离。距离大小为相对值而非实际距离，这个值越大表示与 Viewpoint 之间的距离越大。因此将初值这设为 1.0 相当于清空 Depth Buffer。</div>
</li>
<li class="level1"><div class="li"> 当 OpenGL 栅格化所绘制基本图形(Primitive)，将计算该 Primitive 与 viewpoint 之间的距离，保存在 Depth Buffer 中。</div>
</li>
<li class="level1"><div class="li"> 然后比较所要绘制的图形的距离和当前 Depth Buffer 中的值，如果这个距离比 Depth Buffer 中的值小，表示这个物体离 viewPoint 较近，Open GL 则更新相应的 Color Buffer 并使用这个距离更新 Depth Buffer，否则，表示当前要绘制的图形在已绘制的部分物体后面，则无需绘制该图形（删除）。 </div>
</li>
</ol>
<pre class="code">  gl.Clear(GL10.GL_DEPTH_BUFFER_BIT) 清空 Depth Buffer (赋值为 1.0)通常清空 Depth Buffer 和 Color Buffer 同时进行。
  gl.glClearDepthf(float depth) 指定清空 Depth Buffer 是使用的值，缺省为 1.0，通常无需改变这个值，
  gl.glEnable(GL10.GL_DEPTH_TEST) 打开 depth Test
  gl.glDisable(GL10.GL_DEPTH_TEST) 关闭 depth Test</pre>

<p>
12.Opengl 光照模型
</p>
<ol>
<li class="level1"><div class="li"> 在 OpenGL 光照模型中光源和光照效果可以细分为红，绿，蓝三个部分，光源由红，绿，蓝强度来定义，而物体表面材料由其反射红，绿，蓝的程度和方向来定义。OpenGL 光照模型使用的计算公式是对于现实世界光照的一个近似但效果非常好并适合快速计算。</div>
</li>
<li class="level1"><div class="li"> OpenGL 光照模型中定义的光源可以分别控制，打开或关闭，OpenGL ES支持最多八个光源。</div>
</li>
<li class="level1"><div class="li"> OpenGL 光照模型中最终的光照效果可以分为四个组成部分：Emitted(光源）, ambient(环境光）,diffuse(漫射光）和specular（镜面反射光），最终结果由这四种光叠加而成。</div>
</li>
<li class="level1"><div class="li"> Emitted ： 一般只发光物体或者光源，这种光不受其它光源的影响。</div>
</li>
<li class="level1"><div class="li"> ambient: 指光线经过多次反射后已经无法得知其方向（可以看作来自所有方向），可以成为环境光，该光源如果射到某个平面，其反射方向为所有方向。Ambient 不依赖于光源的方向.</div>
</li>
<li class="level1"><div class="li"> diffuse:当一束平行的入射光线射到粗糙的表面时，因面上凹凸不平，所以入射线虽然互相平行，由于各点的法线方向不一致，造成反射光线向不同的方向无规则地反射，这种反射称之为“漫反射”或“漫射”。这个反射的光则称为漫射光。漫射光射到某个平面时，其反射方向也为所有方向。diffuse 只依赖于光源的方向和法线的方向。</div>
</li>
<li class="level1"><div class="li"> specular ： 一般指物体被光源直射的高亮区域，也可以成为镜面反射区，如金属。specular 依赖于光源的方向，法线的方向和视角的方向。</div>
</li>
<li class="level1"><div class="li"> 尽管光源可能只发送某一频率的光线，但 ambient，diffuse 和 specular 可能不同。比如使用白光照射一堵红墙，散射的光线可能为红色。OpenGL 允许为光源分别设置红，绿，蓝三个元素的值。</div>
</li>
<li class="level1"><div class="li"> 最终决定所看到物体的颜色除了光源的颜色和方向外，还取决于物体本身的颜色，比如红色的光照在红色的物体和蓝色的物体，最终看到的物体一个还是红色，一个为黑色。OpenGL 中对物体材料(Material)的颜色是通过其反射红，绿，蓝的比例来定义的。 和光源一样，物体的颜色也可以有不同的 ambient,diffuse 和 specular，表现为反射这些光的比例。ambient,diffuse 反射通常为同样的颜色，而 specular 常常表现为白色或灰色光，如使用白光照射一个红色的球，球的大部分区域显示为红色，而高亮区域为白色</div>
</li>
</ol>
