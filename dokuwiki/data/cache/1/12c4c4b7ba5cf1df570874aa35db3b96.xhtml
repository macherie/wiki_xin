
<p>
转自   <a href="http://blog.csdn.net/green1900/article/details/42496741#comments" class="urlextern" title="http://blog.csdn.net/green1900/article/details/42496741#comments"  rel="nofollow">http://blog.csdn.net/green1900/article/details/42496741#comments</a>
</p>

<p>
1、底电流调试（Rock Bottom Current Optimization）
</p>

<p>
底电流在手机飞行模式下调试。每个平台的底电流数据可能不一样，具体可以参考release出来的Current Consumption Data文档或者release note。一般情况下的底电流参考数据上限是：
</p>

<p>
512M RAM &lt; 1.5mA; 1G RAM &lt; 2mA; 2G RAM &lt; 2.6mA
</p>

<p>
1.1校准RF
</p>

<p>
保证RF的PA、Antenna switch、Tuner、APT、GPIO工作在正常状态
</p>

<p>
1.2飞行模式
</p>

<p>
开启飞行模式、关闭GPS、关闭自动旋转屏幕、关闭自动亮度调节、关闭其他特效效果设置
</p>

<p>
开启飞行模式，可以基本避免蓝牙、wifi、NFC、网络、FM等的一般影响；
</p>

<p>
关闭GPS，可以基本排除开启GPS对底电流的影响；
</p>

<p>
关闭自动旋转屏幕，可以基本排除sensor的影响；
</p>

<p>
关闭自动亮度调节，可以基本排除距离感应到的影响；
</p>

<p>
关闭其他特效效果设置，如指纹识别、黑屏手势、智能体感、手势隔空操作。。。。。。
</p>

<p>
1.3使用perf_defconfig
</p>

<p>
修改device/qcom/&lt;TARGET&gt;/AndroidBoard.mk。如果KERNEL_DEFCONFIG := &lt;TARGET&gt;_defconfig，那么改成KERNEL_DEFCONFIG := &lt;TARGET&gt;-perf_defconfig
</p>

<p>
同时，kernel代码改用/kernel/arch/arm/configs/&lt;TARGET&gt;-perf_defconfig
</p>

<p>
&lt;TARGET&gt;是平台名称或者项目名称
</p>

<p>
1.4移除debugging APKs
</p>

<p>
/system/app/Logkit.apk
</p>

<p>
/system/app/com.qualcomm.qlogcat.apk
</p>

<p>
/system/xbin/qlogd
</p>

<p>
1.5把应用尽量删除
</p>

<p>
在设置–&gt;应用，禁用正在运行的应用
</p>

<p>
1.6去掉CPU占用高的进程
</p>

<p>
adb shell
</p>

<p>
top
</p>

<p>
查看CPU占用，去掉在休眠模式下CPU占用大于0的进程。kill掉该进程，若kill不掉则rm掉相关应用。对于占用CPU高的kwork，需要查找驱动原因。
</p>

<p>
1.7手动移除所有可以移除的外设
</p>

<p>
手机连上安捷伦电源，手机开机，然后让手机进入待机状态。手动移除TP、LCM、前camera、后camera、sensor、SD卡、SIM卡等可以手动移除的外围器件，同时观察并记录底电流变化。
</p>

<p>
直接移除WLAN芯片可能会导致开不了机，所以在移除WLAN之前，先对软件做如下处理：
</p>

<p>
# mount -o rw,remount -t vfat /dev/block/bootdevice/by-name/modem 
</p>

<p>
# cd /firmware/image 
</p>

<p>
# rm wcnss.* 
</p>

<p>
# reboot 
</p>

<p>
或者
</p>

<p>
#lsmod
</p>

<p>
#rmmod WLAN
</p>

<p>
移除其他可以移除的芯片（sensor、NFC。。。）
</p>

<p>
1.8移除驱动模块
</p>

<p>
在/kernel/arch/arm/configs/&lt;TARGET&gt;-perf_defconfig中把sensor、TP、LCM、camera等的驱动模块移除；
</p>

<p>
或者在对应驱动的Makefile里面，移除驱动代码
</p>

<p>
然后编译bootimage，烧入手机观察底电流变化
</p>

<p>
1.9配置不用的GPIO
</p>

<p>
将不用的GPIO置为输入、拉低；配置成SPI、I2C的GPIO，若不用，置为悬空
</p>

<p>
在boot_images/core/systemdrivers/tlmm/config/platform/TLMMChipset.xml，修改GPIO配置。该处配置GPIO的初始状态，驱动有可能会修改GPIO。
</p>

<p>
对比项目原理图与平台参考原理图，项目原理图中多出的NC GPIO要处理掉。
</p>

<p>
1.10检查power相关的NV items
</p>

<p>
需要跟CE确认。一般如下：
</p>

<p>
1027 = 0
</p>

<p>
1895 = 0
</p>

<p>
1892 = 0
</p>

<p>
1962 = 0
</p>

<p>
4679 = 16
</p>

<p>
4201 = 0
</p>

<p>
3851 = 0
</p>

<p>
3852 = 6
</p>

<p>
7157 = 1
</p>

<p>
69745 rxd_enable = 0
</p>

<p>
WCDMA NV:
</p>

<p>
NV3581 = 0
</p>

<p>
NV3852 = 6
</p>

<p>
1.11排查GPIO、LDO、总线
</p>

<p>
对比项目原理图与平台参考原理图，排查硬件不一样的GPIO、LDO、总线配置。
</p>

<p>
量测各GPIO、LDO、I2C在休眠时候的电压，需用万用表准确测量。
</p>

<p>
休眠时各路I2C GPIO的电压是多少v，用万用表准确测量。
</p>

<p>
如果条件允许，测量所有LDO在休眠前和休眠后的准确电压。
</p>

<p>
对于LDO，调试方法如下：
</p>

<p>
（1）adb shell关闭LDO
</p>

<p>
如关闭L3：
</p>

<p>
cd /sys/kernel/debug/regulator/8916_l3/
</p>

<p>
echo 0 &gt; enable
</p>

<p>
（2）LDO太多设备用到，不适合用adb shell来关。可以这样调试：
</p>

<p>
cat /sys/kernel/debug/regulator/8916_l6/consumers 
</p>

<p>
shell@msm8916_32:/sys/kernel/debug/regulator/8916_l6 $ cat consumers 
</p>

<p>
Device-Supply EN Min_uV Max_uV load_uA 
</p>

<p>
0-000c-vio Y 1800000 1800000 0 
</p>

<p>
0-0068-vi2c N 1800000 1800000 0 
</p>

<p>
5-0038-vcc_i2c Y 1800000 1800000 0 
</p>

<p>
1a98000.qcom,mdss_dsi-vddio N 1800000 1800000 100 
</p>

<p>
1a98300.qcom,mdss_dsi_pll-vddio N 1800000 1800000 100 
</p>

<p>
8916_l6 N 0 0 0 
</p>

<p>
这样就可以看到是哪些设备请求了LDO6。然后 找到对应的代码，在休眠时关掉LDO，唤醒时再打开。 
</p>

<p>
0-000c: 挂在I2C0上地址为0xc 
</p>

<p>
5-0038: 挂在I2C0上地址为0x38 
</p>

<p>
查看这两个设备的驱动代码是否有执行regulator_enable。
</p>

<p>
（3）通过寄存器地址关闭LDO
</p>

<p>
如LDO6的地址是0x14546，则关闭方法是：
</p>

<p>
# cd /sys/kernel/debug/spmi/spmi-0 
</p>

<p>
# echo 0x14546 &gt; address 
</p>

<p>
# echo 1 &gt; count 
</p>

<p>
# cat data 可以读寄存器 
</p>

<p>
# echo 0x00 &gt; data 关LDO6
#在较新的平台是无法手动关闭LDO
</p>

<p>
在S600项目LDO6和LDO17分别是提供主外设用的数字电压和模拟电压，分别是1.8v和2.8v，在cd /sys/kernel/debug/regulator/8916_l6中，cat use_count，如果值等于0表明引用计数没有使用LDO6.如果不等于0，分别将他们驱动去除，去除之后重新查看use_count的值，在S600项目中，因为icm20546陀螺仪驱动导致底电流过高，系统睡不下去。
</p>

<p>
（4）关闭MPP
</p>

<p>
在休眠前关闭MPP1、MPP2、MPP3、MPP4 
</p>

<p>
如PM8916的寄存器地址分别是0xA046、0xA146、0xA246、0xA346 
</p>

<p>
在关闭前先cat data以查看原来的值。 
</p>

<p>
GPIO状态读取的方法如下：
</p>

<p>
（1）GPIO dump
</p>

<p>
为了得到休眠时的GPIO状态，增加下面的打印: 
</p>

<p>
rpm_proc/core/power/sleep/src/lpr_definition_uber.c 
</p>

<p>
#include “tlmm_hwio.h”
</p>

<p>
void deep_sleep_enter(void) 
</p>

<p>
{ 
</p>

<p>
uint64 sleep_duration; 
</p>

<p>
…
</p>

<p>
SWEVENT(SLEEP_DEEP_SLEEP_ENTER_COMPLETE, sleep_mode.deep_sleep_mode, sleep_duration); 
</p>

<p>
<em> For test 

{ 

int num; 

int i=11;/*LCM_I2C_SCL, GPIO_11*/ 

volatile uint32 cfg ,inout, val; 

 

num = 122; </em>8916 only. Need modify for 8974/8&times;10/8&times;26 etc. 
</p>

<p>
cfg = *(volatile uint32*)HWIO_TLMM_GPIO_CFGn_ADDR(i); <em>(0x61000000 + i * 0x1000) 

inout = *(volatile uint32*)HWIO_TLMM_GPIO_IN_OUTn_ADDR(i);</em>(0x61000004 + i * 0x1000) 
</p>

<p>
val = ((cfg « 16)&amp;0xffff0000) | (inout&amp;0xffff); 
</p>

<p>
SWEVENT(SLEEP_GPIO_DUMP, i, val); 
</p>

<p>
} 
</p>

<p>
mpm_sw_done(sleep_mode.deep_sleep_mode, sleep_duration); 
</p>

<p>
} while(FALSE); 
</p>

<p>
} 
</p>

<p>
增加for test下面这一段代码。
</p>

<p>
然后再修改: 
</p>

<p>
rpm_proc\core\power\sleep\build\SConscript 
</p>

<p>
if &#039;USES_QDSS_SWE&#039; in env: 
</p>

<p>
QDSS_IMG = [&#039;QDSS_EN_IMG&#039;] 
</p>

<p>
events = [[&#039;SLEEP_DEEP_SLEEP_ENTER=320&#039;,&#039;deep sleep enter. (sleep mode: %d) (count: %d)&#039;], 
</p>

<p>
[&#039;SLEEP_DEEP_SLEEP_EXIT&#039;,&#039;deep sleep exit (sleep mode: %d)&#039;], 
</p>

<p>
[&#039;SLEEP_NO_DEEP_SLEEP&#039;,&#039;bail early from deep sleep. (sleep mode: %d) (reason: %d)&#039;], 
</p>

<p>
[&#039;SLEEP_RPM_HALT_ENTER&#039;,&#039;rpm halt enter&#039;], 
</p>

<p>
[&#039;SLEEP_RPM_HALT_EXIT&#039;,&#039;rpm halt exit&#039;], 
</p>

<p>
[&#039;SLEEP_MPM_INTS&#039;,&#039;pending mpm interrupts at wakeup: (interrupt_status_1 %d), (interrupt_status_2 %d)&#039;], 
</p>

<p>
[&#039;SLEEP_DEEP_SLEEP_ENTER_COMPLETE&#039;,&#039;deep sleep exit complete (sleep mode: %d)&#039;], 
</p>

<p>
[&#039;SLEEP_DEEP_SLEEP_EXIT_COMPLETE&#039;,&#039;deep sleep exit (sleep mode: %d)&#039;], 
</p>

<p>
[&#039;SLEEP_MPM_WAKEUP_TIME&#039;,&#039;mpm wake up time (wakeup time: 0x%0.8x%0.8x)&#039;], 
</p>

<p>
[&#039;SLEEP_GPIO_DUMP&#039;,&#039;gpio [%d] configuration is %d&#039;],
</p>

<p>
[&#039;SLEEP_EVENT_LAST=383&#039;,&#039;sleep last event placeholder&#039;] 
</p>

<p>
增加SLEEP_GPIO_DUMP这一项。 
</p>

<p>
编译烧写rpm.mbn。
</p>

<p>
让机器休眠，进入download，抓dump，然后将如下日志发给平台技术支持分析。 
</p>

<p>
CODERAM.bin 
</p>

<p>
MSGRAM.bin 
</p>

<p>
DATARAM.bin 
</p>

<p>
以及新编译出来的RPM_AAAAANAZR.elf。  
</p>

<p>
（2）GPIO寄存器读取
</p>

<p>
在RPM可能不是很方便，也可以用busybox来读取寄存器，例如读GPIO11： 
</p>

<p>
Physical Address for GPIO_CFG11 = 0x100B000 
</p>

<p>
root@android:/data/busybox # ./busybox devmem 0x100B000 32 
</p>

<p>
./busybox devmem 0x100B000 32 
</p>

<p>
0x00000203 
</p>

<p>
GPIO_PULL = “11” PULL_UP 
</p>

<p>
FUNC_SEL = “0000” FUNCTION GPIO 
</p>

<p>
DRV_STRENGTH = “000” DRV_2_MA 
</p>

<p>
GPIO_OE = “1” Output Enable 
</p>

<p>
1.12 rpm dump
</p>

<p>
抓rpm dump，然后把log提供给平台技术支持。
</p>

<p>
方法如下： 
</p>

<p>
（1）ps_hold接地
</p>

<p>
在休眠状态下，接ps_hold到地少于200mS，机器会进入紧急下载状态，插入USB，QPST会自动得到memory dump，然后上传以下几个文件： 
</p>

<p>
CODERAM.bin 
</p>

<p>
MSGRAM.bin
</p>

<p>
DATARAM.bin 
</p>

<p>
以及RPM_AAAAANAZR.elf（必须与机器的编译时间一致匹配的elf) 
</p>

<p>
（2）改reset为download key
</p>

<p>
发这些命令改reset为download key: 
</p>

<p>
# cd /sys/kernel/debug/spmi/spmi-0 
</p>

<p>
# echo 0x844 &gt; address 
</p>

<p>
# echo 4 &gt; count 
</p>

<p>
# cat data 
</p>

<p>
00840 – – – – 0F 07 04 00 
</p>

<p>
# echo 0x00 0x00 0x01 0x00 &gt; data 
</p>

<p>
# cat data 
</p>

<p>
00840 – – – – 00 00 01 00 
</p>

<p>
# echo 0x00 0x00 0x01 0x80 &gt; data 
</p>

<p>
# cat data 
</p>

<p>
00840 – – – – 00 00 01 80 
</p>

<p>
然后长按下键，会进入download。之后抓取log方法同上。
</p>

<p>
如果进不了download，需要确认： 
</p>

<p>
CONFIG_MSM_DLOAD_MODE=y 
</p>

<p>
另外也有可能与nv 4399和905有关系。
</p>

<p>
1.13检查rpm_stats
</p>

<p>
检查rpm_stats是否进入vdd min或者xo/no shutdown。使用下面的命令检查rpm lower power mode count:
</p>

<p>
cat /sys/kernel/debug/rpm_stats
</p>

<p>
如果vmin的count是0，则表明设备从来没有进入vdd min；non-zero则说明设备进入过vdd_min。
</p>

<p>
RPM Mode: xosd
</p>

<p>
count:0
</p>

<p>
time in last mode(msec):0
</p>

<p>
time since last mode(sec):794
</p>

<p>
actual last sleep(msec):0
</p>

<p>
RPM Mode:vmin
</p>

<p>
count:11
</p>

<p>
time in last mode(msec):0
</p>

<p>
time since last mode(sec):359
</p>

<p>
actual last sleep(msec):110000
</p>

<p>
1.14使用Trace32
</p>

<p>
可以dump出来完整详细的gpio/clk/pmic信息，排除休眠时候的状态异常。
</p>

<p>
2、待机电流优化（Standby Current Optimization）
</p>

<p>
2.1通过adb log排查
</p>

<p>
adb logcat -v time &gt; YearMounthDayHourMinute_logcat.txt   <em>main log

adb logcat -v time -b events &gt; YearMounthDayHourMinute_logcat_event.txt   </em>event log
</p>

<p>
adb logcat -v time -b radio &gt; YearMounthDayHourMinute_logcat_radio.txt    <em>radio log

adb shell dmesg &gt; YearMounthDayHourMinute_dmesg.txt                 </em>kernel log
</p>

<p>
可以采用功耗问题时间追踪表来精确追踪功耗异常。
</p>

<p>
可以使用如下命令来打开指定文件的kernel log（以qpnp-adc-tm.c和qpnp-adc-common.c为例）：
</p>

<p>
adb shell mount -t debugfs none /sys/kernel/debug
</p>

<p>
adb shell “echo 8 &gt; /proc/sys/kernel/printk”
</p>

<p>
adb shell “echo &#039;file qpnp-adc-tm.c +p&#039; &gt; /sys/kernel/debug/dynamic_debug/control”
</p>

<p>
adb shell “echo &#039;file qpnp-adc-common.c +p&#039; &gt; /sys/kernel/debug/dynamic_debug/control”
</p>

<p>
adb shell “echo 8 &gt; /proc/sys/kernel/printk”
</p>

<p>
为指定的函数开启log，以qpnpint_handle_irq为例：
</p>

<p>
adb shell “echo &#039;func qpnpint_handle_irq +p&#039; &gt; /sys/kernel/debug/dynamic_debug/control”
</p>

<p>
*#logkit#*调出logkit apk，可以保存logcat、dmesg、crash、QXDM、GPU log等日志信息到手机里面。
</p>

<p>
2.2 top
</p>

<p>
通过top命令，可以查询到cpu占用较高的应用。如果一个应用一直在占用cpu，而此时并没有打开该应用，那么该应用很可能会导致待机异常。
</p>

<p>
adb shell
</p>

<p>
top
</p>

<p>
“该场景下CPU使用率”是User+System+<abbr title="In other words">IOW</abbr>+IRQ
</p>

<p>
“模块相关的CPU占用率”是模块相关进程占用CPU使用率的总和
</p>

<p>
2.3正在运行
</p>

<p>
设置–&gt;应用–&gt;正在运行，可以看到正在运行的应用或者服务。禁止掉应用或者服务，观察待机电流变化。
</p>

<p>
2.4 wakeup debug mask
</p>

<p>
调试wakeup问题，可以使能debug功能，然后抓取log。Log中会增加一些debug信息。
</p>

<p>
mount -t debugfs none /sys/kernel/debug  
</p>

<p>
echo 1 &gt; /sys/kernel/debug/clk/debug_suspend  
</p>

<p>
echo 1 &gt; /sys/module/msm_show_resume_irq/parameters/debug_mask  
</p>

<p>
echo 4 &gt; /sys/module/wakelock/parameters/debug_mask  
</p>

<p>
echo 1 &gt; /sys/module/lpm_levels/parameters/debug_mask  
</p>

<p>
echo 0x16 &gt; /sys/module/smd/parameters/debug_mask  
</p>

<p>
2.5 wakelock  
</p>

<p>
1、wakeup_sources  
</p>

<p>
kernel wakelock和userspace wakelock都有可能阻止系统睡眠。所有的wakeup_sources均保存在sys节点/sys/kernel/debug/wakeup_sources里面。 
</p>

<p>
该文件包含了如下信息：
</p>

<p>
（1）the total amount of time a wakeup source has prevented suspend  
</p>

<p>
（2）the amount of time a wakelock has been active since the last activation etc. The unit of time is milliseconds. 
</p>

<p>
2、active_since
</p>

<p>
active_since值可以用来确认wakelock是否正在阻止休眠。如果该值不是零，那么这个wakelock正在工作并且阻止休眠。
</p>

<p>
3、获取wakeup_sources的命令
</p>

<p>
adb root 67754400
</p>

<p>
adb remount
</p>

<p>
adb shell 
</p>

<p>
cat /sys/kernel/debug/wakeup_sources &gt; /data/wakeup_sources.txt
</p>

<p>
adb pull /data/wakeup_sources.txt
</p>

<p>
获得wakeup_sources.txt以后，通过Excel打开，active_since不为0的项为wakeup source。以表2为例，msm_dwc3对应的active-since值481756&gt;0，这意味着msm_dwc3驱动在阻止系统睡眠，下一步需要检查msm_dwc3驱动代码及相关log。
</p>

<p>
表格 2 Wakeup source opened in Excel
</p>

<p>
4、power:wakeup_source_activate and power:wakeup_source_deactivate events
</p>

<p>
当一个wakeup source被acquire或者release时候，power:wakeup_source_activate和power:wakeup_source_deactivate event将随即被写到trace buffer里面，这样可以记录wakeup source被driver使用的频率。
</p>

<p>
开启该功能的方法：
</p>

<p>
echo “power:wakeup_source_activate power:wakeup_source_deactivate” &gt; /sys/kernel/debug/tracing/set_event
</p>

<p>
The power:wakeup_source_activate and power:wakeup_source_deactivate events are written to the trace buffer any time a wakeup source is acquired or released and it can provide information on how often a wakeup source is being used by a driver.  
</p>

<p>
To enable these events, you can enable following:  
</p>

<p>
echo “power:wakeup_source_activate power:wakeup_source_deactivate” &gt; /sys/kernel/debug/tracing/set_event 
</p>

<p>
Once the above done, the traces will be present in /sys/kernel/debug/tracing/trace. 
</p>

<p>
2.6 powertop
</p>

<p>
powertop用来看CPU的运行统计以协助调试power问题。powertop的用法如下：
</p>

<p>
powertop –h
</p>

<p>
Usage: powertop [OPTION…]
</p>

<p>
n -d, –dump read wakeups once and print list of top offenders
</p>

<p>
n -t, –time=DOUBLE default time to gather data in seconds
</p>

<p>
n -r, –reset Reset PM stats data
</p>

<p>
n -h, –help Show this help message
</p>

<p>
n -v, –version Show version information and exit
</p>

<p>
获取powertop log的方法：
</p>

<p>
1. 通过USB连接手机到电脑
</p>

<p>
2. adb shell，然后执行如下命令：
</p>

<p>
sleep 10 &amp;&amp; /data/powertop [-r] -d -t 30 &gt; /data/powertop.log &amp; 
</p>

<p>
3. 拔掉USB线，等待10秒后开始功耗测试
</p>

<p>
4. 插上USB  
</p>

<p>
5. adb pull /data/powertop.log  
</p>

<p>
2.7 CPU freq log 
</p>

<p>
打开CPU freq change log：
</p>

<p>
mount -t debugfs none /sys/kernel/debug  
</p>

<p>
cd /sys/kernel/debug 
</p>

<p>
echo -n &#039;file acpuclock-8&times;60.c +p&#039; &gt; dynamic_debug/control 
</p>

<p>
echo -n &#039;file acpuclock-krait.c +p&#039; &gt; dynamic_debug/control
</p>

<p>
查看cpu freq stats: 
</p>

<p>
cat /sys/devices/system/cpu/cpu0/cpufreq/stats 
</p>

<p>
cat /sys/devices/system/cpu/cpu1/cpufreq/stats 
</p>

<p>
cat /sys/devices/system/cpu/cpu2/cpufreq/stats 
</p>

<p>
cat /sys/devices/system/cpu/cpu3/cpufreq/stats 
</p>

<p>
To lock cpu freg: 
</p>

<p>
echo the same freq to following sys mode will lock cpu freq to the setting freq. 
</p>

<p>
/sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq 
</p>

<p>
/sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq
</p>

<p>
To enable/disable specific freq for ACPU 
</p>

<p>
ACPU freq table is defined in acpu_freq_tbl_* structure of specific platform. 
</p>

<p>
arch/arm/mach-msm/acpuclock-&lt;platform name&gt;.c 
</p>

<p>
For 8974, it is defined in arch/arm/mach-msm/acpuclock-8974.c. the first column of following table used to enable/disable freq in the row: 1:enable, 0:disable  
</p>

<p>
static struct acpu_level acpu_freq_tbl_2p3g_pvs0[] __initdata = { 
</p>

<p>
{ 1, { 300000, PLL_0, 0, 0 }, L2(0), 800000, 72 }, 
</p>

<p>
{ 0, { 345600, HFPLL, 2, 36 }, L2(1), 800000, 83 }, 
</p>

<p>
{ 1, { 422400, HFPLL, 2, 44 }, L2(2), 800000, 101 }, 
</p>

<p>
{ 0, { 499200, HFPLL, 2, 52 }, L2(2), 805000, 120 }, 
</p>

<p>
{ 0, { 576000, HFPLL, 1, 30 }, L2(3), 815000, 139 }, 
</p>

<p>
{ 1, { 652800, HFPLL, 1, 34 }, L2(3), 825000, 159 }, 
</p>

<p>
{ 1, { 729600, HFPLL, 1, 38 }, L2(4), 835000, 180 }, 
</p>

<p>
{ 0, { 806400, HFPLL, 1, 42 }, L2(4), 845000, 200 }, 
</p>

<p>
{ 1, { 883200, HFPLL, 1, 46 }, L2(4), 855000, 221 }, 
</p>

<p>
{ 1, { 960000, HFPLL, 1, 50 }, L2(9), 865000, 242 }, 
</p>

<p>
{ 1, { 1036800, HFPLL, 1, 54 }, L2(10), 875000, 264 }, 
</p>

<p>
{ 0, { 1113600, HFPLL, 1, 58 }, L2(10), 890000, 287 }, 
</p>

<p>
{ 1, { 1190400, HFPLL, 1, 62 }, L2(10), 900000, 308 }, 
</p>

<p>
… 
</p>

<p>
{ 1, { 1958400, HFPLL, 1, 102 }, L2(19), 1040000, 565 }, 
</p>

<p>
{ 0, { 2035200, HFPLL, 1, 106 }, L2(19), 1055000, 596 }, 
</p>

<p>
{ 0, { 2112000, HFPLL, 1, 110 }, L2(19), 1070000, 627 }, 
</p>

<p>
{ 0, { 2188800, HFPLL, 1, 114 }, L2(19), 1085000, 659 }, 
</p>

<p>
{ 1, { 2265600, HFPLL, 1, 118 }, L2(19), 1100000, 691 }, 
</p>

<p>
{ 0, { 0 } } 
</p>

<p>
}; 
</p>

<p>
2.8 Hoplug cores 
</p>

<p>
Core 0 can’t be hotplugged, Core 1/2/3 can be hotplugged, 
</p>

<p>
To remove core : 
</p>

<p>
echo 0 &gt; /sys/devices/system/cpu/cpu1/online 
</p>

<p>
echo 0 &gt; /sys/devices/system/cpu/cpu2/online 
</p>

<p>
echo 0 &gt; /sys/devices/system/cpu/cpu3/online 
</p>

<p>
To add back core: 
</p>

<p>
echo 1 &gt; /sys/devices/system/cpu/cpu1/online
</p>

<p>
echo 1 &gt; /sys/devices/system/cpu/cpu2/online
</p>

<p>
echo 1 &gt; /sys/devices/system/cpu/cpu3/online
</p>

<p>
2.9 Scaling governor
</p>

<p>
To check scaling governor：
</p>

<p>
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
</p>

<p>
To set new governor：
</p>

<p>
echo &lt;new_governor&gt; &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
</p>

<p>
比如：
</p>

<p>
echo ondemand &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
</p>

<p>
2.10 Mpdecision
</p>

<p>
Use Mpdecison daemon to start/stop/enable debug with commands below: 
</p>

<p>
Start mpdecison： 
</p>

<p>
start mpdecision 
</p>

<p>
n 
</p>

<p>
Stop mpdecison：
</p>

<p>
stop mpdecision
</p>

<p>
Enable mpdecision debug ：
</p>

<p>
start mpdecision –debug 
</p>

<p>
2.11 Power feature enable/disable 
</p>

<p>
Following sys node can be used to enable the lower resource, 
</p>

<p>
echo 2 &gt; /sys/module/lpm_resources/enable_low_power/l2 
</p>

<p>
echo 1 &gt; /sys/module/lpm_resources/enable_low_power/pxo 
</p>

<p>
echo 1 &gt; /sys/module/lpm_resources/enable_low_power/vdd_dig 
</p>

<p>
echo 1 &gt; /sys/module/lpm_resources/enable_low_power/vdd_mem 
</p>

<p>
echo 1 &gt; /sys/module/pm_8x60/modes/cpu0/power_collapse/suspend_enabled 
</p>

<p>
echo 1 &gt; /sys/module/pm_8x60/modes/cpu1/power_collapse/suspend_enabled 
</p>

<p>
echo 1 &gt; /sys/module/pm_8x60/modes/cpu2/power_collapse/suspend_enabled 
</p>

<p>
echo 1 &gt; /sys/module/pm_8x60/modes/cpu3/power_collapse/suspend_enabled 
</p>

<p>
echo 1 &gt; /sys/module/pm_8x60/modes/cpu0/power_collapse/idle_enabled 
</p>

<p>
echo 1 &gt; /sys/module/pm_8x60/modes/cpu0/standalone_power_collapse/suspend_enabled
</p>

<p>
echo 1 &gt; /sys/module/pm_8x60/modes/cpu1/standalone_power_collapse/suspend_enabled
</p>

<p>
echo 1 &gt; /sys/module/pm_8x60/modes/cpu2/standalone_power_collapse/suspend_enabled 
</p>

<p>
echo 1 &gt; /sys/module/pm_8x60/modes/cpu3/standalone_power_collapse/suspend_enabled
</p>

<p>
echo 1 &gt; /sys/module/pm_8x60/modes/cpu0/standalone_power_collapse/idle_enabled 
</p>

<p>
echo 1 &gt; /sys/module/pm_8x60/modes/cpu1/standalone_power_collapse/idle_enabled 
</p>

<p>
echo 1 &gt; /sys/module/pm_8x60/modes/cpu2/standalone_power_collapse/idle_enabled 
</p>

<p>
echo 1 &gt; /sys/module/pm_8x60/modes/cpu3/standalone_power_collapse/idle_enabled 
</p>

<p>
echo 0 to above sys node will disable related low power mode. 
</p>

<p>
2.12 Check system alarm  
</p>

<p>
get android alarms and statistics: 
</p>

<p>
adb dumpsys alarm &gt; alarms.txt
</p>

<p>
enable android debug message in logcat： 
</p>

<p>
setprop persist.alarm.debug 1
</p>

<p>
2.13 Kernel timer check
</p>

<p>
Sys node /proc/timer_stats can be used to check kernel timer stastics, customer can use following command to get timer statics in specific scenario: 
</p>

<p>
echo 0 &gt; /proc/timer_stats &amp;&amp; sleep 10 &amp;&amp; echo 1 &gt; /proc/timer_stats &amp;&amp; sleep 30 &amp;&amp; cat /proc/timer_stats &gt; /data/timer_stats &amp; 
</p>

<p>
OEMs need to provide file /data/timer_stats to salesforce case for check. 
</p>

<p>
3、其他功耗项的优化
</p>

<p>
3.1屏幕对功耗的影响
</p>

<p>
屏幕亮度等级不同，功耗不同。亮度越低，功耗越低。调低屏幕默认背光亮度等级和屏幕最高亮度设置时候的背光亮度等级，可以优化手机整体功耗表现。
</p>

<p>
LCD背光等级的设备节点：
</p>

<p>
/sys/class/leds/lcd-backlight/brightness
</p>

<p>
默认背光等级和最高亮度背光等级需要同时考虑到用户体验和功耗表现，需要一起评估。
</p>

<p>
另外，调试LCD的fps帧率，也可以优化功耗。
</p>

<p>
3.2 CPU/GPU DVFS
</p>

<p>
CPU/GPU的动态调频调压可以优化手机的功耗表现。该影响是整体性的，系统性的。
</p>

<p>
CPU降频主要通过两种方式实现，都可以达到降频的目标。
</p>

<p>
1、设置CPU工作在powersave模式。设置该模式后，CPU将一直工作在最低频率（300000hz）。此时手机最省电，但是有可能会出现手机运行变卡顿。
</p>

<p>
例如：将CPU0置为powersave模式，命令为：
</p>

<p>
echo “powersave” &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
</p>

<p>
例如：将CPU1置为powersave模式，命令为：
</p>

<p>
echo “powersave” &gt; /sys/devices/system/cpu/cpu1/cpufreq/scaling_governor
</p>

<p>
ex780共有4个CPU（CPU0~CPU3），都可以这样处理
</p>

<p>
2、限制CPU最高频率，以限制CPU的运行频率上限
</p>

<p>
CPU（CPU0~CPU3）可以选择的频率值如下所列，即这些数值都可以用作CPU的频率上限。选择的频率上限可以根据实际场景需要来设置。在超级省电模式下，CPU工作的宗旨是：CPU工作频率低+运行不卡，两项都要保障。
</p>

<p>
CPU可以选择的频率：
</p>

<p>
300000 422400 652800 729600 883200 960000 1036800 1190400 1267200 1497600 1574400 1728000 1958400 2265600 2457600
</p>

<p>
例如：将CPU0的频率上限设置为960000
</p>

<p>
echo 960000 &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
</p>

<p>
例如：将CPU0的频率上限设置为422400
</p>

<p>
echo 422400 &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
</p>

<p>
GPU相关调试与CPU类似，设备节点路径/sys/devices/fdb00000.qcom,kgsl-3d0/kgsl/kgsl-3d0
</p>

<p>
3.3 CPU占用率
</p>

<p>
应用对cpu的占有率，如果占有率过高，则该应用一般会导致功耗较大。
</p>

<p>
adb shell
</p>

<p>
top -m 6 
</p>

<p>
3.4游戏功耗
</p>

<p>
可以从下面几个方面优化：
</p>

<p>
降低屏幕背光亮度等级；
</p>

<p>
采用CPU、GPU动态调频调压，并调低CPU、GPU频率下限；
</p>

<p>
采用thermal-engine.conf 。
</p>

<p>
3.5 Camera功耗偏大
</p>

<p>
降低camera帧率；
</p>

<p>
降低屏幕背光亮度等级；
</p>

<p>
采用CPU、GPU动态调频调压，并调低CPU、GPU频率下限；
</p>

<p>
采用thermal-engine.conf 。
</p>
