
<h1 class="sectionedit1" id="wpa_supplicant_分析">Wpa_supplicant 分析</h1>
<div class="level1">

<p>
依然是带着问题去看吧，否则20w行代码要看死的…，不可能也没必要去详细的分析代码，我们只要知道它的功能框架，会去debug，会去用就看了，下面是我想到的几个问题：
</p>

</div>
<!-- EDIT1 SECTION "Wpa_supplicant 分析" [1-266] -->
<h2 class="sectionedit2" id="什么是wpa_supplicant_它主要的功能是什么_它有什么特点">1.什么是wpa_supplicant，它主要的功能是什么，它有什么特点...</h2>
<div class="level2">

<p>
Wpa_supplicnt是一个开源项目，支持多平台多系统，它实现了对无线网络进行管理和控制的功能.
Wpa_supplicant主要是用来支持WEP，WPA/WPA2和WAPI无线协议和加密认证的，而实际上的工作内容是通过socket（不管是wpa_supplicant与上层还是wpa_supplicant与驱动都采用socket通讯）与驱动交互上报数据给用户，而用户可以通过socket发送命令给wpa_supplicant调动驱动来对WiFi芯片操作。 简单的说，wpa_supplicant就是WiFi驱动和用户的中转站外加对协议和加密认证的支持。
</p>

<p>
根据官网描述，wpa_supplicant所支持的功能非常多，此处列举其中几个重要的功能点：
</p>

</div>
<!-- EDIT2 SECTION "1.什么是wpa_supplicant，它主要的功能是什么，它有什么特点..." [267-1056] -->
<h3 class="sectionedit3" id="支持wpa和ieee_80211i所定义的大部分功能_这部分功能集中在安全方面_包括">1&gt;支持WPA和IEEE 802.11i所定义的大部分功能，这部分功能集中在安全方面，包括：</h3>
<div class="level3">

<p>
●支持WPA-PSK（即WPA-Personal）和WPA-Enterprise（即利用RAIDUS认证服务器来完成身份认证的情况）。
</p>

<p>
●数据加密方面支持CCMP、TKIP、WEP104和WEP40。注意，WEP104和WEP40中的数字代表密钥的长度。104表示密钥长度为104个二进制位（如以ASCII字符个数来计算的话，WEP104支持的密钥长度为13个ASCII字符）。
</p>

<p>
●完全支持WPA和WPA2，包括PMKSA缓存，预认证（pre-authentication）等功能。
</p>

<p>
●支持IEEE 802.11r和802.11w，其中802.11r规范定义了快速基础服务转移（Fast Transition）功能，而802.11w则新增了对管理帧的安全保护机制。支持WFA制定的Wi-Fi Proctected Setup功能、P2P、TDLS等。
</p>

</div>
<!-- EDIT3 SECTION "1>支持WPA和IEEE 802.11i所定义的大部分功能，这部分功能集中在安全方面，包括：" [1057-1890] -->
<h3 class="sectionedit4" id="支持多种eap_method_主要和8021x中supplicant的功能有关_wpa_supplicant支持多达25种eap_method_包括">2&gt;支持多种EAP Method：主要和802.1X中Supplicant的功能有关，wpa_supplicant支持多达25种EAP Method，包括：</h3>
<div class="level3">

<p>
●EAP-TLS：TLS（Transport Layer Security）本身是一种传输层安全协议，它利用密钥算法提供端点身份认证与通讯保密，其基础是公钥基础设施（public key infrastructure，简称PKI）。EAP-TLS定义于RFC 5216。
</p>

<p>
●EAP-PEAP：PEAP（Protected Extensible Authentication Protocol，可扩展EAP）由微软、思科以及RSA Security三个公司共同开发，是一种利用证书加用户名和密码来进行身份验证的方法。
</p>

<p>
●EAP-TTLS：它是TLS的拓展，全名为Tunneled Transport Layer Security（隧道传输层安全协议），相比TLS，它简化了认证过程中客户端的工作。
</p>

<p>
●EAP-SIM、EAP-PSK、EAP-GPSK等其他认证方法。
</p>

<p>
☆<a href="http://en.wikipedia.org/wiki/Extensible_Authentication_Protocol" class="urlextern" title="http://en.wikipedia.org/wiki/Extensible_Authentication_Protocol"  rel="nofollow">http://en.wikipedia.org/wiki/Extensible_Authentication_Protocol</a>以了解更多EAP方法的知识
</p>

</div>
<!-- EDIT4 SECTION "2>支持多种EAP Method：主要和802.1X中Supplicant的功能有关，wpa_supplicant支持多达25种EAP Method，包括：" [1891-2837] -->
<h3 class="sectionedit5" id="支持的无线网卡驱动">3&gt;支持的无线网卡驱动：</h3>
<div class="level3">

<p>
●支持nl80211/cfg80211驱动
</p>

<p>
●支持wext驱动
</p>

<p>
●Wired Ethernet drivers
</p>

<p>
●BSD net80211 layer (e.g., Atheros driver) (FreeBSD 6-CURRENT and NetBSD current)
</p>

<p>
●Windows NDIS drivers (Windows; at least XP and 2000, others not tested)
</p>

<p>
wpa_supplicant经过谷歌修改移植到android平台上，它是用户空间中无线网络部分的核心模块，所有Framework中wifi相关的操作最终都是借由wpa_supplicant来完成。
</p>

</div>
<!-- EDIT5 SECTION "3>支持的无线网卡驱动：" [2838-3323] -->
<h2 class="sectionedit6" id="wpa_supplicant都有哪些部分组成_框架是什么">2.Wpa_supplicant都有哪些部分组成，框架是什么?</h2>
<div class="level2">

<p>
<a href="/dokuwiki/lib/exe/detail.php/android;wifi;wpa_supplicant;wpa_supplicant.png?id=android%3Awifi%3Awpa_supplicant%3Awpa_supplicant%E5%88%86%E6%9E%90" class="media" title="android:wifi:wpa_supplicant:wpa_supplicant.png"><img src="/dokuwiki/lib/exe/fetch.php/android;wifi;wpa_supplicant;wpa_supplicant.png" class="media" alt="" /></a>
</p>

<p>
从上图看wpa_supplicant主要组成部分：
</p>

<p>
●wpa_supplicant所有工作都围绕事件（对应图中的event loop模块）展开。wpa_supplicant没有使用多线程编程，所有事件处理都在主线程中完成。
</p>

<p>
●位于event loop模块下方的driver i/f（i/f代表interface）接口模块用于隔离和底层驱动直接交互的那些driver控制模块（如wext、ndiswrapper、nl80211等，wpa_supplicant中称之为driver wrapper）。这些driver wrapper和平台以及芯片所使用的驱动相关。不过，由于driver i/f的隔离作用，wpa_supplicant中其他模块将能最大程度保持平台以及驱动无关性。
</p>

<p>
●driver wrapper经常要返回一些信息给上层。wpa_supplicant中，这些信息将通过driver events的方式反馈给wpa_supplicant供其他模块进行处理。
</p>

<p>
●EAP以及EAPOL协议，除了定义消息格式外，RFC4137文档定义了EAP状态机，而802.1X文档中还定义了EAPOL状态机。wpa_supplicant根据这两个协议分别实现了EAP和EAPOL状态机。除此之外，wpa_supplicant还定义了自己的状态机（即WPA/WPA2 State Machine）。
</p>

<p>
●wpa_supplicant实现了多种EAP方法，如图中EAP method模块所示。另外它还包含了TLS模块和crypto模块用于支持对应的EAP方法。
</p>

<p>
●EAPOL以及EAP消息都属于LLC层数据，所以wpa_supplicant的l2_packet模块用于收发EAPOL和EAP消息。
</p>

<p>
●wpa_supplicant支持较多的配置参数，这些参数的处理由configuration模块完成。
</p>

<p>
●wpa_supplicant是C/S结构中的Server端，它通过ctrl i/f模块向客户端提供通信接口。Linux/Unix平台中，Client端利用Unix域socket与其通信。目前常用的Client端wpa_cli（无界面的命令行程序）和wpa_gui（UI用Qt实现）。
</p>

<p>
关于WPA/WPA2 80211i 80211x EAP EAPOL见另一文档介绍。
</p>

</div>
<!-- EDIT6 SECTION "2.Wpa_supplicant都有哪些部分组成，框架是什么?" [3324-5297] -->
<h2 class="sectionedit7" id="wpa_supplicant是如何初始化的">3.Wpa_supplicant是如何初始化的?</h2>
<div class="level2">

<p>
<a href="/dokuwiki/lib/exe/detail.php/android;wifi;wpa_supplicant;wpa_supplicnat.jpg?id=android%3Awifi%3Awpa_supplicant%3Awpa_supplicant%E5%88%86%E6%9E%90" class="media" title="android:wifi:wpa_supplicant:wpa_supplicnat.jpg"><img src="/dokuwiki/lib/exe/fetch.php/android;wifi;wpa_supplicant;wpa_supplicnat.jpg" class="media" alt="" /></a>
</p>

<p>
看不清楚？好吧，见附件下载。
</p>

</div>
<!-- EDIT7 SECTION "3.Wpa_supplicant是如何初始化的?" [5298-5447] -->
<h2 class="sectionedit8" id="wpa_supplicant是如何完成_承上启下_的桥梁功能的">4.Wpa_supplicant是如何完成“承上启下”的桥梁功能的？</h2>
<div class="level2">

</div>
<!-- EDIT8 SECTION "4.Wpa_supplicant是如何完成“承上启下”的桥梁功能的？" [5448-5531] -->
<h3 class="sectionedit9" id="上行接口_即与framework层通信接口_是通过socket通信_上面流程图中已经分析了两种接口的初始化与建立">1&gt;上行接口，即与framework层通信接口，是通过socket通信，上面流程图中已经分析了两种接口的初始化与建立：</h3>
<div class="level3">

<p>
● global control interface: 用于配置（增加或删除）网络接口。
</p>

<p>
● ctrl interface: 与其他外部模块交互的控制接口。
</p>

<p>
例如，在初始化时，android 平台的wifi.c中的 wifi_connect_to_supplicant函数调用wpa_ctrl_open函数创建两个socket，一个是ctrl interface，另一个就是monitor interface,monitor interface这个接口用于监测从wpa_supplicant发出的event事件。
这两个socket创建成功后，monitor interface 会发送ATTACH到wpa_supplicant模块，wpa_supplicant模块收到后，会将该客户端的socket信息记录下来，用于以后发送事件时用（由于用的是DGRAM的方式）。
</p>

<p>
关于控制接口命令：
</p>
<pre class="code">     PING
     MIB
     STATUS
     STATUS-VERBOSE
     PMKSA
     SET &lt;variable&gt; &lt;valus&gt;
     LOGON
     LOGOFF
     REASSOCIATE
     RECONNECT
     PREAUTH &lt;BSSID&gt;
     ATTACH
     DETACH
     LEVEL &lt;debug level&gt;
     RECONFIGURE
     TERMINATE
     BSSID &lt;network id&gt; &lt;BSSID&gt;
     LIST_NETWORKS
     DISCONNECT
     SCAN
     SCAN_RESULTS
     BSS
     SELECT_NETWORK &lt;network id&gt;
     ENABLE_NETWORK &lt;network id&gt;
     DISABLE_NETWORK &lt;network id&gt;
     ADD_NETWORK
     REMOVE_NETWORK &lt;network id&gt;
     SET_NETWORK &lt;network id&gt; &lt;variable&gt; &lt;value&gt;
     GET_NETWORK &lt;network id&gt; &lt;variable&gt;
     SAVE_CONFIG</pre>

</div>
<!-- EDIT9 SECTION "1>上行接口，即与framework层通信接口，是通过socket通信，上面流程图中已经分析了两种接口的初始化与建立：" [5532-7048] -->
<h3 class="sectionedit10" id="下行接口_即最终实现与kernel_driver层通信_待具体分析">2&gt;下行接口，即最终实现与kernel driver层通信（待具体分析）：</h3>
<div class="level3">

<p>
● socket for ioctl: 发送命令到kernel space。
</p>

<p>
● socket (netlink) for interact between kernel and userspace(AF_NETLINK, NETLINK_ROUTE): 接受kernel发送上来的event。
</p>

<p>
● socket for l2 packet(PF_PACKET): 处理802.1x报文。
</p>

</div>
<!-- EDIT10 SECTION "2>下行接口，即最终实现与kernel driver层通信（待具体分析）：" [7049-7384] -->
<h2 class="sectionedit11" id="wpa_supplicant工具使用_wpa_supplicantconf的格式">5.wpa_supplicant工具使用，Wpa_supplicant.conf的格式？</h2>
<div class="level2">

</div>
<!-- EDIT11 SECTION "5.wpa_supplicant工具使用，Wpa_supplicant.conf的格式？" [7385-7459] -->
<h2 class="sectionedit12" id="资源列表">6.资源列表.</h2>
<div class="level2">

</div>
<!-- EDIT12 SECTION "6.资源列表." [7460-] -->