a:406:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:0;}i:2;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:"NFC(近场通信)";}i:2;i:1;}i:3;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18;}i:4;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18;}i:5;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:374:"NFC是一套短距离的无线通信，通常距离是4厘米或更短。NFC工作频率是13.56M Hz,传输速率是106kbit/s 到848kbit/s. NFC总是在一个发起者和一个被动目标之间发生。发起者发出近场无线电波，这个近场可以给被动目标供电。这些被动的目标包括不需要电源的标签，卡，也可以是有电源的设备。";}i:2;i:22;}i:6;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:396;}i:7;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:396;}i:8;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:216:"与其他无线通信技术比较， 例如蓝牙和WiFi， NFC提供更低带宽和距离，并且低成本，不需要供电，不需要实现匹配，整个通信过程仅仅是短短的靠近一秒就能完成。";}i:2;i:398;}i:9;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:614;}i:10;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:614;}i:11;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:197:"一个带有NFC支持的android设备通常是一个发起者。也可以作为NFC的读写设备。他将检测NFC tags并且打开一个Activity来处理. Android 2.3.3还有支持有限的P2P。";}i:2;i:616;}i:12;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:813;}i:13;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:813;}i:14;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:262:"Tags分很多种，其中简单的只提供读写段，有的只能读。复杂的tags可以支持一些运算，加密来控制对tags里数据段的读写。甚至一些tags上有简单的操作系统，允许一些复杂的交互和可以执行一些代码。";}i:2;i:815;}i:15;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1077;}i:16;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1077;}i:17;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:"API概览";}i:2;i:1079;}i:18;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1088;}i:19;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1088;}i:20;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:135:"Android.nfc  package包含顶层类用来与本地NFC适配器交互. 这些类可以表示被检测到的tags和用NDEF数据格式。";}i:2;i:1090;}i:21;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1225;}i:22;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1225;}i:23;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:"Class";}i:2;i:1227;}i:24;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1232;}i:25;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1232;}i:26;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:"Description";}i:2;i:1236;}i:27;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1247;}i:28;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1247;}i:29;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:"NfcManager";}i:2;i:1249;}i:30;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1259;}i:31;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1259;}i:32;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:244:"一个NFC adapter的管理器，可以列出所有此android设备支持的NFC adapter.只不过大部分android 设备只有一个NFC adapter，所以你大部分情况下可以直接用静态方法 getDefaultAdapter(context)来取适配器。";}i:2;i:1263;}i:33;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1507;}i:34;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1507;}i:35;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:"NfcAdapter";}i:2;i:1509;}i:36;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1519;}i:37;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1519;}i:38;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:255:"表示本设备的NFC adapter,可以定义Intent来请求将系统检测到tags的提醒发送到你的Activity.并提供方法去注册前台tag提醒发布和前台NDEF推送。 前台NDEF推送是当前android版本唯一支持的p2p NFC通信方式。";}i:2;i:1523;}i:39;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1778;}i:40;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1778;}i:41;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:"NdefMessage and NdefRecord";}i:2;i:1780;}i:42;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1806;}i:43;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1806;}i:44;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:457:"NDEF是NFC论坛定义的数据结构，用来有效的存数据到NFC tags.比如文本，URL，和其他MIME类型。一个NdefMessage扮演一个容器，这个容器存哪些发送和读到的数据。一个NdefMessage对象包含0或多个NdefRecord,每个NDEF record有一个类型，比如文本，URL，智慧型海报/广告，或其他MIME数据。在NDEFMessage里的第一个NfcRecord的类型用来发送tag到一个android设备上的activity.";}i:2;i:1810;}i:45;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2267;}i:46;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2267;}i:47;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"Tag";}i:2;i:2269;}i:48;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2272;}i:49;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2272;}i:50;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:107:"标示一个被动的NFC目标，比如tag，card，钥匙挂扣，甚至是一个电话模拟的的NFC卡.";}i:2;i:2276;}i:51;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2383;}i:52;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2383;}i:53;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:334:"当一个tag被检测到，一个tag对象将被创建并且封装到一个Intent里，然后NFC 发布系统将这个Intent用startActivity发送到注册了接受这种Intent的activity里。你可以用getTechList()方法来得到这个tag支持的技术细节和创建一个android.nfc.tech提供的相应的TagTechnology对象。";}i:2;i:2385;}i:54;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2719;}i:55;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2719;}i:56;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:148:"android.nfc.tech package 包含那些对tag查询属性和进行I/O操作的类。这些类分别标示一个tag支持的不同的NFC技术标准。";}i:2;i:2721;}i:57;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2869;}i:58;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2869;}i:59;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:"Class";}i:2;i:2871;}i:60;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2876;}i:61;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2876;}i:62;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:"Description";}i:2;i:2880;}i:63;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2891;}i:64;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2891;}i:65;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:"TagTechnology";}i:2;i:2893;}i:66;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2906;}i:67;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2906;}i:68;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:62:"这个接口是下面所有tag technology类必须实现的。";}i:2;i:2910;}i:69;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2972;}i:70;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2972;}i:71;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:114:"NfcA   支持ISO 14443-3A 标准的操作。Provides access to NFC-A (ISO 14443-3A) properties and I/O operations.";}i:2;i:2974;}i:72;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3088;}i:73;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3088;}i:74;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:77:"NfcB   Provides access to NFC-B (ISO 14443-3B) properties and I/O operations.";}i:2;i:3090;}i:75;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3167;}i:76;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3167;}i:77;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:75:"NfcF   Provides access to NFC-F (JIS 6319-4) properties and I/O operations.";}i:2;i:3169;}i:78;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3244;}i:79;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3244;}i:80;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:74:"NfcV   Provides access to NFC-V (ISO 15693) properties and I/O operations.";}i:2;i:3246;}i:81;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3320;}i:82;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3320;}i:83;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:78:"IsoDep Provides access to ISO-DEP (ISO 14443-4) properties and I/O operations.";}i:2;i:3322;}i:84;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3400;}i:85;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3400;}i:86;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:83:"Ndef   提供对那些被格式化为NDEF的tag的数据的访问和其他操作。";}i:2;i:3402;}i:87;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3485;}i:88;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3485;}i:89;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:89:"Provides access to NDEF data and operations on NFC tags that have been formatted as NDEF.";}i:2;i:3487;}i:90;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3576;}i:91;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3576;}i:92;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:14:"NdefFormatable";}i:2;i:3578;}i:93;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3592;}i:94;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3592;}i:95;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:76:"对那些可以被格式化成NDEF格式的tag提供一个格式化的操作";}i:2;i:3596;}i:96;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3672;}i:97;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3672;}i:98;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:"MifareClassic";}i:2;i:3674;}i:99;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3687;}i:100;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3687;}i:101;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:87:"如果android设备支持MIFARE，提供对MIFARE Classic目标的属性和I/O操作。";}i:2;i:3691;}i:102;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3778;}i:103;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3778;}i:104;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"MifareUltralight";}i:2;i:3780;}i:105;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3796;}i:106;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3796;}i:107;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:90:"如果android设备支持MIFARE，提供对MIFARE Ultralight目标的属性和I/O操作。";}i:2;i:3800;}i:108;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3890;}i:109;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3890;}i:110;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:35:"声明Android Manifest.xml的元素";}i:2;i:3892;}i:111;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3927;}i:112;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3927;}i:113;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:133:"在你能访问一个设备的NFC硬件和正确的处理NFC的Intent之前，需要在AndroidManifest.xml中先声明下面的项：";}i:2;i:3929;}i:114;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4062;}i:115;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4062;}i:116;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:"1.     NFC使用 <uses-permission> 元素来访问NFC硬件:";}i:2;i:4064;}i:117;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4124;}i:118;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4124;}i:119;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:30:"<uses-permission android:name=";}i:2;i:4126;}i:120;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:4156;}i:121;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"android.permission.NFC";}i:2;i:4157;}i:122;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:4179;}i:123;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" />";}i:2;i:4180;}i:124;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4183;}i:125;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4183;}i:126;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:91:"2.     最小SDK版本需要设置正确，API level 9只包含有限的tag支持,包括：";}i:2;i:4185;}i:127;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4276;}i:128;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:154:"  .通过ACTION_TAG_DISCOVERED来发布Tag信息
  .只有通过EXTRA_NDEF_MESSAGES扩展来访问NDEF消息
  .其他的tag属性和I/O操作都不支持";}i:2;i:4276;}i:129;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4276;}i:130;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:78:"所以你可能想要用API level 10来实现对tag的广泛的读写支持。";}i:2;i:4438;}i:131;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4516;}i:132;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4516;}i:133;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:32:"<uses-sdk android:minSdkVersion=";}i:2;i:4518;}i:134;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:4550;}i:135;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"10";}i:2;i:4551;}i:136;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:4553;}i:137;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"/>";}i:2;i:4554;}i:138;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4556;}i:139;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4556;}i:140;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:93:"3.     uses-feature 元素定义：你的程序可以再android市场里显示有NFC硬件。";}i:2;i:4558;}i:141;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4651;}i:142;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4651;}i:143;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:27:"<uses-feature android:name=";}i:2;i:4653;}i:144;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:4680;}i:145;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:"android.hardware.nfc";}i:2;i:4681;}i:146;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:4701;}i:147;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:" android:required=";}i:2;i:4702;}i:148;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:4720;}i:149;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"true";}i:2;i:4721;}i:150;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:4725;}i:151;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:" />";}i:2;i:4726;}i:152;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4729;}i:153;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4729;}i:154;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:118:"4.      NFC intent filter告诉android系统你的activity能处理NFC数据，可以定义1个或多个intent filter:";}i:2;i:4731;}i:155;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4849;}i:156;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4849;}i:157;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"<intent-filter>";}i:2;i:4851;}i:158;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4866;}i:159;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:97:"<action android:name="android.nfc.action.NDEF_DISCOVERED"/>
<data android:mimeType="mime/type" />";}i:2;i:4866;}i:160;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4866;}i:161;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"</intent-filter>";}i:2;i:4969;}i:162;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4985;}i:163;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4985;}i:164;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"<intent-filter>";}i:2;i:4987;}i:165;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5002;}i:166;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:181:"<action android:name="android.nfc.action.TECH_DISCOVERED"/>
<meta-data android:name="android.nfc.action.TECH_DISCOVERED"
              android:resource="@xml/nfc_tech_filter.xml" />";}i:2;i:5002;}i:167;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5002;}i:168;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"</intent-filter>";}i:2;i:5191;}i:169;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5207;}i:170;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5207;}i:171;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"<intent-filter>";}i:2;i:5209;}i:172;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5224;}i:173;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:58:"<action android:name="android.nfc.action.TAG_DISCOVERED"/>";}i:2;i:5224;}i:174;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5224;}i:175;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"</intent-filter>";}i:2;i:5286;}i:176;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5302;}i:177;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5302;}i:178;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:85:"上边3个intent filters 有优先级，更多信息可以看下面的Tag发布系统";}i:2;i:5304;}i:179;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5389;}i:180;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5389;}i:181;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:75:"也可以看NFCDemo例子的 AndroidManifest.xml来有个更深的理解。";}i:2;i:5391;}i:182;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5466;}i:183;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5466;}i:184;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"Tag发布系统";}i:2;i:5468;}i:185;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5483;}i:186;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5483;}i:187;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:611:"当android设备扫描到一个NFC tag，通用的行为是自动找最合适的Activity会处理这个tag Intent而不需要用户来选择哪个Activity来处理。因为设备扫描NFC tags是在很短的范围和时间，如果让用户选择的话，那就有可能需要移动设备，这样将会打断这个扫描过程。你应该开发你只处理需要处理的tags的Activity，以防止让用户选择使用哪个Activity来处理的情况。Android提供两个系统来帮助你正确的识别一个NFC tag是否是你的Activity想要处理的：Intent发布系统和前台Activity发布系统。";}i:2;i:5485;}i:188;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6096;}i:189;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6096;}i:190;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:315:"Intent发布系统检查所有Activities的intent filters，找出那些定义了可以处理此tag的Activity，如果有多个Activity都配置了处理同一个tag Intent，那么将使用Activity选择器来让用户选择使用哪个Activity。用户选择之后，将使用选择的Activity来处理此Intent.";}i:2;i:6098;}i:191;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6413;}i:192;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6413;}i:193;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:356:"前台发布系统允许一个Activity覆盖掉Intent发布系统而首先处理此tag Intent，这要求你将要处理Tag Intent的Activity运行在前台，这样当一个NFC tag被扫描到，系统先检测前台的Activity是否支持处理此Intent，如果支持，即将此Intent传给此Activity，如果不支持，则转到Intent发布系统。";}i:2;i:6415;}i:194;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6771;}i:195;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6771;}i:196;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:"使用Intent发布系统";}i:2;i:6773;}i:197;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6797;}i:198;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6797;}i:199;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:166:"Intent发布系统指定了3个intent有不同的优先级。通常当一个tag被检测到之后，Intent就被启动（start）了，这个启动遵循以下行为:";}i:2;i:6799;}i:200;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6965;}i:201;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6965;}i:202;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:529:"·         android.nfc.action.NDEF_DISCOVERED: 这个intent是在一个包含NDEF负载的tag被检测到时启动，这是最高优先级的intent, android系统不会让你指定一个Intent能处理所有的NFC数据类型，你必须在AndroidManifest.xml中指定与NFC tag对应的<data>元素，这样当扫描到的tag传过来的数据类型与你定义的相匹配时，你的Activity就会被调用。例如想处理一个包含plain text 的 NDEF_DISCOVERED intent ，你要按照如下定义AndroidManifest.xml file:";}i:2;i:6967;}i:203;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7496;}i:204;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7496;}i:205;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"<intent-filter>";}i:2;i:7498;}i:206;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7513;}i:207;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:102:"  <action android:name="android.nfc.action.NDEF_DISCOVERED"/>
  <data android:mimeType="text/plain" />";}i:2;i:7513;}i:208;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7513;}i:209;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"</intent-filter>";}i:2;i:7621;}i:210;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7637;}i:211;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7637;}i:212;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:211:"如果NDEF_DISCOVERED intent 已经被启动，TECH_DISCOVERED 和 TAG_DISCOVERED intents 将不会被启动。假如一个未知的tag或者不包含NDEF负载的tag被检测到，此Intent就不会被启动。";}i:2;i:7639;}i:213;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7850;}i:214;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7850;}i:215;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:384:"·         android.nfc.action.TECH_DISCOVERED: 如果 NDEF_DISCOVERED intent没启动或者没有一个Activity的filter检测NDEF_DISCOVERED ，并且此tag是已知的，那么此TECH_DISCOVERED Intent将会启动. TECH_DISCOVERED intent要求你在一个资源文件里(xml)里指定你要支持technologies列表。更多细节请看下面的Specifying tag technologies to handle.";}i:2;i:7852;}i:216;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8236;}i:217;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8236;}i:218;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:183:"·         android.nfc.action.TAG_DISCOVERED: 如果没有一个activity处理_DISCOVERED and TECH_DISCOVERED intents或者tag被检测为未知的，那么此Intent将会被启动。";}i:2;i:8238;}i:219;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8421;}i:220;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8421;}i:221;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:64:"Specifying tag technologies to handle指定处理的technologies";}i:2;i:8423;}i:222;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8487;}i:223;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8487;}i:224;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:453:"假如你的Activity在AndroidManifest.xml文件里声明了处理android.nfc.action.TECH_DISCOVERED intent ，你必须创建一个Xml格式的资源文件，并加上你的activity支持的technologies到tech-list集合里。这样你的activity将被认作能处理这些tech-list的处理者，如果tag使用的technology属于你的定义的list里，你的Activity将接收此Intent。你可以用getTechList()来获得tag支持的technologies。";}i:2;i:8489;}i:225;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8942;}i:226;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8942;}i:227;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:191:"例如：如果一个tag被检测到支持MifareClassic, NdefFormatable, 和 NfcA，你的tech-list集合必须指定了其中的一项或者多项来保证你的Activity能处理此Intent。";}i:2;i:8944;}i:228;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9135;}i:229;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9135;}i:230;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:186:"下面是一个资源文件例子，定义了所有的technologies. 你可以根据需要删掉不需要的项，将此文件以任意名字+.xml保存到<project-root>/res/xml文件夹.";}i:2;i:9137;}i:231;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9323;}i:232;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9323;}i:233;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:"<resources xmlns:xliff=";}i:2;i:9325;}i:234;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:9348;}i:235;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:"urn:oasis:names:tc:xliff:document:1.2";}i:2;i:9349;}i:236;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:9386;}i:237;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:">";}i:2;i:9387;}i:238;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9388;}i:239;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:438:"  <tech-list>
      <tech>android.nfc.tech.IsoDep</tech>
      <tech>android.nfc.tech.NfcA</tech>        
      <tech>android.nfc.tech.NfcB</tech>
      <tech>android.nfc.tech.NfcF</tech>
      <tech>android.nfc.tech.NfcV</tech>
      <tech>android.nfc.tech.Ndef</tech>
      <tech>android.nfc.tech.NdefFormatable</tech>
      <tech>android.nfc.tech.MifareClassic</tech>
      <tech>android.nfc.tech.MifareUltralight</tech>
  </tech-list>";}i:2;i:9388;}i:240;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9388;}i:241;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"</resources>";}i:2;i:9850;}i:242;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9862;}i:243;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9862;}i:244;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:332:"你也可以指定多个tech-list集合，每个集合都认做独立的。如果任何单个tech-list集合是getTechList()返回的technologies集合的子集，那么你的Activity将被认为匹配了。这个还提供’与’和’或’操作。下面的例子表示支持 NfcA和NDef的卡，或者支持NfcB和NDef的卡：";}i:2;i:9864;}i:245;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10196;}i:246;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10196;}i:247;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:"<resources xmlns:xliff=";}i:2;i:10198;}i:248;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:10221;}i:249;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:"urn:oasis:names:tc:xliff:document:1.2";}i:2;i:10222;}i:250;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:10259;}i:251;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:">";}i:2;i:10260;}i:252;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10261;}i:253;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:118:"  <tech-list>
      <tech>android.nfc.tech.NfcA</tech>        
      <tech>android.nfc.tech.Ndef</tech>
  </tech-list>";}i:2;i:10261;}i:254;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10261;}i:255;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"</resources>";}i:2;i:10389;}i:256;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10401;}i:257;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10401;}i:258;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:"<resources xmlns:xliff=";}i:2;i:10403;}i:259;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:10426;}i:260;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:"urn:oasis:names:tc:xliff:document:1.2";}i:2;i:10427;}i:261;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:10464;}i:262;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:">";}i:2;i:10465;}i:263;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10466;}i:264;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:118:"  <tech-list>
      <tech>android.nfc.tech.NfcB</tech>        
      <tech>android.nfc.tech.Ndef</tech>
  </tech-list>";}i:2;i:10466;}i:265;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10466;}i:266;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"</resources>";}i:2;i:10594;}i:267;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10606;}i:268;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10606;}i:269;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:148:"在 AndroidManifest.xml 文件中, 指定这个tech-list资源文件的方法是在<activity> 元素中创建<meta-data>元素，例如下面例子:";}i:2;i:10608;}i:270;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10756;}i:271;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10756;}i:272;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:"<activity>
";}i:2;i:10758;}i:273;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:10769;}i:274;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"
<intent-filter>";}i:2;i:10772;}i:275;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10788;}i:276;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:61:"  <action android:name="android.nfc.action.TECH_DISCOVERED"/>";}i:2;i:10788;}i:277;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10788;}i:278;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"</intent-filter>";}i:2;i:10853;}i:279;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10869;}i:280;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10869;}i:281;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:"<meta-data android:name=";}i:2;i:10871;}i:282;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:10895;}i:283;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:34:"android.nfc.action.TECH_DISCOVERED";}i:2;i:10896;}i:284;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:10930;}i:285;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10931;}i:286;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:44:"  android:resource="@xml/nfc_tech_filter" />";}i:2;i:10931;}i:287;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10931;}i:288;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:10979;}i:289;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"
</activity>";}i:2;i:10982;}i:290;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10994;}i:291;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10994;}i:292;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:"使用前台发布系统Using the foreground dispatch system";}i:2;i:10996;}i:293;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11056;}i:294;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11056;}i:295;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:134:"前台发布系统允许一个Activity 拦截一个tag Intent 获得最高优先级的处理，这种方式很容易使用和实现：";}i:2;i:11058;}i:296;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11192;}i:297;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11192;}i:298;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:59:"1.     添加下列代码到Activity的onCreate() 方法里";}i:2;i:11194;}i:299;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11253;}i:300;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11253;}i:301;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:115:"a.     创建一个 PendingIntent 对象, 这样Android系统就能在一个tag被检测到时定位到这个对象";}i:2;i:11255;}i:302;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11370;}i:303;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11370;}i:304;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:56:"PendingIntent pendingIntent = PendingIntent.getActivity(";}i:2;i:11372;}i:305;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11428;}i:306;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:86:"  this, 0, new Intent(this, getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0);";}i:2;i:11428;}i:307;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11428;}i:308;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:442:"b.    在Intent filters里声明你想要处理的Intent，一个tag被检测到时先检查前台发布系统，如果前台Activity符合Intent filter的要求，那么前台的Activity的将处理此Intent。如果不符合，前台发布系统将Intent转到Intent发布系统。如果指定了null的Intent filters，当任意tag被检测到时，你将收到TAG_DISCOVERED intent。因此请注意你应该只处理你想要的Intent。";}i:2;i:11519;}i:309;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11962;}i:310;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:441:"  IntentFilter ndef = new IntentFilter(NfcAdapter.ACTION_NDEF_DISCOVERED);
      try {
          ndef.addDataType("*/*");    /* Handles all MIME based dispatches.
                                         You should specify only the ones that you need. */
      }
      catch (MalformedMimeTypeException e) {
          throw new RuntimeException("fail", e);
      }
      intentFiltersArray = new IntentFilter[] {
              ndef,
      };";}i:2;i:11962;}i:311;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11962;}i:312;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:152:"c.     设置一个你程序要处理的Tag technologies的列表，调用Object.class.getName() 方法来获得你想要支持处理的technology类。";}i:2;i:12428;}i:313;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12580;}i:314;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:74:"techListsArray = new String[][] { new String[] { NfcF.class.getName() } };";}i:2;i:12582;}i:315;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12582;}i:316;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:354:"2.     覆盖下面的方法来打开或关闭前台发布系统。比如onPause()和onResume（）方法。必须在主线程里调用enableForegroundDispatch(Activity, PendingIntent, IntentFilter[], String[][]) 而且Activity在前台（可以在onResume()里调用来保证这点）。你也要覆盖onNewIntent回调来处理得到的NFC tag数据。";}i:2;i:12663;}i:317;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13017;}i:318;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13017;}i:319;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:"public void onPause() {";}i:2;i:13019;}i:320;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13042;}i:321;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:62:"  super.onPause();
  mAdapter.disableForegroundDispatch(this);";}i:2;i:13042;}i:322;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13042;}i:323;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"}  ";}i:2;i:13110;}i:324;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13113;}i:325;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13113;}i:326;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:"public void onResume() {";}i:2;i:13115;}i:327;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13139;}i:328;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:113:"  super.onResume();
  mAdapter.enableForegroundDispatch(this, pendingIntent, intentFiltersArray, techListsArray);";}i:2;i:13139;}i:329;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13139;}i:330;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"}";}i:2;i:13258;}i:331;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13259;}i:332;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13259;}i:333;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:40:"public void onNewIntent(Intent intent) {";}i:2;i:13261;}i:334;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13301;}i:335;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:106:"  Tag tagFromIntent = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);
  //do something with tagFromIntent";}i:2;i:13301;}i:336;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13301;}i:337;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"}";}i:2;i:13413;}i:338;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13414;}i:339;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13414;}i:340;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:39:"See the ForegroundDispatch sample from ";}i:2;i:13416;}i:341;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"API";}i:2;i:13455;}i:342;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:" Demos for the complete sample.";}i:2;i:13458;}i:343;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13489;}i:344;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13489;}i:345;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:25:"使用NFC tag上的数据";}i:2;i:13491;}i:346;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13516;}i:347;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13516;}i:348;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:757:"NFC tag上的数据是以字节存放，所以你可以将其转换成其他你想要的格式。当往tag写东西时，你必须以字节格式来写。Android提供API来帮助写符合NDEF标准的信息。使用此标准能保证你的数据在往tag写时能被所有Android NFC设备支持。然而，很多tag使用他们自己的标准来存储数据，这些标准也被Android支持。但你必须自己实现协议栈来读写这些tag。你可以在android.nfc.tech里找到所有支持的technologies，并且可以在TagTechnology接口里对technology有个了解。这一段是简单介绍在android系统里怎样使用NDEF 消息。这不意味着是一个完整的NDEF功能的介绍。但标出了主要需要注意和使用的东西。";}i:2;i:13518;}i:349;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14275;}i:350;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14275;}i:351;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:638:"为了方便使用NDEF消息，android提供NdefRecord 和 NdefMessage来包装原始字节数据为NDEF消息。一个NdefMessage是保存0个或多个NdefRecords的容器。每个NdefRecord有自己的唯一类型名字格式，记录类型和ID来与其他记录区分开。你可以存储不同类型的记录，不同的长度到同一个 NdefMessage。NFC tag容量的限制决定你的NdefMessage的大小。
那些支持Ndef和NdefFormatable技术的tag可以返回和接受NdefMessage对象为参数来进行读写操作。你需要创建你自己的逻辑来为其他在android.nfc.tech的tag技术实现读写字节的操作。";}i:2;i:14277;}i:352;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14915;}i:353;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14915;}i:354;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"你可以从NFC Forum(";}i:2;i:14917;}i:355;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:31:"http://www.nfc-forum.org/specs/";i:1;N;}i:2;i:14939;}i:356;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:145:")下载NDEF消息标准的技术文档，比如纯文本和智慧型海报. NFCDemo例子里声明了纯文本和智慧型海报的NDef 消息。";}i:2;i:14970;}i:357;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15115;}i:358;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15115;}i:359;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"读一个NFC tag";}i:2;i:15117;}i:360;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15133;}i:361;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15133;}i:362;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:241:"当一个NFC tag靠近一个NFC设备，一个相应的Intent将在设备上被创建。然后通知合适的程序来处理此Intent。
下面的方法处理TAG_DISCOVERED intent并且使用迭代器来获得包含在NDEF tag负载的数据";}i:2;i:15135;}i:363;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15376;}i:364;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15376;}i:365;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:15378;}i:366;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:51:"NdefMessage[] getNdefMessages(Intent intent) {
    ";}i:2;i:15380;}i:367;a:3:{i:0;s:13:"emphasis_open";i:1;a:0:{}i:2;i:15431;}i:368;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:480:" Parse the intent
    NdefMessage[] msgs = null;
    String action = intent.getAction();
    if (NfcAdapter.ACTION_TAG_DISCOVERED.equals(action)) {
        Parcelable[] rawMsgs = intent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES);
        if (rawMsgs != null) {
            msgs = new NdefMessage[rawMsgs.length];
            for (int i = 0; i < rawMsgs.length; i++) {
                msgs[i] = (NdefMessage) rawMsgs[i];
            }
        }
        else {
        ";}i:2;i:15433;}i:369;a:3:{i:0;s:14:"emphasis_close";i:1;a:0:{}i:2;i:15913;}i:370;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:325:" Unknown tag type
            byte[] empty = new byte[] {};
            NdefRecord record = new NdefRecord(NdefRecord.TNF_UNKNOWN, empty, empty, empty);
            NdefMessage msg = new NdefMessage(new NdefRecord[] {record});
            msgs = new NdefMessage[] {msg};
        }
    }        
    else {
        Log.e(TAG, ";}i:2;i:15915;}i:371;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:16240;}i:372;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"Unknown intent ";}i:2;i:16241;}i:373;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:16256;}i:374;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:54:" + intent);
        finish();
    }
    return msgs;
}";}i:2;i:16257;}i:375;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:16311;}i:376;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16313;}i:377;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16313;}i:378;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:243:"请记住NFC设备读到的数据是byte类型，所以你可能需要将他转成其他格式来呈现给用户。NFCDemo例子展示了怎样用com.example.android.nfc.record中的类来解析NDEF消息，比如纯文本和智慧型海报。";}i:2;i:16315;}i:379;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16558;}i:380;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16558;}i:381;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:"写NFC tag";}i:2;i:16560;}i:382;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16570;}i:383;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16570;}i:384;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:162:"往NFC tag写东西涉及到构造一个NDEF 消息和使用与tag匹配的Tag技术。下面的代码展示怎样写一个简单的文本到NdefFormatable tag：";}i:2;i:16572;}i:385;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16734;}i:386;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16734;}i:387;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:16736;}i:388;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:138:"NdefFormatable tag = NdefFormatable.get(t);
Locale locale = Locale.US;
final byte[] langBytes = locale.getLanguage().getBytes(Charsets.US_";}i:2;i:16738;}i:389;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:5:"ASCII";}i:2;i:16876;}i:390;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:");
String text = ";}i:2;i:16881;}i:391;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:16898;}i:392;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"Tag, you're it!";}i:2;i:16899;}i:393;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:16914;}i:394;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:483:";
final byte[] textBytes = text.getBytes(Charsets.UTF_8);
final int utfBit = 0;
final char status = (char) (utfBit + langBytes.length);
final byte[] data = Bytes.concat(new byte[] {(byte) status}, langBytes, textBytes);
NdefRecord record = NdefRecord(NdefRecord.TNF_WELL_KNOWN, NdefRecord.RTD_TEXT, new byte[0], data);
try {
    NdefRecord[] records = {text};
    NdefMessage message = new NdefMessage(records);
    tag.connect();
    tag.format(message);
}
catch (Exception e){
    ";}i:2;i:16915;}i:395;a:3:{i:0;s:13:"emphasis_open";i:1;a:0:{}i:2;i:17398;}i:396;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1544:"do error handling
}''

点对点的数据交换

前台推送技术支持简单点对点的数据交换，你可以用enableForegroundNdefPush(Activity, NdefMessage) 方法来打开此功能. 为了用这个功能：

·         推送数据的Activity必须是前台Activity。

·         你必须将你要发送的数据封装到NdefMessage对象里。

·         接收推送数据的设备必须支持com.android.npp  NDEF推送协议，这个对于Android设备是可选的

假如你的Activity打开了前台推送功能并且位于前台，这时标准的Intent发布系统是禁止的。然而，如果你的Activity允许前台发布系统，那么此时检测tag的功能仍然是可用的，不过只适用于前台发布系统。

要打开前台推送:

1.     创建一个你要推送给其他NFC设备的包含NdefRecords的NdefMessage。

2.     在你的Activity里实现onResume() 和 onPause() 的回调来正确处理前台推送的生命周期。你必须在你的Activity位于前台并在主线程里调用enableForegroundNdefPush(Activity, NdefMessage) （可以在onResume()里调用来保证这点）.

public void onResume() {
    super.onResume();
    if (mAdapter != null)
        mAdapter.enableForegroundNdefPush(this, myNdefMessage);
}
public void onPause() {
    super.onPause();
    if (mAdapter != null)
        mAdapter.disableForegroundNdefPush(this);
}

当Activity位于前台，你可以靠近另外一个NFC设备来推送数据。请参考例子ForegroundNdefPush来了解点对点数据交换。
 ";}i:2;i:17400;}i:397;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"---";}i:2;i:18944;}i:398;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:18947;}i:399;a:3:{i:0;s:14:"emphasis_close";i:1;a:0:{}i:2;i:18948;}i:400;a:3:{i:0;s:9:"emaillink";i:1;a:2:{i:0;s:17:"ting.yang@sim.com";i:1;s:9:"ting.yang";}i:2;i:18950;}i:401;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:" 2014/04/17 11:31";}i:2;i:18981;}i:402;a:3:{i:0;s:13:"emphasis_open";i:1;a:0:{}i:2;i:18998;}i:403;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:0:"";}i:2;i:19000;}i:404;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:19000;}i:405;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:19000;}}