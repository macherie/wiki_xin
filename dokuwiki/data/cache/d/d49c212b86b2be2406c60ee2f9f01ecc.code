<span class="kw4">static</span> boolean_t
<span class="co2">#ifdef CONFIG_E1000_NAPI</span>
e1000_clean_rx_irq<span class="br0">&#40;</span><span class="kw4">struct</span> e1000_adapter <span class="sy0">*</span>adapter<span class="sy0">,</span> <span class="kw4">int</span> <span class="sy0">*</span>work_done<span class="sy0">,</span>
                   <span class="kw4">int</span> work_to_do<span class="br0">&#41;</span>
<span class="co2">#else</span>
e1000_clean_rx_irq<span class="br0">&#40;</span><span class="kw4">struct</span> e1000_adapter <span class="sy0">*</span>adapter<span class="br0">&#41;</span>
<span class="co2">#endif</span>
<span class="br0">&#123;</span>
       <span class="coMULTI">/*这里很清楚，获取设备的环形缓冲区指针。*/</span>
       <span class="kw4">struct</span> e1000_desc_ring <span class="sy0">*</span>rx_ring <span class="sy0">=</span> <span class="sy0">&amp;</span>adapter<span class="sy0">-&gt;</span>rx_ring<span class="sy0">;</span>
       <span class="kw4">struct</span> net_device <span class="sy0">*</span>netdev <span class="sy0">=</span> adapter<span class="sy0">-&gt;</span>netdev<span class="sy0">;</span>
       <span class="kw4">struct</span> pci_dev <span class="sy0">*</span>pdev <span class="sy0">=</span> adapter<span class="sy0">-&gt;</span>pdev<span class="sy0">;</span>
       <span class="kw4">struct</span> e1000_rx_desc <span class="sy0">*</span>rx_desc<span class="sy0">;</span>
       <span class="kw4">struct</span> e1000_buffer <span class="sy0">*</span>buffer_info<span class="sy0">;</span>
       <span class="kw4">struct</span> sk_buff <span class="sy0">*</span>skb<span class="sy0">;</span>
       <span class="kw4">unsigned</span> <span class="kw4">long</span> flags<span class="sy0">;</span>
       <span class="kw4">uint32_t</span> length<span class="sy0">;</span>
       <span class="kw4">uint8_t</span> last_byte<span class="sy0">;</span>
       <span class="kw4">unsigned</span> <span class="kw4">int</span> i<span class="sy0">;</span>
       boolean_t cleaned <span class="sy0">=</span> FALSE<span class="sy0">;</span>
       <span class="coMULTI">/*把i置为下一个要清除的描述符索引，因为在环形缓冲区队列当中，我们即使已经处理完一个缓冲区描述符，也不是将其删除，而是标记为已经处理，这样如果有新的数据需要使用缓冲区，只是将已经处理的缓冲区覆盖而已。*/</span>
       i <span class="sy0">=</span> rx_ring<span class="sy0">-&gt;</span>next_to_clean<span class="sy0">;</span>
       rx_desc <span class="sy0">=</span> E1000_RX_DESC<span class="br0">&#40;</span><span class="sy0">*</span>rx_ring<span class="sy0">,</span> i<span class="br0">&#41;</span><span class="sy0">;</span>
       <span class="coMULTI">/*如果i对应的描述符状态是已经删除，则将这个缓冲区取出来给新的数据使用*/</span>
       <span class="kw1">while</span><span class="br0">&#40;</span>rx_desc<span class="sy0">-&gt;</span>status <span class="sy0">&amp;</span> E1000_RXD_STAT_DD<span class="br0">&#41;</span> <span class="br0">&#123;</span>
              buffer_info <span class="sy0">=</span> <span class="sy0">&amp;</span>rx_ring<span class="sy0">-&gt;</span>buffer_info<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy0">;</span>
&nbsp;
<span class="co2">#ifdef CONFIG_E1000_NAPI</span>
       <span class="coMULTI">/*在配置了NAPI的情况下，判断是否已经完成的工作？，因为是轮询机制，所以我们必须自己计算我们已经处理了多少数据。*/</span>
              <span class="kw1">if</span><span class="br0">&#40;</span><span class="sy0">*</span>work_done <span class="sy0">&gt;=</span> work_to_do<span class="br0">&#41;</span>
                     <span class="kw2">break</span><span class="sy0">;</span>
&nbsp;
              <span class="br0">&#40;</span><span class="sy0">*</span>work_done<span class="br0">&#41;</span><span class="sy0">++;</span>
<span class="co2">#endif</span>
&nbsp;
              cleaned <span class="sy0">=</span> TRUE<span class="sy0">;</span>
              <span class="coMULTI">/*这个是DMA函数，目的是解除与DMA缓冲区的映射关系，这样我们就可以访问这个缓冲区，获取通过DMA传输过来的数据包（skb）。驱动程序在分配环形缓冲区的时候就将缓冲区与DMA进行了映射。*/</span>
              pci_unmap_single<span class="br0">&#40;</span>pdev<span class="sy0">,</span>
                               buffer_info<span class="sy0">-&gt;</span>dma<span class="sy0">,</span>
                               buffer_info<span class="sy0">-&gt;</span>length<span class="sy0">,</span>
                               PCI_DMA_FROMDEVICE<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
              skb <span class="sy0">=</span> buffer_info<span class="sy0">-&gt;</span>skb<span class="sy0">;</span>
              length <span class="sy0">=</span> le16_to_cpu<span class="br0">&#40;</span>rx_desc<span class="sy0">-&gt;</span>length<span class="br0">&#41;</span><span class="sy0">;</span>
              <span class="coMULTI">/*对接收的数据包检查一下正确性。确认是一个正确的数据包以后，将skb的数据指针进行偏移。*/</span>
              skb_put<span class="br0">&#40;</span>skb<span class="sy0">,</span> length <span class="sy0">-</span> ETHERNET_FCS_SIZE<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
              <span class="coMULTI">/* Receive Checksum Offload */</span>
              e1000_rx_checksum<span class="br0">&#40;</span>adapter<span class="sy0">,</span> rx_desc<span class="sy0">,</span> skb<span class="br0">&#41;</span><span class="sy0">;</span>
              <span class="coMULTI">/*获取skb的上层协议类型。这里指的是IP层的协议类型。*/</span>
              skb<span class="sy0">-&gt;</span>protocol <span class="sy0">=</span> eth_type_trans<span class="br0">&#40;</span>skb<span class="sy0">,</span> netdev<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co2">#ifdef CONFIG_E1000_NAPI     </span>
<span class="coMULTI">/*调用函数直接将skb向上层协议处理函数递交，而不是插入什么队列等待继续处理，因此这里可能存在一个问题，如果数据包比较大，处理时间相对较长，则可能造成系统效率的下降。*/</span>
                     netif_receive_skb<span class="br0">&#40;</span>skb<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="co2">#else /* CONFIG_E1000_NAPI */</span>
              <span class="coMULTI">/*如果采用中断模式，则调用netif_rx（）将数据包插入队列中，在随后的软中断处理函数中调用netif_receive_skb（skb）向上层协议处理函数递交。这里就体现出了中断处理机制和轮询机制之间的差别。*/</span>     
                     netif_rx<span class="br0">&#40;</span>skb<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co2">#endif /* CONFIG_E1000_NAPI */</span>
              <span class="coMULTI">/*用全局时间变量修正当前设备的最后数据包接收时间。*/</span>
              netdev<span class="sy0">-&gt;</span>last_rx <span class="sy0">=</span> jiffies<span class="sy0">;</span>
&nbsp;
              rx_desc<span class="sy0">-&gt;</span>status <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
              buffer_info<span class="sy0">-&gt;</span>skb <span class="sy0">=</span> NULL<span class="sy0">;</span>
              <span class="coMULTI">/*这 里是处理环形缓冲区达到队列末尾的情况，因为是环形的，所以到达末尾的下一个就是队列头，这样整个环形队列就不断的循环处理。然后获取下一个描述符的状 态，看看是不是处于删除状态。如果处于这种状态就会将新到达的数据覆盖旧的的缓冲区，如果不处于这种状态跳出循环。并且将当前缓冲区索引号置为下一次查询 的目标。*/</span>
              <span class="kw1">if</span><span class="br0">&#40;</span><span class="sy0">++</span>i <span class="sy0">==</span> rx_ring<span class="sy0">-&gt;</span>count<span class="br0">&#41;</span> i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
              rx_desc <span class="sy0">=</span> E1000_RX_DESC<span class="br0">&#40;</span><span class="sy0">*</span>rx_ring<span class="sy0">,</span> i<span class="br0">&#41;</span><span class="sy0">;</span>
       <span class="br0">&#125;</span>
&nbsp;
       rx_ring<span class="sy0">-&gt;</span>next_to_clean <span class="sy0">=</span> i<span class="sy0">;</span>
       <span class="coMULTI">/*为下一次接收skb做好准备，分配sk_buff内存。出于效率的考虑，如果下一个要使用的缓冲区的sk_buff还没有分配，就分配，如果已经分配，则可以重用。*/</span>
       e1000_alloc_rx_buffers<span class="br0">&#40;</span>adapter<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
       <span class="kw1">return</span> cleaned<span class="sy0">;</span>
<span class="br0">&#125;</span>